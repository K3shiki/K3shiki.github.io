<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>【UE5】多人联机TPS游戏开发（二） —— 基础框架 | Keshiki's Blog</title><meta name="author" content="Keshiki"><meta name="copyright" content="Keshiki"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="【UE5】多人联机TPS游戏开发（二） —— 基础框架 终于要正式开始游戏的制作了。在这一部分中，将进行射击游戏的基本框架的搭建。 这部分内容的目标是完成射击游戏的基础网络框架搭建。虽然这些步骤看起来有些“公式化”，但它们实际上奠定了整个多人游戏的网络底层环境。 这部分有两个首次接触的多人游戏中的重点：复制和RPC。这两项是多人游戏最核心的同步机制。我们需要在各种需要同步的地方使用这两个功能，在实">
<meta property="og:type" content="article">
<meta property="og:title" content="【UE5】多人联机TPS游戏开发（二） —— 基础框架">
<meta property="og:url" content="https://www.keshiki.top/undefined/e6c9f323.html">
<meta property="og:site_name" content="Keshiki&#39;s Blog">
<meta property="og:description" content="【UE5】多人联机TPS游戏开发（二） —— 基础框架 终于要正式开始游戏的制作了。在这一部分中，将进行射击游戏的基本框架的搭建。 这部分内容的目标是完成射击游戏的基础网络框架搭建。虽然这些步骤看起来有些“公式化”，但它们实际上奠定了整个多人游戏的网络底层环境。 这部分有两个首次接触的多人游戏中的重点：复制和RPC。这两项是多人游戏最核心的同步机制。我们需要在各种需要同步的地方使用这两个功能，在实">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.keshiki.top/img/avatar.png">
<meta property="article:published_time" content="2025-07-16T16:00:00.000Z">
<meta property="article:modified_time" content="2025-08-13T17:44:24.211Z">
<meta property="article:author" content="Keshiki">
<meta property="article:tag" content="Keshiki,Keshiki&#39;s Blog,Keshiki的博客,博客,Blog,blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.keshiki.top/img/avatar.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "【UE5】多人联机TPS游戏开发（二） —— 基础框架",
  "url": "https://www.keshiki.top/undefined/e6c9f323.html",
  "image": "https://www.keshiki.top/img/avatar.png",
  "datePublished": "2025-07-16T16:00:00.000Z",
  "dateModified": "2025-08-13T17:44:24.211Z",
  "author": [
    {
      "@type": "Person",
      "name": "Keshiki",
      "url": "https://www.keshiki.top/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://www.keshiki.top/undefined/e6c9f323.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/manifest.json"/><meta name="msapplication-TileColor" content="#39C5BB"/><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/128.png"/><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/16.png"/><link rel="mask-icon" href="/img/siteicon/128.png" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【UE5】多人联机TPS游戏开发（二） —— 基础框架',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Keshiki's Blog" type="application/atom+xml">
</head><body><div id="web_bg" style="background-image: url(https://s21.ax1x.com/2024/12/11/pAbSVg0.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/index.html"><i class="fa-fw fas fa-home"></i><span> 追番</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Keshiki's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">【UE5】多人联机TPS游戏开发（二） —— 基础框架</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/index.html"><i class="fa-fw fas fa-home"></i><span> 追番</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">【UE5】多人联机TPS游戏开发（二） —— 基础框架</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-16T16:00:00.000Z" title="发表于 2025-07-17 00:00:00">2025-07-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-13T17:44:24.211Z" title="更新于 2025-08-14 01:44:24">2025-08-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="【UE5】多人联机TPS游戏开发（二）-——-基础框架"><a href="#【UE5】多人联机TPS游戏开发（二）-——-基础框架" class="headerlink" title="【UE5】多人联机TPS游戏开发（二） —— 基础框架"></a>【UE5】多人联机TPS游戏开发（二） —— 基础框架</h1><blockquote>
<p>终于要正式开始游戏的制作了。在这一部分中，将进行射击游戏的基本框架的搭建。</p>
<p>这部分内容的目标是完成射击游戏的<strong>基础网络框架</strong>搭建。虽然这些步骤看起来有些“公式化”，但它们实际上奠定了整个多人游戏的网络底层环境。</p>
<p>这部分有两个首次接触的多人游戏中的重点：<strong>复制</strong>和<strong>RPC</strong>。这两项是多人游戏最核心的同步机制。我们需要在各种需要同步的地方使用这两个功能，在实现同步功能的同时尽可能地节省网络带宽资源。</p>
<p>除了上面这两个知识点在遇到的时候会有比较详细的解释，其它部分基本上就一笔带过了，毕竟这个项目还有很多别的要讲呢。</p>
</blockquote>
<h2 id="1-安装联机插件"><a href="#1-安装联机插件" class="headerlink" title="1.安装联机插件"></a>1.安装联机插件</h2><p>上一部分中，我花了大量的精力制作了一个用于多人联机的UE5插件，是时候让它发挥作用了。</p>
<p>创建一个新的空项目，将打包好的插件文件复制到正确的位置：</p>
<p><img src="/undefined/e6c9f323/image-20250713200110018.png" alt="image-20250713200110018"></p>
<p>进行一些常规配置：</p>
<p><strong><code>NetDriverDefinitions</code></strong>：指定 UE 在多人模式下使用 <code>SteamNetDriver</code> 作为底层网络驱动。它利用Steam的中继服务器(Steam Relay)实现P2P连接，解决NAT穿透问题；<code>DriverClassNameFallback</code> 则是在无法使用 Steam 时回退到本地 IP 驱动。</p>
<p><strong><code>DefaultPlatformService=Steam</code></strong>：选择 Steam 作为当前网络平台子系统。如果不设置，将默认使用 NULL 子系统（仅支持本地多人）。</p>
<p><strong><code>SteamDevAppId=480</code></strong>：<code>Steam</code>官方提供的测试<code>AppID</code>，任何开发者都可以用它进行多人联机调试。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//Config/DefaultEngine.ini</span><br><span class="line"></span><br><span class="line"><span class="section">[/Script/Engine.GameEngine]</span></span><br><span class="line">	+<span class="attr">NetDriverDefinitions</span>=(DefName=<span class="string">&quot;GameNetDriver&quot;</span>,DriverClassName=<span class="string">&quot;OnlineSubsystemSteam.SteamNetDriver&quot;</span>,DriverClassNameFallback=<span class="string">&quot;OnlineSubsystemUtils.IpNetDriver&quot;</span>)</span><br><span class="line"> </span><br><span class="line">	<span class="section">[OnlineSubsystem]</span></span><br><span class="line">	<span class="attr">DefaultPlatformService</span>=Steam</span><br><span class="line"> </span><br><span class="line">	<span class="section">[OnlineSubsystemSteam]</span></span><br><span class="line">	<span class="attr">bEnabled</span>=<span class="literal">true</span></span><br><span class="line">	<span class="attr">SteamDevAppId</span>=<span class="number">480</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">; If using Sessions</span></span><br><span class="line">	<span class="comment">; bInitServerOnClient=true</span></span><br><span class="line"> </span><br><span class="line">	<span class="section">[/Script/OnlineSubsystemSteam.SteamNetDriver]</span></span><br><span class="line">	<span class="attr">NetConnectionClassName</span>=<span class="string">&quot;OnlineSubsystemSteam.SteamNetConnection&quot;</span></span><br></pre></td></tr></table></figure>
<p>在 <code>.Build.cs</code> 添加模块依赖（<code>OnlineSubsystem</code>, <code>OnlineSubsystemSteam</code>）。</p>
<p>创建大厅地图，将项目打包后发送到另一台电脑，就可以轻松实现联机了。因为大厅地图只是一个空地图，使用的是默认游戏模式，玩家控制的是UE默认的Pawn：一个球。</p>
<p><img src="/undefined/e6c9f323/image-20250707151801594.png" alt="image-20250707151801594"></p>
<h2 id="2-项目基础搭建"><a href="#2-项目基础搭建" class="headerlink" title="2.项目基础搭建"></a>2.项目基础搭建</h2><p>在完成网络环境验证后，就可以开始搭建射击游戏的最基础框架了，包括角色、动画和游戏模式等。</p>
<h3 id="2-1-角色"><a href="#2-1-角色" class="headerlink" title="2.1 角色"></a>2.1 角色</h3><p>这套流程已经进行过不知道多少次了，这里直接一笔带过。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CameraBoom = <span class="built_in">CreateDefaultSubobject</span>&lt;USpringArmComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;CameraBoom&quot;</span>));</span><br><span class="line">CameraBoom-&gt;<span class="built_in">SetupAttachment</span>(<span class="built_in">GetMesh</span>());</span><br><span class="line">CameraBoom-&gt;TargetArmLength = <span class="number">600.f</span>;</span><br><span class="line">CameraBoom-&gt;bUsePawnControlRotation = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">FollowCamera = <span class="built_in">CreateDefaultSubobject</span>&lt;UCameraComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;FollowCamera&quot;</span>));</span><br><span class="line">FollowCamera-&gt;<span class="built_in">SetupAttachment</span>(CameraBoom, USpringArmComponent::SocketName);</span><br><span class="line">FollowCamera-&gt;bUsePawnControlRotation = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">bUseControllerRotationYaw = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">GetCharacterMovement</span>()-&gt;bOrientRotationToMovement = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>网格体和增强输入子系统的配置都在蓝图中完成。</p>
<h3 id="2-2-大厅游戏模式"><a href="#2-2-大厅游戏模式" class="headerlink" title="2.2 大厅游戏模式"></a>2.2 大厅游戏模式</h3><p>游戏模式是以关卡为单位，规定关卡中的一些规则的一个类。而大厅作为一个关卡，也可以通过游戏模式去进行一些管理。</p>
<p>这里创建一个简单的游戏模式<code>LobbyGameNide</code>，重写了<code>PostLogin</code>函数，规定当大厅人数达到要求后就使用<code>ServerTravel</code>函数将所有玩家传送到游戏地图。<code>PostLogin</code>在服务器端调用，表示有新的客户端成功连接到该关卡。这里在测试时规定的是写死的2个玩家，之后会实现通过菜单进行配置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ALobbyGameMode::PostLogin</span><span class="params">(APlayerController* NewPlayer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">PostLogin</span>(NewPlayer);</span><br><span class="line"></span><br><span class="line">	int32 NumberOfPlayer = GameState.<span class="built_in">Get</span>()-&gt;PlayerArray.<span class="built_in">Num</span>();</span><br><span class="line">	<span class="keyword">if</span> (NumberOfPlayer == <span class="number">2</span>) &#123;</span><br><span class="line">		UWorld* World = <span class="built_in">GetWorld</span>();</span><br><span class="line">		<span class="keyword">if</span> (World) &#123;</span><br><span class="line">			bUseSeamlessTravel = <span class="literal">true</span>;</span><br><span class="line">			World-&gt;<span class="built_in">ServerTravel</span>(<span class="built_in">FString</span>(<span class="string">&quot;/Games/_MultiplayerTPS/Maps/MultiplayerTPSMap?listen&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中有一句：<code>bUseSeamlessTravel = true</code>，意思是启用<strong>无缝传送</strong>，使玩家在切换地图时保持角色状态和连接，不需要重新登录。启用后，UE 会在切图前先加载一个“中转地图”，避免切换过程中客户端掉线。而如果想启用无缝传送，我们需要创建一个空地图，并在项目设置中将其设为<strong>转移地图</strong>。</p>
<p><img src="/undefined/e6c9f323/image-20250713202944487.png" alt="image-20250713202944487"></p>
<h3 id="补充知识：Net-Role"><a href="#补充知识：Net-Role" class="headerlink" title="补充知识：Net Role"></a>补充知识：Net Role</h3><p><strong>Net Role 就是角色（Actor）在网络中“扮演的身份”</strong>。每个 Actor（Pawn、角色、物体等）在多人游戏中都会有两个“网络身份”：本机上的角色和远处机器上的角色。</p>
<p>Net Role有以下取值：</p>
<ul>
<li><strong><code>ROLE_Authority</code>（权威）：代表服务器端拥有控制权</strong>，只有服务器上的 Actor 才会是 Authority，只有 Authority 才能调用 <code>Server</code> 函数，进行<strong>状态更改、复制、指令广播等。</strong></li>
<li><p><strong><code>ROLE_AutonomousProxy</code>（自主代理）：代表“我在客户端上拥有控制权”</strong>，常用于玩家自己控制的角色，本地玩家操控自己的角色时，该角色在客户端是 <code>AutonomousProxy</code>。</p>
</li>
<li><p><strong><code>ROLE_SimulatedProxy</code>（模拟代理）：代表“这是别人控制的角色，我本地只做视觉模拟”</strong>，这类对象不能执行本地输入，只能接受服务器同步的数据（比如位置、动画状态）。</p>
</li>
</ul>
<p>通过区分不同的Net Role可以辅助实现一些联机中的功能，如同步变量、RPC等。</p>
<h2 id="3-射击游戏基础"><a href="#3-射击游戏基础" class="headerlink" title="3 射击游戏基础"></a>3 射击游戏基础</h2><p>在网络环境和大厅逻辑就绪后，就可以开始构建射击游戏的基础组件了。</p>
<h3 id="3-1-武器类"><a href="#3-1-武器类" class="headerlink" title="3.1 武器类"></a>3.1 武器类</h3><p>武器类继承自<code>AActor</code>类，具有以下要素：</p>
<p><strong>枚举<code>EWeaponState</code></strong>表示武器当前的装备状态，如初始、丢弃、装备中等。</p>
<p><strong>武器网格体</strong>：武器的外观。</p>
<p><strong>球体碰撞体积</strong>：检测玩家是否接近武器，用于触发拾取逻辑。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Weapon.h</span></span><br><span class="line"><span class="built_in">UENUM</span>(BlueprintType)</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">EWeaponState</span> :uint8</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">EWS_Initial <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Initial State&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">	EWS_Equipped <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Equipped&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">	EWS_Dropped <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Dropped&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">	</span></span><br><span class="line"><span class="function">	EWS_MAX <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;DefaultMAX&quot;</span>)</span></span></span><br><span class="line"><span class="function">&#125;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MULTIPLAYERTPS_API</span> AWeapon : <span class="keyword">public</span> AActor</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:	</span><br><span class="line">	<span class="built_in">AWeapon</span>();</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(VisibleAnywhere, Category = <span class="string">&quot;Weapon Properties&quot;</span>)</span><br><span class="line">	USkeletalMeshComponent* WeaponMesh;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(VisibleAnywhere, Category = <span class="string">&quot;Weapon Properties&quot;</span>)</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">USphereComponent</span>* AreaSphere;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(VisibleAnywhere)</span><br><span class="line">	EWeaponState WeaponState;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:	</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在构造函数中：对网格体设置默认的碰撞响应，阻挡除 <code>Pawn</code> 外的所有通道；初始状态关闭球体的碰撞，避免无关检测；将 <code>bReplicates = true</code>，使武器可以在服务器和客户端之间同步状态。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Weapon.cpp</span></span><br><span class="line">AWeapon::<span class="built_in">AWeapon</span>()</span><br><span class="line">&#123;</span><br><span class="line">	PrimaryActorTick.bCanEverTick = <span class="literal">false</span>;</span><br><span class="line">	bReplicates = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	WeaponMesh = <span class="built_in">CreateDefaultSubobject</span>&lt;USkeletalMeshComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;WeaponMesh&quot;</span>));</span><br><span class="line">	<span class="built_in">SetRootComponent</span>(WeaponMesh);</span><br><span class="line"></span><br><span class="line">	WeaponMesh-&gt;<span class="built_in">SetCollisionResponseToAllChannels</span>(ECollisionResponse::ECR_Block);</span><br><span class="line">	WeaponMesh-&gt;<span class="built_in">SetCollisionResponseToChannel</span>(ECollisionChannel::ECC_Pawn, ECollisionResponse::ECR_Ignore);</span><br><span class="line">	WeaponMesh-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);</span><br><span class="line"></span><br><span class="line">	AreaSphere = <span class="built_in">CreateDefaultSubobject</span>&lt;USphereComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;AreaSphere&quot;</span>));</span><br><span class="line">	AreaSphere-&gt;<span class="built_in">SetupAttachment</span>(RootComponent);</span><br><span class="line">	AreaSphere-&gt;<span class="built_in">SetCollisionResponseToAllChannels</span>(ECollisionResponse::ECR_Ignore);</span><br><span class="line">	AreaSphere-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AWeapon::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">HasAuthority</span>()) &#123;</span><br><span class="line">		AreaSphere-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::QueryAndPhysics);</span><br><span class="line">		AreaSphere-&gt;<span class="built_in">SetCollisionResponseToChannel</span>(ECollisionChannel::ECC_Pawn, ECollisionResponse::ECR_Overlap);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-拾取UI组件（复制）"><a href="#3-2-拾取UI组件（复制）" class="headerlink" title="3.2 拾取UI组件（复制）"></a>3.2 拾取UI组件（复制）</h3><p>当玩家和武器的球体碰撞体积重叠后，需要有一个UI提示玩家拾取武器。这个拾取UI组件本质上是一个文字块，是<code>Weapon</code>类的一个变量。它被标记为<code>UPROPERTY</code>，在编辑器中设定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PickupWidget = <span class="built_in">CreateDefaultSubobject</span>&lt;UWidgetComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;PickupWidget&quot;</span>));</span><br><span class="line">PickupWidget-&gt;<span class="built_in">SetupAttachment</span>(RootComponent);</span><br></pre></td></tr></table></figure>
<p>在武器类中写了一个球体重叠的函数，当球体碰撞体积检测到玩家时会被调用，将拾取UI组件设为可见：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AWeapon::OnSphereOverlap</span><span class="params">(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, <span class="type">bool</span> bFromSweep, <span class="type">const</span> FHitResult&amp; SweepResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	AMultiplayerTPSCharacter* MultiplayerTPSCharacter = <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(OtherActor);</span><br><span class="line">	<span class="keyword">if</span> (MultiplayerTPSCharacter &amp;&amp; PickupWidget) &#123;</span><br><span class="line">		PickupWidget-&gt;<span class="built_in">SetVisibility</span>(<span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>BeginPlay</code> 中，如果当前运行在服务器（<code>HasAuthority()</code> 为真），则开启球体的碰撞检测并绑定重叠回调：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AWeapon::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">HasAuthority</span>()) &#123;</span><br><span class="line">		AreaSphere-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::QueryAndPhysics);</span><br><span class="line">		AreaSphere-&gt;<span class="built_in">SetCollisionResponseToChannel</span>(ECollisionChannel::ECC_Pawn, ECollisionResponse::ECR_Overlap);</span><br><span class="line">		AreaSphere-&gt;OnComponentBeginOverlap.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;ThisClass::OnSphereOverlap);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (PickupWidget) &#123;</span><br><span class="line">		PickupWidget-&gt;<span class="built_in">SetVisibility</span>(<span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，就能<strong>在服务器中看到拾取UI组件了</strong>。在客户端看不到的原因是，<strong>只有在服务器上才会开启武器的球体碰撞体积，也只有在服务器上会进行球体碰撞体积开始重叠的回调函数绑定</strong>。<strong>这是多人游戏中为了防止作弊的常规做法</strong>。那么要怎么在客户端上看到拾取UI组件呢？答案是<strong>复制(Replication)</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/replicate-actor-properties-in-unreal-engine?application_version=5.5">在虚幻引擎中复制Actor属性 | 虚幻引擎 5.5 文档 | Epic Developer Community</a></p>
<p><strong>复制</strong>是指权威服务器将状态数据发送到连接的客户端的过程。简单来说，对于标注了复制的变量，当它被改变时（通常在权威服务器上），这个改变会被同步到所有客户端上。<strong>复制只对Actor及其相关属性生效</strong>。</p>
<p>如果想要复制Actor的变量，这个Actor自身必须是可复制的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bReplicates = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>角色类本身就是可复制的，所以不用显式开启。</p>
<p>对于要复制的变量，必须要用<code>UPROPERTY</code>宏将其标记。如果只是需要将这个变量标记为复制，可以用<code>Replicated</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(Replicated)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AWeapon</span>* OverlappingWeapon;</span><br></pre></td></tr></table></figure>
<p>这个变量用来表示当前重叠的武器。还需要一个<code>Set</code>函数来设置这个变量。<code>SetOverlappingWeapon</code> 用于在网络同步时更新角色的重叠武器状态，并控制拾取 UI 的可见性。只有在本地控制的角色上才会显示拾取 UI。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::SetOverlappingWeapon</span><span class="params">(AWeapon* Weapon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//如果当前重叠的武器有值，需要将其拾取组件隐藏</span></span><br><span class="line">    <span class="keyword">if</span> (OverlappingWeapon) &#123;</span><br><span class="line">		OverlappingWeapon-&gt;<span class="built_in">ShowPickWidget</span>(<span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//显示新的重叠的武器的拾取组件（只有是本地控制的角色时才显示）</span></span><br><span class="line">	OverlappingWeapon = Weapon;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsLocallyControlled</span>()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (OverlappingWeapon) &#123;</span><br><span class="line">			OverlappingWeapon-&gt;<span class="built_in">ShowPickWidget</span>(<span class="literal">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AWeapon::ShowPickWidget</span><span class="params">(<span class="type">bool</span> bShowWidget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (PickupWidget) &#123;</span><br><span class="line">		PickupWidget-&gt;<span class="built_in">SetVisibility</span>(bShowWidget);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改之前武器球体开始重叠的回调函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AWeapon::OnSphereOverlap</span><span class="params">(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, <span class="type">bool</span> bFromSweep, <span class="type">const</span> FHitResult&amp; SweepResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	AMultiplayerTPSCharacter* MultiplayerTPSCharacter = <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(OtherActor);</span><br><span class="line">	<span class="keyword">if</span> (MultiplayerTPSCharacter) &#123;</span><br><span class="line">		MultiplayerTPSCharacter-&gt;<span class="built_in">SetOverlappingWeapon</span>(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如果有需要复制的变量，我们就需要下面的这个函数去注册这个变量</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSCharacter.h</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">GetLifetimeReplicatedProps</span><span class="params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MultiplayerTPSCharacter.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::GetLifetimeReplicatedProps</span><span class="params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">GetLifetimeReplicatedProps</span>(OutLifetimeProps);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">DOREPLIFETIME</span>(AMultiplayerTPSCharacter, OverlappingWeapon);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如果想要有条件地复制<code>Actor</code>属性，如仅复制到Actor的所有者，在进行注册时需要用<code>DOREPLIFETIME_CONDITION</code>宏而不是<code>DOREPLIFETIME</code>宏，同时用<code>COND_Custom</code>控制复制的条件</strong>。具体用法在官方文档中有详细讲解。</p>
<p>这样一来，当这个变量在服务器上被改变后，它就会自动复制到客户端。在这里，当服务器上角色和地上的武器重叠后，<code>OverlappingWeapon</code>被设为重叠的武器，发生了改变，这时这个变量就会同步到所有客户端。</p>
<p>现在当服务器上角色和武器重叠时，所有客户端的对应角色的<code>OverlappingWeapon</code>变量都会被设为正确的值，但是要怎样让这个变量显示拾取组件呢？</p>
<p><strong>如果想要当复制发生时调用某个函数，可以用下面这个<code>UPROPERTY</code>标记：<code>ReplicatedUsing = FunctionName</code></strong>。<strong>（回调函数必须要有UFUNCTION()宏）</strong></p>
<p>回调函数通常需要加上<code>OnRep_</code>的前缀：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::OnRep_OverlappingWeapon</span><span class="params">(AWeapon* LastWeapon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (OverlappingWeapon) &#123;</span><br><span class="line">		OverlappingWeapon-&gt;<span class="built_in">ShowPickWidget</span>(<span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (LastWeapon) &#123;</span><br><span class="line">		LastWeapon-&gt;<span class="built_in">ShowPickWidget</span>(<span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>回调函数通常是无参的</strong>，但是<strong>也可以带一个要复制的变量类的指针的参数，其值为变量在复制前的值</strong>。可以通过这个参数对复制之前的值进行一些操作。</p>
<p>这样一来，当<code>OverlappingWeapon</code>被复制的时候，所有通过的复制同步了这个变量的客户端都会执行<code>OnRep_OverlappingWeapon</code>函数，设置武器拾取控制的可见性。当然，只有拾取武器的那个角色能看到效果。</p>
<p>在结束重叠的回调函数中将重叠的武器设为空。同样，这会触发复制，并且将之前重叠的武器的拾取UI组件隐藏。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AWeapon::OnSphereEndOverlap</span><span class="params">(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	AMultiplayerTPSCharacter* MultiplayerTPSCharacter = <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(OtherActor);</span><br><span class="line">	<span class="keyword">if</span> (MultiplayerTPSCharacter) &#123;</span><br><span class="line">		MultiplayerTPSCharacter-&gt;<span class="built_in">SetOverlappingWeapon</span>(<span class="literal">nullptr</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-装备武器（RPC）"><a href="#3-3-装备武器（RPC）" class="headerlink" title="3.3 装备武器（RPC）"></a>3.3 装备武器（RPC）</h3><p>为了实现模块化，可以把所有处理和战斗相关的逻辑写在一个角色组件<code>CombatComponent</code>中。在其中声明两个变量，分别为角色和装备的武器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AMultiplayerTPSCharacter</span>* Character;</span><br><span class="line">AWeapon* EquippedWeapon;</span><br></pre></td></tr></table></figure>
<p>为了方便角色访问组件，这里将角色类设为了组件类的友元类。这种行为一般来说是不推荐的，但是因为组件本质上是角色的一部分，所以这里这样做没问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">AMultiplayerTPSCharacter</span>;</span><br></pre></td></tr></table></figure>
<p>装备武器的逻辑实现如下，将武器附着到角色的手部插槽，并更新武器状态为已装备。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::EquipWeapon</span><span class="params">(AWeapon* WeaponToEquip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Character == <span class="literal">nullptr</span> || WeaponToEquip == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">	EquippedWeapon = WeaponToEquip;</span><br><span class="line">	EquippedWeapon-&gt;<span class="built_in">SetWeaponState</span>(EWeaponState::EWS_Equipped);</span><br><span class="line">	<span class="type">const</span> USkeletalMeshSocket* HandSocket = Character-&gt;<span class="built_in">GetMesh</span>()-&gt;<span class="built_in">GetSocketByName</span>(<span class="built_in">FName</span>(<span class="string">&quot;RightHandSocket&quot;</span>));</span><br><span class="line">	<span class="keyword">if</span> (HandSocket) &#123;</span><br><span class="line">		HandSocket-&gt;<span class="built_in">AttachActor</span>(EquippedWeapon, Character-&gt;<span class="built_in">GetMesh</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	EquippedWeapon-&gt;<span class="built_in">SetOwner</span>(Character);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>角色类是复制的，但是战斗组件不是，所以角色持有战斗组件后要将其设为复制的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSCharacter.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UCombatComponent</span>* Combat;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MultiplayerTPSCharacter.cpp</span></span><br><span class="line">Combat = <span class="built_in">CreateDefaultSubobject</span>&lt;UCombatComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;CombatComponent&quot;</span>));</span><br><span class="line">Combat-&gt;<span class="built_in">SetIsReplicated</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::PostInitializeComponents</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">PostInitializeComponents</span>();</span><br><span class="line">	<span class="keyword">if</span> (Combat) &#123;</span><br><span class="line">		Combat-&gt;Character = <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拾取武器的操作只能在服务器上进行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::EquipButtonPressed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Combat &amp;&amp; <span class="built_in">HasAuthority</span>()) &#123;</span><br><span class="line">		Combat-&gt;<span class="built_in">EquipWeapon</span>(OverlappingWeapon);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目前服务器的装备武器操作还没有同步到客户端上。对于变量，我们使用复制的方式进行同步，那对于“操作”呢。</p>
<p><strong>远程程序调用(RPC)</strong> 是在一台或多台连接的机器上远程执行本地调用的函数。RPC可帮助客户端和服务器通过网络连接相互调用函数。RPC是一种重要机制，它补充了使用 <code>Replicated</code> 或 <code>ReplicatedUsing</code> 说明符的复制属性。要调用RPC，必须从Actor或Actor组件调用RPC，并设置要复制的Actor或相关Actor组件。</p>
<p>简单来说，RPC可以分为<strong>调用</strong>和<strong>执行</strong>，当调用RPC函数时会根据规则在本机或者别的机器上执行实现函数。</p>
<p><a target="_blank" rel="noopener" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/remote-procedure-calls-in-unreal-engine?application_version=5.5">虚幻引擎中的远程程序调用 | 虚幻引擎 5.5 文档 | Epic Developer Community</a></p>
<p><a target="_blank" rel="noopener" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/actor-owner-and-owning-connection-in-unreal-engine?application_version=5.5">虚幻引擎中的Actor所有者和所属连接 | 虚幻引擎 5.5 文档 | Epic Developer Community</a></p>
<p>我画了几张图来表示几种<code>RPC</code>的工作原理。</p>
<p>假设一共有三个玩家在一起进行游戏，其中有两个客户端，他们都连接到<code>Listened Server</code>。对于使用<code>Listened Server</code>的模型，<code>Listened Server</code>本身即是服务器，同时也是特殊的客户端。在每一个客户端上都存在三个角色（对于Actor也是同理），对于自己的角色，可以称之为称之为<strong>本地控制的(Locally Controlled)</strong>；而另外两个角色都是经由服务器发送的数据进行模拟的，可以称之为<strong>本地模拟的(Simulated)</strong>；另外，服务器上的角色都是<strong>权威的(Authority)</strong>，通常那些重要数据只能在权威的Actor上才能进行修改。</p>
<p>注意，这是我自己根据实际开发的过程中的理解进行划分的，叫法和之前的<code>Net Role</code>略有不同，但是意思基本一样，因为在开发中基本上就是通过<code>HasAuthority()</code>和<code>IsLocallyControlled()</code>来判断<code>Actor</code>所属的。同时，对于<code>Listened Server</code>，<code>Actor</code>可能既是权威的，又是本地控制的。</p>
<p><img src="/undefined/e6c9f323/CS模型.png" alt="CS模型"></p>
<p><strong><code>Server RPC</code></strong>：如果是本地控制的<code>Actor</code>调用，将会由服务器上对应的<code>Actor</code>来执行。</p>
<p><img src="/undefined/e6c9f323/Server RPC.png" alt="Server RPC"></p>
<p><strong><code>Client RPC</code></strong>：如果是服务器上的<code>Actor</code>调用，将会由<code>Actor</code>的所属客户端上的对应来执行。</p>
<p><img src="/undefined/e6c9f323/Client RPC.png" alt="Client RPC"></p>
<p><strong><code>NetMultacast RPC</code></strong>：我通常直接称之为<code>Multicast RPC</code>或者多播RPC（因为官方文档中其函数前缀就是<code>Multacast</code>），被设计于在服务器上调用，会由所有客户端上对应的<code>Actor</code>来执行。</p>
<p><img src="/undefined/e6c9f323/Multicast RPC.png" alt="Multicast RPC"></p>
<p>这里使用<strong><code>Server RPC</code></strong>来实现装备武器的同步，以及初步了解RPC的用法。</p>
<p>首先要声明一个RPC函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RPC函数一般以RPC类型为前缀，如Server，Client，Multicast</span></span><br><span class="line"><span class="comment">//UFUNCTION宏中需要声明RPC类型，以及是否可靠。类似于TCP和UDP，如果声明RPC为Reliable，RPC调用会确保成功执行了RPC函数，但是会增加网络开销，尽量用于比较重要的操作</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(Server, Reliable)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ServerEquipButtonPressed</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>在定义函数时要在函数后面加上后缀<code>_Implementation</code></strong>，代表RPC函数的实现。编译时不会报错。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::ServerEquipButtonPressed_Implementation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Combat) &#123;</span><br><span class="line">		Combat-&gt;<span class="built_in">EquipWeapon</span>(OverlappingWeapon);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按下装备键的回调函数改为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::EquipButtonPressed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Combat) &#123;</span><br><span class="line">		<span class="comment">//如果在服务器上调用，直接装备武器</span></span><br><span class="line">		<span class="comment">//否则调用Server RPC</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">HasAuthority</span>()) &#123; </span><br><span class="line">			Combat-&gt;<span class="built_in">EquipWeapon</span>(OverlappingWeapon);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">ServerEquipButtonPressed</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说实话，我觉得这样写真的很不优雅。经过查阅资料和自己验证，我确定这里不需要判断是否是权威的，直接调用<code>Server RPC</code>即可。对于<code>Listened Server</code>，其同样算是特殊的客户端，所以同样会执行<code>Server RPC</code>，并且是直接在本地执行的，不会经过网络。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::EquipButtonPressed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Combat) &#123;</span><br><span class="line">		<span class="built_in">ServerEquipButtonPressed</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这样就保证了任何机器试图装备武器时，其操作都是在服务器上执行的。</p>
<p>再回过头来看装备武器的逻辑。将要装备的武器的状态改为<code>EWS_Equipped</code>，将其附着到角色的手部插槽上，然后将其Owner设为角色，将其拾取UI组件隐藏。Weapon自身是可复制的，所以这里面大部分操作都会自动同步到所有机器，除了“将其拾取UI组件隐藏”这一步，因为这是我们自己的逻辑和变量。那么要如何实现拾取UI组件逻辑的同步？</p>
<p>可以注意到，装备武器后会改变<code>WeaponState</code>这个变量。那么我们将其设为复制，然后在回调函数中隐藏拾取UI组件不就行了吗？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Weapon.h</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">GetLifetimeReplicatedProps</span><span class="params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnRep_WeaponState</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(ReplicatedUsing = OnRep_WeaponState, VisibleAnywhere, Category = <span class="string">&quot;Weapon Properties&quot;</span>)</span><br><span class="line">EWeaponState WeaponState;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Weapon.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AWeapon::GetLifetimeReplicatedProps</span><span class="params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">GetLifetimeReplicatedProps</span>(OutLifetimeProps);</span><br><span class="line">	<span class="built_in">DOREPLIFETIME</span>(AWeapon, WeaponState);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AWeapon::OnRep_WeaponState</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (WeaponState) &#123;</span><br><span class="line">	<span class="keyword">case</span> EWeaponState::EWS_Equipped:</span><br><span class="line">		<span class="built_in">ShowPickWidget</span>(<span class="literal">false</span>);</span><br><span class="line">		AreaSphere-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>补一个设置武器状态的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AWeapon::SetWeaponState</span><span class="params">(EWeaponState State)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	WeaponState = State;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>装备武器后需要更新角色的动画。实现的逻辑和简单，在角色类中实现一个接口返回当前是否装备武器，动画实例类中实时通过这个接口获取当前是否装备武器，并据此在动画蓝图中切换动画状态。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSCharacter.cpp</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AMultiplayerTPSCharacter::IsWeaponEquipped</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (Combat &amp;&amp; Combat-&gt;EquippedWeapon);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MultiplayerTPSAnimInstance.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly, Category = <span class="string">&quot;Movement&quot;</span>, meta = (AllowPrivateAccess = <span class="string">&quot;true&quot;</span>))</span><br><span class="line"><span class="type">bool</span> bWeaponEquipped;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MultiplayerTPSAnimInstance.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMultiplayerTPSAnimInstance::NativeUpdateAnimation</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">NativeUpdateAnimation</span>(DeltaTime);</span><br><span class="line">	...</span><br><span class="line">    bWeaponEquipped = MultiplayerTPSCharacter-&gt;<span class="built_in">IsWeaponEquipped</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>唯一的问题是装备的武器是在服务器上更新的，需要进行复制。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CombatComponent.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(Replicated)</span><br><span class="line">AWeapon* EquippedWeapon;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CombatComponent.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::GetLifetimeReplicatedProps</span><span class="params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">GetLifetimeReplicatedProps</span>(OutLifetimeProps);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">DOREPLIFETIME</span>(UCombatComponent, EquippedWeapon);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-蹲伏"><a href="#3-4-蹲伏" class="headerlink" title="3.4 蹲伏"></a>3.4 蹲伏</h3><p>蹲伏功能很简单，可以直接调用角色类实现的函数。记得要启用蹲伏功能。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//角色的构造函数</span></span><br><span class="line"><span class="built_in">GetCharacterMovement</span>()-&gt;NavAgentProps.bCanCrouch = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定蹲伏按键的回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::CrouchButtonPressed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bIsCrouched) &#123;</span><br><span class="line">		<span class="built_in">UnCrouch</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">Crouch</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以直接在动画蓝图中获取当前是否在蹲伏来切换动画状态。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bIsCrouched = MultiplayerTPSCharacter-&gt;bIsCrouched;</span><br></pre></td></tr></table></figure>
<p>作为角色类的内置功能，<code>Crouch()</code>和<code>UnCrouch()</code>已经处理好了网络同步的相关功能，我们不需要考虑相关问题。</p>
<h3 id="3-5-瞄准"><a href="#3-5-瞄准" class="headerlink" title="3.5 瞄准"></a>3.5 瞄准</h3><p>瞄准主要依赖于战斗组件中的一个变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSCharacter.h</span></span><br><span class="line"><span class="type">bool</span> bAiming;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MultiplayerTPSCharacter.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::AimButtonPressed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Combat) &#123;</span><br><span class="line">		Combat-&gt;bAiming = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::AimButtonReleased</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Combat) &#123;</span><br><span class="line">		Combat-&gt;bAiming = <span class="literal">false</span>;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AMultiplayerTPSCharacter::IsAiming</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (Combat &amp;&amp; Combat-&gt;bAiming);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>动画实例类中实时获取当前是否在瞄准，来切换动画蓝图中的状态。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly, Category = <span class="string">&quot;Movement&quot;</span>, meta = (AllowPrivateAccess = <span class="string">&quot;true&quot;</span>))</span><br><span class="line"><span class="type">bool</span> bAiming;</span><br></pre></td></tr></table></figure>
<p>这样就完成了瞄准的<strong>本地实现</strong>，现在需要将瞄准同步到所有客户端。要用什么方法呢？</p>
<p>瞄准是在本地按键后执行的，而<strong>复制只能在当服务器上的值改变时将其同步到所有连接</strong>，如果将<code>bAiming</code>设为复制属性，那么客户端瞄准时也无法将这个状态同步给服务器和其它客户端。所以除了复制以外，还要使用<code>Server RPC</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CombatComponent.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(Replicated)</span><br><span class="line"><span class="type">bool</span> bAiming;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetAiming</span><span class="params">(<span class="type">bool</span> bIsAiming)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>(Server, Reliable)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ServerSetAiming</span><span class="params">(<span class="type">bool</span> bIsAiming)</span></span>;</span><br></pre></td></tr></table></figure>
<p>角色瞄准时从直接设置瞄准变为执行<code>SetAiming</code>函数。在<code>SetAiming</code>函数中会执行<code>ServerSetAiming</code>函数，在服务器上设置<code>bAiming</code>。而当服务器上<code>bAiming</code>改变后，就会通过复制改变所有连接的对应属性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSCharacter.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::AimButtonPressed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Combat) &#123;</span><br><span class="line">		Combat-&gt;<span class="built_in">SetAiming</span>(<span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::AimButtonReleased</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Combat) &#123;</span><br><span class="line">		Combat-&gt;<span class="built_in">SetAiming</span>(<span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CombatComponent.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::SetAiming</span><span class="params">(<span class="type">bool</span> bIsAiming)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bAiming = bIsAiming;</span><br><span class="line">	<span class="built_in">ServerSetAiming</span>(bIsAiming);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::ServerSetAiming_Implementation</span><span class="params">(<span class="type">bool</span> bIsAiming)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bAiming = bIsAiming;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当装备武器时会使用控制器控制角色Yaw方向的旋转，此时需要使用混合空间来控制角色在不同方向移动时的动作。混合空间需要Yaw和Lean两个输入，我们在动画实例类中实时计算这两个值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSAnimInstance.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly, Category = <span class="string">&quot;Movement&quot;</span>, meta = (AllowPrivateAccess = <span class="string">&quot;true&quot;</span>))</span><br><span class="line"><span class="type">float</span> YawOffset;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly, Category = <span class="string">&quot;Movement&quot;</span>, meta = (AllowPrivateAccess = <span class="string">&quot;true&quot;</span>))</span><br><span class="line"><span class="type">float</span> Lean;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MultiplayerTPSAnimInstance.cpp</span></span><br><span class="line">FRotator AimRotation = MultiplayerTPSCharacter-&gt;<span class="built_in">GetBaseAimRotation</span>();</span><br><span class="line">FRotator MovementRotation = UKismetMathLibrary::<span class="built_in">MakeRotFromX</span>(MultiplayerTPSCharacter-&gt;<span class="built_in">GetVelocity</span>());</span><br><span class="line"></span><br><span class="line">FRotator DeltaRot = UKismetMathLibrary::<span class="built_in">NormalizedDeltaRotator</span>(MovementRotation, AimRotation);</span><br><span class="line">DeltaRotation = FMath::<span class="built_in">RInterpTo</span>(DeltaRotation, DeltaRot, DeltaTime, <span class="number">6.f</span>);</span><br><span class="line">YawOffset = DeltaRotation.Yaw;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lean</span></span><br><span class="line">CharacterRotationLastFrame = CharacterRotation;</span><br><span class="line">CharacterRotation = MultiplayerTPSCharacter-&gt;<span class="built_in">GetActorRotation</span>();</span><br><span class="line"><span class="type">const</span> FRotator Delta = UKismetMathLibrary::<span class="built_in">NormalizedDeltaRotator</span>(CharacterRotation, CharacterRotationLastFrame);</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> Target = Delta.Yaw / DeltaTime;</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> Interp = FMath::<span class="built_in">FInterpTo</span>(Lean, Target, DeltaTime, <span class="number">6.f</span>);</span><br><span class="line">Lean = FMath::<span class="built_in">Clamp</span>(Interp, <span class="number">-90.f</span>, <span class="number">90.f</span>);</span><br></pre></td></tr></table></figure>
<p>在装备武器时设置<code>bOrientRotationToMovement = false</code>和<code>bUseControllerRotationYaw = true</code>，但是这两个值是不会自动复制的。可以使用之前已经设为<code>EquippedWeapon</code>属性，当其改变时检测其是否为空，如果不为空，说明装备了武器，此时可以用<code>ReplicatedUsing =</code>来调用回调函数设置这两个值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CombatComponent.h</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnRep_EquipWeapon</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(ReplicatedUsing = OnRep_EquipWeapon)</span><br><span class="line">AWeapon* EquippedWeapon;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CombatComponent.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::OnRep_EquipWeapon</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (EquippedWeapon &amp;&amp; Character) &#123;</span><br><span class="line">		Character-&gt;<span class="built_in">GetCharacterMovement</span>()-&gt;bOrientRotationToMovement = <span class="literal">false</span>;</span><br><span class="line">		Character-&gt;bUseControllerRotationYaw = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>瞄准时需要降低移动速度，逻辑很简单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CombatComponent.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line"><span class="type">float</span> BaseWalkSpeed;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line"><span class="type">float</span> AimWalkSpeed;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CombatComponent.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::SetAiming</span><span class="params">(<span class="type">bool</span> bIsAiming)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bAiming = bIsAiming;</span><br><span class="line">	<span class="built_in">ServerSetAiming</span>(bIsAiming);</span><br><span class="line">	<span class="keyword">if</span> (Character) &#123;</span><br><span class="line">		Character-&gt;<span class="built_in">GetCharacterMovement</span>()-&gt;MaxWalkSpeed = bIsAiming ? AimWalkSpeed : BaseWalkSpeed;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>移动速度作为角色类的内置属性应该是会自动复制的。然而<strong>移动速度这个值是由服务器权威控制的</strong>，在客户端本地修改这个值不但同步无法生效，甚至在客户端本地的修改也不会生效，而是会被服务器的值不断覆盖。因此我们只能在服务器修改这个值。之前我们实现了瞄准时的<code>Server RPC</code>，在那里进行修改即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::ServerSetAiming_Implementation</span><span class="params">(<span class="type">bool</span> bIsAiming)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bAiming = bIsAiming;</span><br><span class="line">	<span class="keyword">if</span> (Character) &#123;</span><br><span class="line">		Character-&gt;<span class="built_in">GetCharacterMovement</span>()-&gt;MaxWalkSpeed = bIsAiming ? AimWalkSpeed : BaseWalkSpeed;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>瞄准时还要放大<code>FOV</code>。通过插值完成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Weapon.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line"><span class="type">float</span> ZoomedFOV = <span class="number">30.f</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line"><span class="type">float</span> ZoomInterpSpeed = <span class="number">20.f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">FORCEINLINE <span class="type">float</span> <span class="title">GetZoomedFOV</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> ZoomedFOV; &#125;</span><br><span class="line"><span class="function">FORCEINLINE <span class="type">float</span> <span class="title">GetZoomInterpSpeed</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> ZoomInterpSpeed; &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CombatComponent.h</span></span><br><span class="line"><span class="comment">//Aiming and FOV</span></span><br><span class="line"><span class="type">float</span> DefaultFOV;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, Category = <span class="string">&quot;Combat&quot;</span>)</span><br><span class="line"><span class="type">float</span> ZoomedFOV = <span class="number">30.f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> CurrentFOV;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, Category = <span class="string">&quot;Combat&quot;</span>)</span><br><span class="line"><span class="type">float</span> ZoomInterpSpeed = <span class="number">20.f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InterpFOV</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CombatComponent.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Character) &#123;</span><br><span class="line">        ...</span><br><span class="line">		<span class="keyword">if</span> (Character-&gt;<span class="built_in">GetFollowCamera</span>()) &#123;</span><br><span class="line">			DefaultFOV = Character-&gt;<span class="built_in">GetFollowCamera</span>()-&gt;FieldOfView;</span><br><span class="line">			CurrentFOV = DefaultFOV;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::InterpFOV</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!EquippedWeapon) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bAiming) &#123;</span><br><span class="line">		CurrentFOV = FMath::<span class="built_in">FInterpTo</span>(CurrentFOV, EquippedWeapon-&gt;<span class="built_in">GetZoomedFOV</span>(), DeltaTime, EquippedWeapon-&gt;<span class="built_in">GetZoomInterpSpeed</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		CurrentFOV = FMath::<span class="built_in">FInterpTo</span>(CurrentFOV, DefaultFOV, DeltaTime, ZoomInterpSpeed);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (Character &amp;&amp; Character-&gt;<span class="built_in">GetFollowCamera</span>()) &#123;</span><br><span class="line">		Character-&gt;<span class="built_in">GetFollowCamera</span>()-&gt;<span class="built_in">SetFieldOfView</span>(CurrentFOV);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::TickComponent</span><span class="params">(<span class="type">float</span> DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">TickComponent</span>(DeltaTime, TickType, ThisTickFunction);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (Character &amp;&amp; Character-&gt;<span class="built_in">IsLocallyControlled</span>()) &#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="built_in">InterpFOV</span>(DeltaTime);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-6-瞄准偏移"><a href="#3-6-瞄准偏移" class="headerlink" title="3.6 瞄准偏移"></a>3.6 瞄准偏移</h3><p>在很多第三人称游戏中，当我们移动视角时，角色并不会一直随着摄像机进行旋转。当视角旋转幅度不大时角色会转动头部或上半身，直到视角旋转到了角色身后才会转身。这种转动上半身的效果可以通过瞄准偏移实现。</p>
<p>瞄准偏移属于动画的一种，根据输入的<code>Yaw</code>和<code>Pitch</code>计算角色上半身的旋转和俯仰。</p>
<p>在角色类中声明这两个值，并在Tick中进行计算：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSCharacter.h</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">float</span> AO_Yaw;</span><br><span class="line">	<span class="type">float</span> AO_Pitch;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">FORCEINLINE <span class="type">float</span> <span class="title">GetAO_Yaw</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> AO_Yaw; &#125;</span><br><span class="line">	<span class="function">FORCEINLINE <span class="type">float</span> <span class="title">GetAO_Pitch</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> AO_Pitch; &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSCharacter.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::AimOffset</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Combat &amp;&amp; !Combat-&gt;EquippedWeapon) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	FVector Velocity = <span class="built_in">GetVelocity</span>();</span><br><span class="line">	Velocity.Z = <span class="number">0.f</span>;</span><br><span class="line">	<span class="type">float</span> Speed = Velocity.<span class="built_in">Size</span>();</span><br><span class="line">	<span class="type">bool</span> bIsInAir = <span class="built_in">GetCharacterMovement</span>()-&gt;<span class="built_in">IsFalling</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果站在原地不动</span></span><br><span class="line">	<span class="keyword">if</span> (Speed == <span class="number">0.f</span> &amp;&amp; !bIsInAir) &#123;</span><br><span class="line">		FRotator CurrentAimRotation = <span class="built_in">FRotator</span>(<span class="number">0.f</span>, <span class="built_in">GetBaseAimRotation</span>().Yaw, <span class="number">0.f</span>);</span><br><span class="line">		FRotator DeltaAimRotation = UKismetMathLibrary::<span class="built_in">NormalizedDeltaRotator</span>(CurrentAimRotation, StartingAimRotation);</span><br><span class="line">		AO_Yaw = DeltaAimRotation.Yaw;</span><br><span class="line">        <span class="keyword">if</span> (TurningInPlace == ETurningInPlace::ETIP_NotTurning) &#123;</span><br><span class="line">			InterpAO_Yaw = AO_Yaw;</span><br><span class="line">		&#125;</span><br><span class="line">		bUseControllerRotationYaw = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//如果正在移动或者在空中</span></span><br><span class="line">	<span class="keyword">if</span> (Speed &gt; <span class="number">0.f</span> || bIsInAir) &#123;</span><br><span class="line">		StartingAimRotation = <span class="built_in">FRotator</span>(<span class="number">0.f</span>, <span class="built_in">GetBaseAimRotation</span>().Yaw, <span class="number">0.f</span>);</span><br><span class="line">		bUseControllerRotationYaw = <span class="literal">true</span>;</span><br><span class="line">		AO_Yaw = <span class="number">0.f</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	AO_Pitch = <span class="built_in">GetBaseAimRotation</span>().Pitch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在动画蓝图中就可以使用这两个值实现瞄准偏移了。</p>
<p>还有一个问题。角色类中的AO_Pitch会进行自动复制，但是在传输过程中引擎会将这个值进行压缩来实现更高的传输效率，但是在解压时会解压成一个在[0,360]之间的值。当角色低头时，Pitch在[-90,0]之间，压缩再解压后就变成了[270,360]之间的值，导致在传输后的低头逻辑错误。解决方法很简单，将解压后的值进行映射即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">IsLocallyControlled</span>() &amp;&amp; AO_Pitch &gt; <span class="number">90.f</span>) &#123;</span><br><span class="line">	<span class="comment">//将Pitch从[270,360)映射到[-90,0)</span></span><br><span class="line">	<span class="function">FVector2D <span class="title">InRange</span><span class="params">(<span class="number">270.f</span>, <span class="number">360.f</span>)</span></span>;</span><br><span class="line">	<span class="function">FVector2D <span class="title">OutRange</span><span class="params">(<span class="number">-90.f</span>, <span class="number">0.f</span>)</span></span>;</span><br><span class="line">	AO_Pitch = FMath::<span class="built_in">GetMappedRangeValueClamped</span>(InRange, OutRange, AO_Pitch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随着上半身的旋转，会出现角色的左手和武器无法匹配的情况，可以使用<code>FABRIK</code>来解决，将左手放在武器对应的插槽上。这里主要讲一下如何获取左手要放置的位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSAnimInstance.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly, Category = <span class="string">&quot;Movement&quot;</span>, meta = (AllowPrivateAccess = <span class="string">&quot;true&quot;</span>))</span><br><span class="line">FTransform LeftHandTransform;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSAnimInstance.cpp</span></span><br><span class="line"><span class="keyword">if</span> (bWeaponEquipped &amp;&amp; EquippedWeapon &amp;&amp; EquippedWeapon-&gt;<span class="built_in">GetWeaponMesh</span>() &amp;&amp; MultiplayerTPSCharacter-&gt;<span class="built_in">GetMesh</span>()) &#123;</span><br><span class="line">	LeftHandTransform = EquippedWeapon-&gt;<span class="built_in">GetWeaponMesh</span>()-&gt;<span class="built_in">GetSocketTransform</span>(<span class="built_in">FName</span>(<span class="string">&quot;LeftHandSocket&quot;</span>), ERelativeTransformSpace::RTS_World);</span><br><span class="line">	FVector OutPosition;</span><br><span class="line">	FRotator OutRotation;</span><br><span class="line">	MultiplayerTPSCharacter-&gt;<span class="built_in">GetMesh</span>()-&gt;<span class="built_in">TransformToBoneSpace</span>(<span class="built_in">FName</span>(<span class="string">&quot;hand_r&quot;</span>), LeftHandTransform.<span class="built_in">GetLocation</span>(), FRotator::ZeroRotator, OutPosition, OutRotation);</span><br><span class="line">	LeftHandTransform.<span class="built_in">SetLocation</span>(OutPosition);</span><br><span class="line">	LeftHandTransform.<span class="built_in">SetRotation</span>(<span class="built_in">FQuat</span>(OutRotation));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和瞄准偏移相对应的是当偏移到一定程度后角色要进行转身。</p>
<p>定义一个枚举表示角色当前的转身状态。当AO_Yaw超过指定范围后就切换转身状态。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSCharacter.h</span></span><br><span class="line"><span class="built_in">UENUM</span>(BlueprintType)</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">ETurningInPlace</span> : uint8 &#123;</span><br><span class="line">	<span class="function">ETIP_Left <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Turning Left&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">	ETIP_Right <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Turning Right&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">	ETIP_NotTurning <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Not Turning&quot;</span>)</span>,</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	ETIP_MAX <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;DefaultMAX&quot;</span>)</span></span></span><br><span class="line"><span class="function">&#125;</span>;</span><br><span class="line"></span><br><span class="line">ETurningInPlace TurningInPlace;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TurnInPlace</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::TurnInPlace</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (AO_Yaw &gt; <span class="number">90.f</span>) &#123;</span><br><span class="line">		TurningInPlace = ETurningInPlace::ETIP_Right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (AO_Yaw &lt; <span class="number">-90.f</span>) &#123;</span><br><span class="line">		TurningInPlace = ETurningInPlace::ETIP_Left;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (TurningInPlace != ETurningInPlace::ETIP_NotTurning) &#123;</span><br><span class="line">		InterpAO_Yaw = FMath::<span class="built_in">FInterpTo</span>(InterpAO_Yaw, <span class="number">0.f</span>, DeltaTime, <span class="number">4.f</span>);</span><br><span class="line">		AO_Yaw = InterpAO_Yaw;</span><br><span class="line">		<span class="keyword">if</span> (FMath::<span class="built_in">Abs</span>(AO_Yaw) &lt; <span class="number">15.f</span>) &#123;</span><br><span class="line">			TurningInPlace = ETurningInPlace::ETIP_NotTurning;</span><br><span class="line">			StartingAimRotation = <span class="built_in">FRotator</span>(<span class="number">0.f</span>, <span class="built_in">GetBaseAimRotation</span>().Yaw, <span class="number">0.f</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个变量在初始时设为<code>NotInTurning</code>，并在<code>AimOffset</code>函数中计算枚举的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果站在原地不动</span></span><br><span class="line"><span class="keyword">if</span> (Speed == <span class="number">0.f</span> &amp;&amp; !bIsInAir) &#123;</span><br><span class="line">	FRotator CurrentAimRotation = <span class="built_in">FRotator</span>(<span class="number">0.f</span>, <span class="built_in">GetBaseAimRotation</span>().Yaw, <span class="number">0.f</span>);</span><br><span class="line">	FRotator DeltaAimRotation = UKismetMathLibrary::<span class="built_in">NormalizedDeltaRotator</span>(CurrentAimRotation, StartingAimRotation);</span><br><span class="line">	AO_Yaw = DeltaAimRotation.Yaw;</span><br><span class="line">	bUseControllerRotationYaw = <span class="literal">false</span>;</span><br><span class="line">	<span class="built_in">TurnInPlace</span>(DeltaTime);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运动时</span></span><br><span class="line"><span class="keyword">if</span> (Speed &gt; <span class="number">0.f</span> || bIsInAir) &#123;</span><br><span class="line">	StartingAimRotation = <span class="built_in">FRotator</span>(<span class="number">0.f</span>, <span class="built_in">GetBaseAimRotation</span>().Yaw, <span class="number">0.f</span>);</span><br><span class="line">	bUseControllerRotationYaw = <span class="literal">true</span>;</span><br><span class="line">	AO_Yaw = <span class="number">0.f</span>;</span><br><span class="line">	TurningInPlace = ETurningInPlace::ETIP_NotTurning;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FORCEINLINE ETurningInPlace <span class="title">GetTurningInPlace</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> TurningInPlace; &#125;</span><br></pre></td></tr></table></figure>
<p>在动画实例类中实时获取这个值，并根据这个值在动画蓝图中使用<code>RotateRootBone</code>节点实现转身即可。</p>
<h3 id="3-7-基础射击"><a href="#3-7-基础射击" class="headerlink" title="3.7 基础射击"></a>3.7 基础射击</h3><p>本项目的射击方式分为两种：<strong>延迟弹道</strong>和<strong>即时命中</strong>。首先实现延迟弹道。</p>
<p>延迟弹道是指开火时会发射子弹，子弹命中后造成伤害。所以我们首先需要创建一个投射物类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AProjectile::<span class="built_in">AProjectile</span>()</span><br><span class="line">&#123;</span><br><span class="line">	PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line">	CollisionBox = <span class="built_in">CreateDefaultSubobject</span>&lt;UBoxComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;CollisionBox&quot;</span>));</span><br><span class="line">	<span class="built_in">SetRootComponent</span>(CollisionBox);</span><br><span class="line">	CollisionBox-&gt;<span class="built_in">SetCollisionObjectType</span>(ECollisionChannel::ECC_WorldDynamic);</span><br><span class="line">	CollisionBox-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::QueryAndPhysics);</span><br><span class="line">	CollisionBox-&gt;<span class="built_in">SetCollisionResponseToAllChannels</span>(ECollisionResponse::ECR_Ignore);</span><br><span class="line">	CollisionBox-&gt;<span class="built_in">SetCollisionResponseToChannel</span>(ECollisionChannel::ECC_Visibility, ECollisionResponse::ECR_Block);</span><br><span class="line">	CollisionBox-&gt;<span class="built_in">SetCollisionResponseToChannel</span>(ECollisionChannel::ECC_WorldStatic, ECollisionResponse::ECR_Block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按下开火键后为角色和武器播放开火动画。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSCharacter.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::FireButtonPressed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Combat) &#123;</span><br><span class="line">		Combat-&gt;<span class="built_in">FireButtonPressed</span>(<span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::FireButtonReleased</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Combat) &#123;</span><br><span class="line">		Combat-&gt;<span class="built_in">FireButtonPressed</span>(<span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::PlayFireMontage</span><span class="params">(<span class="type">bool</span> bAiming)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!Combat || !Combat-&gt;EquippedWeapon) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	UAnimInstance* AnimInstance = <span class="built_in">GetMesh</span>()-&gt;<span class="built_in">GetAnimInstance</span>();</span><br><span class="line">	<span class="keyword">if</span> (AnimInstance &amp;&amp; FireWeaponMontage) &#123;</span><br><span class="line">		AnimInstance-&gt;<span class="built_in">Montage_Play</span>(FireWeaponMontage);</span><br><span class="line">		FName SectionName;</span><br><span class="line">		SectionName = bAiming ? <span class="built_in">FName</span>(<span class="string">&quot;RifleAim&quot;</span>) : <span class="built_in">FName</span>(<span class="string">&quot;RifleHip&quot;</span>);</span><br><span class="line">		AnimInstance-&gt;<span class="built_in">Montage_JumpToSection</span>(SectionName);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CombatComponent.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::FireButtonPressed</span><span class="params">(<span class="type">bool</span> bPressed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bFireButtonPressed = bPressed;</span><br><span class="line">	<span class="keyword">if</span> (!EquippedWeapon) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (Character &amp;&amp; bFireButtonPressed) &#123;</span><br><span class="line">		Character-&gt;<span class="built_in">PlayerFireMontage</span>(bAiming);</span><br><span class="line">		EquippedWeapon-&gt;<span class="built_in">Fire</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Weapon.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, Category = <span class="string">&quot;Weapon Properties&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UAnimationAsset</span>* FireAnimation;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fire</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Weapon.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AWeapon::Fire</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (FireAnimation) &#123;</span><br><span class="line">		WeaponMesh-&gt;<span class="built_in">PlayAnimation</span>(FireAnimation, <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就实现了<strong>本地的射击</strong>。</p>
<p>要实现开火的同步，解决方法当然是RPC。我们可以使用一个<code>Server RPC</code>和一个<code>Multicast RPC</code>，当开火时调用<code>Server RPC</code>，服务器在执行<code>Server RPC</code>时再调用<code>Multicast RPC</code>，而真正的开火逻辑则放在<code>Multicast RPC</code>的实现中，调用<code>Multicast RPC</code>后会在每一台电脑上执行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSCharacter.h</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(Server, Reliable)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ServerFire</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>(NetMulticast, Reliable)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MulticastFire</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>之前战斗组件中开火键设置的逻辑改为调用<code>Server RPC</code>。开火同步完成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CombatComponent.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::FireButtonPressed</span><span class="params">(<span class="type">bool</span> bPressed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bFireButtonPressed = bPressed;</span><br><span class="line">	<span class="keyword">if</span> (bFireButtonPressed) &#123;</span><br><span class="line">		<span class="built_in">ServerFire</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::ServerFire_Implementation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">MulticastFire</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::MulticastFire_Implementation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!EquippedWeapon) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (Character) &#123;</span><br><span class="line">		Character-&gt;<span class="built_in">PlayerFireMontage</span>(bAiming);</span><br><span class="line">		EquippedWeapon-&gt;<span class="built_in">Fire</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是射击的对象。使用射线检测，以准星为起点向前发射，在Tick中计算准星瞄准的对象，并保存到成员变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::TraceUnderCrosshairs</span><span class="params">(FHitResult&amp; TraceHitResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FVector2D ViewportSize;</span><br><span class="line">	<span class="keyword">if</span> (GEngine &amp;&amp; GEngine-&gt;GameViewport) &#123;</span><br><span class="line">		GEngine-&gt;GameViewport-&gt;<span class="built_in">GetViewportSize</span>(ViewportSize);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">FVector2D <span class="title">CrosshairLocation</span><span class="params">(ViewportSize.X / <span class="number">2.f</span>, ViewportSize.Y / <span class="number">2.f</span>)</span></span>;</span><br><span class="line">	FVector CrosshairWorldPosition;</span><br><span class="line">	FVector CrosshairWorldDirection;</span><br><span class="line">	<span class="type">bool</span> bScreenToWorld = UGameplayStatics::<span class="built_in">DeprojectScreenToWorld</span>(</span><br><span class="line">		UGameplayStatics::<span class="built_in">GetPlayerController</span>(<span class="keyword">this</span>, <span class="number">0</span>),</span><br><span class="line">		CrosshairLocation,</span><br><span class="line">		CrosshairWorldPosition,</span><br><span class="line">		CrosshairWorldDirection</span><br><span class="line">	);</span><br><span class="line">	<span class="keyword">if</span> (bScreenToWorld) &#123;</span><br><span class="line">		FVector Start = CrosshairWorldPosition;</span><br><span class="line">        <span class="comment">//起点向前移一点，防止瞄准到角色自身</span></span><br><span class="line">        <span class="keyword">if</span> (Character) &#123;</span><br><span class="line">			<span class="type">float</span> DistanceToCharacter = (Character-&gt;<span class="built_in">GetActorLocation</span>() - Start).<span class="built_in">Size</span>();</span><br><span class="line">			Start += CrosshairWorldDirection * (DistanceToCharacter + <span class="number">100.f</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		FVector End = Start + CrosshairWorldDirection * TRACE_LENGTH;</span><br><span class="line">		<span class="built_in">GetWorld</span>()-&gt;<span class="built_in">LineTraceSingleByChannel</span>(</span><br><span class="line">			TraceHitResult,</span><br><span class="line">			Start,</span><br><span class="line">			End,</span><br><span class="line">			ECollisionChannel::ECC_Visibility</span><br><span class="line">		);</span><br><span class="line">		<span class="keyword">if</span> (!TraceHitResult.bBlockingHit) &#123;</span><br><span class="line">			TraceHitResult.ImpactPoint = End;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">DrawDebugSphere</span>(</span><br><span class="line">				<span class="built_in">GetWorld</span>(),</span><br><span class="line">				TraceHitResult.ImpactPoint,</span><br><span class="line">				<span class="number">12.f</span>,</span><br><span class="line">				<span class="number">12</span>,</span><br><span class="line">				FColor::Red</span><br><span class="line">			);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">if</span> (!TraceHitResult.bBlockingHit) &#123;</span><br><span class="line">			TraceHitResult.ImpactPoint = End;</span><br><span class="line">			HitTarget = End;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			HitTarget = TraceHitResult.ImpactPoint;</span><br><span class="line">			<span class="built_in">DrawDebugSphere</span>(</span><br><span class="line">				<span class="built_in">GetWorld</span>(),</span><br><span class="line">				TraceHitResult.ImpactPoint,</span><br><span class="line">				<span class="number">12.f</span>,</span><br><span class="line">				<span class="number">12</span>,</span><br><span class="line">				FColor::Red</span><br><span class="line">			);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-8-弹道武器"><a href="#3-8-弹道武器" class="headerlink" title="3.8 弹道武器"></a>3.8 弹道武器</h3><p>弹道武器的要点就是<strong>在开火时生成一颗子弹，并发射出去</strong>。</p>
<p>生成子弹的过程很简单，在弹道武器类中重写开火函数，执行父类的开火函数后获取枪口插槽的位置以及目标点到插槽的方向，根据这些信息生成子弹即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AProjectileWeapon::Fire</span><span class="params">(<span class="type">const</span> FVector&amp; HitTarget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">Fire</span>(HitTarget);</span><br><span class="line">	APawn* InstigatorPawn = <span class="built_in">Cast</span>&lt;APawn&gt;(<span class="built_in">GetOwner</span>());</span><br><span class="line">	<span class="type">const</span> USkeletalMeshSocket* MuzzleFlashSocket = <span class="built_in">GetWeaponMesh</span>()-&gt;<span class="built_in">GetSocketByName</span>(<span class="built_in">FName</span>(<span class="string">&quot;MuzzleFlash&quot;</span>));</span><br><span class="line">	<span class="keyword">if</span> (MuzzleFlashSocket &amp;&amp; InstigatorPawn) &#123;</span><br><span class="line">		FTransform SocketTransform = MuzzleFlashSocket-&gt;<span class="built_in">GetSocketTransform</span>(<span class="built_in">GetWeaponMesh</span>());</span><br><span class="line">		<span class="comment">//从MuzzleSocket到命中点</span></span><br><span class="line">		FVector ToTarget = HitTarget - SocketTransform.<span class="built_in">GetLocation</span>();</span><br><span class="line">		FRotator TargetRotatrion = ToTarget.<span class="built_in">Rotation</span>();</span><br><span class="line">		<span class="keyword">if</span> (ProjectileClass) &#123;</span><br><span class="line">			FActorSpawnParameters SpawnParams;</span><br><span class="line">			SpawnParams.Owner = <span class="built_in">GetOwner</span>();</span><br><span class="line">			SpawnParams.Instigator = InstigatorPawn;</span><br><span class="line">			UWorld* World = <span class="built_in">GetWorld</span>();</span><br><span class="line">			<span class="keyword">if</span> (World) &#123;</span><br><span class="line">				World-&gt;<span class="built_in">SpawnActor</span>&lt;AProjectile&gt;(</span><br><span class="line">					ProjectileClass,</span><br><span class="line">					SocketTransform.<span class="built_in">GetLocation</span>(),</span><br><span class="line">					TargetRotatrion,</span><br><span class="line">					SpawnParams</span><br><span class="line">				);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就是发射子弹了。幸运的是，UE提供了现成的发射器组件，只需要为子弹附带上这个组件，就可以轻松发射子弹。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Projectile.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UProjectileMovementComponent</span>* ProjectileMovementComponent;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Projectile.cpp</span></span><br><span class="line">AProjectile::<span class="built_in">AProjectile</span>()</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	ProjectileMovementComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;UProjectileMovementComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;ProjectileMovementComponent&quot;</span>));</span><br><span class="line">	ProjectileMovementComponent-&gt;bRotationFollowsVelocity = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发射子弹后我们基本上是看不到的，所以需要为子弹添加轨迹来增强视觉效果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Weapon.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UParticleSystem</span>* Tracer;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UParticleSystemComponent</span>* TracerComponent;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Weapon.cpp</span></span><br><span class="line"><span class="keyword">if</span> (Tracer) &#123;</span><br><span class="line">	TracerComponent = UGameplayStatics::<span class="built_in">SpawnEmitterAttached</span>(</span><br><span class="line">		Tracer,</span><br><span class="line">		CollisionBox,</span><br><span class="line">		<span class="built_in">FName</span>(),</span><br><span class="line">		<span class="built_in">GetActorLocation</span>(),</span><br><span class="line">		<span class="built_in">GetActorRotation</span>(),</span><br><span class="line">		EAttachLocation::KeepWorldPosition</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子弹也是需要同步的，除了复制子弹之外，还要将准星瞄准的目标也设为复制，当开火时将其传入准星瞄准的参数，才能正确实现子弹的飞行。</p>
<p>子弹在碰撞后要进行销毁。绑定<code>OnHit</code>事件，在回调函数中处理销毁逻辑：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Projectile.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UParticleSystem* ImpactParticles;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">USoundCue</span>* ImpactSound;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Projectile.cpp</span></span><br><span class="line"><span class="built_in">BeginPlay</span>()&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">HasAuthority</span>()) &#123;</span><br><span class="line">		CollisionBox-&gt;OnComponentHit.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;ThisClass::OnHit);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AProjectile::OnHit</span><span class="params">(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, <span class="type">const</span> FHitResult&amp; Hit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Destroy</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AProjectile::Destroyed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">Destroyed</span>();</span><br><span class="line">	<span class="keyword">if</span> (ImpactParticles) &#123;</span><br><span class="line">		UGameplayStatics::<span class="built_in">SpawnEmitterAtLocation</span>(<span class="built_in">GetWorld</span>(), ImpactParticles, <span class="built_in">GetActorTransform</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ImpactSound) &#123;</span><br><span class="line">		UGameplayStatics::<span class="built_in">PlaySoundAtLocation</span>(<span class="keyword">this</span>, ImpactSound, <span class="built_in">GetActorLocation</span>());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>射击后需要抛出弹壳，创建一个<code>Casing</code>类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere)</span><br><span class="line">UStaticMeshComponent* CasingMesh;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ACasing::<span class="built_in">ACasing</span>()</span><br><span class="line">&#123;</span><br><span class="line">	PrimaryActorTick.bCanEverTick = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	CasingMesh = <span class="built_in">CreateDefaultSubobject</span>&lt;UStaticMeshComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;CasingMesh&quot;</span>));</span><br><span class="line">	<span class="built_in">SetRootComponent</span>(CasingMesh);</span><br><span class="line">    CasingMesh-&gt;<span class="built_in">SetCollisionResponseToChannel</span>(ECollisionChannel::ECC_Camera, ECollisionResponse::ECR_Ignore);</span><br><span class="line">	CasingMesh-&gt;<span class="built_in">SetSimulatePhysics</span>(<span class="literal">true</span>);</span><br><span class="line">	CasingMesh-&gt;<span class="built_in">SetEnableGravity</span>(<span class="literal">true</span>);</span><br><span class="line">	CasingMesh-&gt;<span class="built_in">SetNotifyRigidBodyCollision</span>(<span class="literal">true</span>);</span><br><span class="line">	ShellEjectionImpulse = <span class="number">5.f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Weapon.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">TSubclassOf&lt;<span class="keyword">class</span> <span class="title class_">ACasing</span>&gt; CasingClass;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Weapon.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AWeapon::Fire</span><span class="params">(<span class="type">const</span> FVector&amp; HitTarget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (FireAnimation) &#123;</span><br><span class="line">		WeaponMesh-&gt;<span class="built_in">PlayAnimation</span>(FireAnimation, <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (CasingClass) &#123;</span><br><span class="line">		<span class="type">const</span> USkeletalMeshSocket* AmmoEjectSocket = WeaponMesh-&gt;<span class="built_in">GetSocketByName</span>(<span class="built_in">FName</span>(<span class="string">&quot;AmmoEject&quot;</span>));</span><br><span class="line">		<span class="keyword">if</span> (AmmoEjectSocket) &#123;</span><br><span class="line">			FTransform SocketTransform = AmmoEjectSocket-&gt;<span class="built_in">GetSocketTransform</span>(WeaponMesh);</span><br><span class="line">			UWorld* World = <span class="built_in">GetWorld</span>();</span><br><span class="line">			<span class="keyword">if</span> (World) &#123;</span><br><span class="line">				World-&gt;<span class="built_in">SpawnActor</span>&lt;ACasing&gt;(</span><br><span class="line">					CasingClass,</span><br><span class="line">					SocketTransform.<span class="built_in">GetLocation</span>(),</span><br><span class="line">					SocketTransform.<span class="built_in">GetRotation</span>().<span class="built_in">Rotator</span>()</span><br><span class="line">				);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>落地后要进行销毁：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ShellSound) &#123;</span><br><span class="line">	UGameplayStatics::<span class="built_in">PlaySoundAtLocation</span>(<span class="keyword">this</span>, ShellSound, <span class="built_in">GetActorLocation</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Destroy</span>();</span><br></pre></td></tr></table></figure>
<h3 id="3-9-即时命中武器"><a href="#3-9-即时命中武器" class="headerlink" title="3.9 即时命中武器"></a>3.9 即时命中武器</h3><p>没什么好说的，开火时进行射线检测，如果命中角色，对其造成伤害，然后在命中点生成音效和命中特效，并且生成子弹的轨迹。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AHitScanWeapon::Fire</span><span class="params">(<span class="type">const</span> FVector&amp; HitTarget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">Fire</span>(HitTarget);</span><br><span class="line"></span><br><span class="line">	APawn* OwnerPawn = <span class="built_in">Cast</span>&lt;APawn&gt;(<span class="built_in">GetOwner</span>());</span><br><span class="line">	<span class="keyword">if</span> (!OwnerPawn) <span class="keyword">return</span>;</span><br><span class="line">	AController* InstigatorController = OwnerPawn-&gt;<span class="built_in">GetController</span>();</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> USkeletalMeshSocket* MuzzleFlashSocket = <span class="built_in">GetWeaponMesh</span>()-&gt;<span class="built_in">GetSocketByName</span>(<span class="string">&quot;MuzzleFlash&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (MuzzleFlashSocket) &#123;</span><br><span class="line">		FTransform SocketTransform = MuzzleFlashSocket-&gt;<span class="built_in">GetSocketTransform</span>(<span class="built_in">GetWeaponMesh</span>());</span><br><span class="line">		FVector Start = SocketTransform.<span class="built_in">GetLocation</span>();</span><br><span class="line">		FVector End = Start + (HitTarget - Start) * <span class="number">1.25f</span>;</span><br><span class="line"></span><br><span class="line">		FHitResult FireHit;</span><br><span class="line">		UWorld* World = <span class="built_in">GetWorld</span>();</span><br><span class="line">		<span class="keyword">if</span> (World) &#123;</span><br><span class="line">			World-&gt;<span class="built_in">LineTraceSingleByChannel</span>(</span><br><span class="line">				FireHit,</span><br><span class="line">				Start,</span><br><span class="line">				End,</span><br><span class="line">				ECollisionChannel::ECC_Visibility</span><br><span class="line">			);</span><br><span class="line">			FVector BeamEnd = End;</span><br><span class="line">			<span class="keyword">if</span> (FireHit.bBlockingHit) &#123;</span><br><span class="line">				BeamEnd = FireHit.ImpactPoint;</span><br><span class="line">				AMultiplayerTPSCharacter* MultiplayerTPSCharacter = <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(FireHit.<span class="built_in">GetActor</span>());</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">HasAuthority</span>() &amp;&amp; MultiplayerTPSCharacter &amp;&amp; InstigatorController) &#123;</span><br><span class="line">					UGameplayStatics::<span class="built_in">ApplyDamage</span>(</span><br><span class="line">						MultiplayerTPSCharacter,</span><br><span class="line">						Damage,</span><br><span class="line">						InstigatorController,</span><br><span class="line">						<span class="keyword">this</span>,</span><br><span class="line">						UDamageType::<span class="built_in">StaticClass</span>()</span><br><span class="line">					);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (ImpactParticles) &#123;</span><br><span class="line">					UGameplayStatics::<span class="built_in">SpawnEmitterAtLocation</span>(</span><br><span class="line">						World,</span><br><span class="line">						ImpactParticles,</span><br><span class="line">						FireHit.ImpactPoint,</span><br><span class="line">						FireHit.ImpactNormal.<span class="built_in">Rotation</span>()</span><br><span class="line">					);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (BeamParticles) &#123;</span><br><span class="line">				UParticleSystemComponent* Beam = UGameplayStatics::<span class="built_in">SpawnEmitterAtLocation</span>(</span><br><span class="line">					World,</span><br><span class="line">					BeamParticles,</span><br><span class="line">					SocketTransform</span><br><span class="line">				);</span><br><span class="line">				<span class="keyword">if</span> (Beam) &#123;</span><br><span class="line">					Beam-&gt;<span class="built_in">SetVectorParameter</span>(<span class="built_in">FName</span>(<span class="string">&quot;Target&quot;</span>), BeamEnd);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-10-准星"><a href="#3-10-准星" class="headerlink" title="3.10 准星"></a>3.10 准星</h3><p>准星可以在HUD类中进行绘制，而这个过程一般是由玩家控制器来控制的。因此这里需要创建自己的<code>PlayerController</code>类和<code>HUD</code>类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSHUD.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个结构体，存储准星的五个部分以及扩散和颜色</span></span><br><span class="line"><span class="built_in">USTRUCT</span>(BlueprintType)</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FHUDPackage</span> &#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">UTexture2D</span>* CrosshairCenter;</span><br><span class="line">	UTexture2D* CrosshairLeft;</span><br><span class="line">	UTexture2D* CrosshairRight;</span><br><span class="line">	UTexture2D* CrosshairTop;</span><br><span class="line">	UTexture2D* CrosshairBottom;</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> CrosshairSpread;</span><br><span class="line">    FLinearColor CrosshairColor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DrawHUD</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	FHUDPackage HUDPackage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">FORCEINLINE <span class="type">void</span> <span class="title">SetHUDPackage</span><span class="params">(<span class="type">const</span> FHUDPackage&amp; Package)</span> </span>&#123; HUDPackage = Package; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在武器类中同样声明五个2D材质变量，用来存储每个武器自己的准星。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Weapon.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UTexture2D</span>* CrosshairCenter;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UTexture2D* CrosshairLeft;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UTexture2D* CrosshairRight;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UTexture2D* CrosshairTop;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UTexture2D* CrosshairBottom;</span><br></pre></td></tr></table></figure>
<p>在战斗组件中每帧进行准星设置：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CombatComponent.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AMPTPSPlayerController</span>* Controller;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AMultiplayerTPSHUD</span>* HUD;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CombatComponent.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::SetHUDCrosshairs</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!Character || !Character-&gt;Controller) <span class="keyword">return</span>;</span><br><span class="line">	Controller = Controller == <span class="literal">nullptr</span> ? <span class="built_in">Cast</span>&lt;AMPTPSPlayerController&gt;(Character-&gt;Controller) : Controller;</span><br><span class="line">	<span class="keyword">if</span> (Controller) &#123;</span><br><span class="line">		HUD = HUD == <span class="literal">nullptr</span> ? <span class="built_in">Cast</span>&lt;AMultiplayerTPSHUD&gt;(Controller-&gt;<span class="built_in">GetHUD</span>()) : HUD;</span><br><span class="line">		<span class="keyword">if</span> (HUD) &#123;</span><br><span class="line">			FHUDPackage HUDPackage;</span><br><span class="line">			<span class="keyword">if</span> (EquippedWeapon) &#123;</span><br><span class="line">				HUDPackage.CrosshairCenter = EquippedWeapon-&gt;CrosshairCenter;</span><br><span class="line">				HUDPackage.CrosshairLeft = EquippedWeapon-&gt;CrosshairLeft;</span><br><span class="line">				HUDPackage.CrosshairRight = EquippedWeapon-&gt;CrosshairRight;</span><br><span class="line">				HUDPackage.CrosshairTop = EquippedWeapon-&gt;CrosshairTop;</span><br><span class="line">				HUDPackage.CrosshairBottom = EquippedWeapon-&gt;CrosshairBottom;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				HUDPackage.CrosshairCenter = <span class="literal">nullptr</span>;</span><br><span class="line">				HUDPackage.CrosshairLeft = <span class="literal">nullptr</span>;</span><br><span class="line">				HUDPackage.CrosshairRight = <span class="literal">nullptr</span>;</span><br><span class="line">				HUDPackage.CrosshairTop = <span class="literal">nullptr</span>;</span><br><span class="line">				HUDPackage.CrosshairBottom = <span class="literal">nullptr</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			HUD-&gt;<span class="built_in">SetHUDPackage</span>(HUDPackage);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在HUD类中实现准星绘制：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSHUD::DrawHUD</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">DrawHUD</span>();</span><br><span class="line"></span><br><span class="line">	FVector2D ViewportSize;</span><br><span class="line">	<span class="keyword">if</span> (GEngine) &#123;</span><br><span class="line">		GEngine-&gt;GameViewport-&gt;<span class="built_in">GetViewportSize</span>(ViewportSize);</span><br><span class="line">		<span class="function"><span class="type">const</span> FVector2D <span class="title">ViewportCenter</span><span class="params">(ViewportSize.X / <span class="number">2.f</span>, ViewportSize.Y / <span class="number">2.f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (HUDPackage.CrosshairCenter) &#123;</span><br><span class="line">			<span class="built_in">DrawCrosshair</span>(HUDPackage.CrosshairCenter, ViewportCenter);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (HUDPackage.CrosshairLeft) &#123;</span><br><span class="line">			<span class="built_in">DrawCrosshair</span>(HUDPackage.CrosshairLeft, ViewportCenter);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (HUDPackage.CrosshairRight) &#123;</span><br><span class="line">			<span class="built_in">DrawCrosshair</span>(HUDPackage.CrosshairRight, ViewportCenter);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (HUDPackage.CrosshairTop) &#123;</span><br><span class="line">			<span class="built_in">DrawCrosshair</span>(HUDPackage.CrosshairTop, ViewportCenter);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (HUDPackage.CrosshairBottom) &#123;</span><br><span class="line">			<span class="built_in">DrawCrosshair</span>(HUDPackage.CrosshairBottom, ViewportCenter);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSHUD::DrawCrosshair</span><span class="params">(UTexture2D* Texture, FVector2D ViewportCenter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">float</span> TextureWidth = Texture-&gt;<span class="built_in">GetSizeX</span>();</span><br><span class="line">	<span class="type">const</span> <span class="type">float</span> TextureHeight = Texture-&gt;<span class="built_in">GetSizeY</span>();</span><br><span class="line">	<span class="function"><span class="type">const</span> FVector2D <span class="title">TextureDrawPoint</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		ViewportCenter.X - (TextureWidth / <span class="number">2.f</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">		ViewportCenter.Y - (TextureHeight / <span class="number">2.f</span>)</span></span></span><br><span class="line"><span class="params"><span class="function">	)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">DrawTexture</span>(</span><br><span class="line">		Texture,</span><br><span class="line">		TextureDrawPoint.X,</span><br><span class="line">		TextureDrawPoint.Y,</span><br><span class="line">		TextureWidth,</span><br><span class="line">		TextureHeight,</span><br><span class="line">		<span class="number">0.f</span>,</span><br><span class="line">		<span class="number">0.f</span>,</span><br><span class="line">		<span class="number">1.f</span>,</span><br><span class="line">		<span class="number">1.f</span>,</span><br><span class="line">		FLinearColor::White</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在射击游戏中，通常准星都会有各种扩散（当然一般来说没什么人会开，但是开不开是玩家的事，有没有是开发者的事），这个扩散值由用各种“因子”来决定，包括速度，瞄准，跳跃，射击等。这里直接给出添加了扩散后的准星绘制代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSHUD.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, Category = <span class="string">&quot;Player Stats&quot;</span>)</span><br><span class="line">TSubclassOf&lt;<span class="keyword">class</span> <span class="title class_">UUserWidget</span>&gt; CharacterOverlayClass;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CombatComponent.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::TickComponent</span><span class="params">(<span class="type">float</span> DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (Character &amp;&amp; Character-&gt;<span class="built_in">IsLocallyControlled</span>()) &#123;</span><br><span class="line">		<span class="built_in">SetHUDCrosshairs</span>(DeltaTime);</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::SetHUDCrosshairs</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//UE_LOG(LogTemp, Warning, TEXT(&quot;Crosshair set.&quot;));</span></span><br><span class="line">	<span class="keyword">if</span> (!Character || !Character-&gt;Controller) <span class="keyword">return</span>;</span><br><span class="line">	Controller = Controller == <span class="literal">nullptr</span> ? <span class="built_in">Cast</span>&lt;AMPTPSPlayerController&gt;(Character-&gt;Controller) : Controller;</span><br><span class="line">	<span class="keyword">if</span> (Controller) &#123;</span><br><span class="line">		HUD = HUD == <span class="literal">nullptr</span> ? <span class="built_in">Cast</span>&lt;AMultiplayerTPSHUD&gt;(Controller-&gt;<span class="built_in">GetHUD</span>()) : HUD;</span><br><span class="line">		<span class="keyword">if</span> (HUD) &#123;</span><br><span class="line">			<span class="keyword">if</span> (EquippedWeapon) &#123;</span><br><span class="line">				HUDPackage.CrosshairCenter = EquippedWeapon-&gt;CrosshairCenter;</span><br><span class="line">				HUDPackage.CrosshairLeft = EquippedWeapon-&gt;CrosshairLeft;</span><br><span class="line">				HUDPackage.CrosshairRight = EquippedWeapon-&gt;CrosshairRight;</span><br><span class="line">				HUDPackage.CrosshairTop = EquippedWeapon-&gt;CrosshairTop;</span><br><span class="line">				HUDPackage.CrosshairBottom = EquippedWeapon-&gt;CrosshairBottom;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				HUDPackage.CrosshairCenter = <span class="literal">nullptr</span>;</span><br><span class="line">				HUDPackage.CrosshairLeft = <span class="literal">nullptr</span>;</span><br><span class="line">				HUDPackage.CrosshairRight = <span class="literal">nullptr</span>;</span><br><span class="line">				HUDPackage.CrosshairTop = <span class="literal">nullptr</span>;</span><br><span class="line">				HUDPackage.CrosshairBottom = <span class="literal">nullptr</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="function">FVector2D <span class="title">WalkSpeedRange</span><span class="params">(<span class="number">0.f</span>, Character-&gt;GetCharacterMovement()-&gt;MaxWalkSpeed)</span></span>;</span><br><span class="line">			<span class="function">FVector2d <span class="title">VelocityMultiplierRange</span><span class="params">(<span class="number">0.f</span>, <span class="number">1.f</span>)</span></span>;</span><br><span class="line">			FVector Velocity = Character-&gt;<span class="built_in">GetVelocity</span>();</span><br><span class="line">			Velocity.Z = <span class="number">0.f</span>;</span><br><span class="line">			CrosshairVelocityFactor = FMath::<span class="built_in">GetMappedRangeValueClamped</span>(WalkSpeedRange, VelocityMultiplierRange, Velocity.<span class="built_in">Size</span>());</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (Character-&gt;<span class="built_in">GetCharacterMovement</span>()-&gt;<span class="built_in">IsFalling</span>()) &#123;</span><br><span class="line">				CrosshairInAirFactor = FMath::<span class="built_in">FInterpTo</span>(CrosshairInAirFactor, <span class="number">2.25f</span>, DeltaTime, <span class="number">2.25f</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				CrosshairInAirFactor= FMath::<span class="built_in">FInterpTo</span>(CrosshairInAirFactor, <span class="number">0.f</span>, DeltaTime, <span class="number">30.f</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (bAiming) &#123;</span><br><span class="line">				CrosshairAimFactor = FMath::<span class="built_in">FInterpTo</span>(CrosshairAimFactor, <span class="number">0.58f</span>, DeltaTime, <span class="number">30.f</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				CrosshairAimFactor = FMath::<span class="built_in">FInterpTo</span>(CrosshairAimFactor, <span class="number">0.f</span>, DeltaTime, <span class="number">30.f</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			CrosshairShootingFactor = FMath::<span class="built_in">FInterpTo</span>(CrosshairShootingFactor, <span class="number">0.f</span>, DeltaTime, <span class="number">40.f</span>);</span><br><span class="line"></span><br><span class="line">			HUDPackage.CrosshairSpread = <span class="number">0.5f</span> + CrosshairVelocityFactor + CrosshairInAirFactor - CrosshairAimFactor + CrosshairShootingFactor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			HUD-&gt;<span class="built_in">SetHUDPackage</span>(HUDPackage);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSHUD</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSHUD::DrawHUD</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">DrawHUD</span>();</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> SpreadScaled = CrosshairSpreadMax * HUDPackage.CrosshairSpread;</span><br><span class="line"></span><br><span class="line">	FVector2D ViewportSize;</span><br><span class="line">	<span class="keyword">if</span> (GEngine) &#123;</span><br><span class="line">		GEngine-&gt;GameViewport-&gt;<span class="built_in">GetViewportSize</span>(ViewportSize);</span><br><span class="line">		<span class="function"><span class="type">const</span> FVector2D <span class="title">ViewportCenter</span><span class="params">(ViewportSize.X / <span class="number">2.f</span>, ViewportSize.Y / <span class="number">2.f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (HUDPackage.CrosshairCenter) &#123;</span><br><span class="line">			<span class="function">FVector2D <span class="title">Spread</span><span class="params">(<span class="number">0.f</span>, <span class="number">0.f</span>)</span></span>;</span><br><span class="line">			<span class="built_in">DrawCrosshair</span>(HUDPackage.CrosshairCenter, ViewportCenter, Spread, HUDPackage.CrosshairColor);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (HUDPackage.CrosshairLeft) &#123;</span><br><span class="line">			<span class="function">FVector2D <span class="title">Spread</span><span class="params">(-SpreadScaled, <span class="number">0.f</span>)</span></span>;</span><br><span class="line">			<span class="built_in">DrawCrosshair</span>(HUDPackage.CrosshairLeft, ViewportCenter, Spread, HUDPackage.CrosshairColor);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (HUDPackage.CrosshairRight) &#123;</span><br><span class="line">			<span class="function">FVector2D <span class="title">Spread</span><span class="params">(SpreadScaled, <span class="number">0.f</span>)</span></span>;</span><br><span class="line">			<span class="built_in">DrawCrosshair</span>(HUDPackage.CrosshairRight, ViewportCenter, Spread, HUDPackage.CrosshairColor);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (HUDPackage.CrosshairTop) &#123;</span><br><span class="line">			<span class="function">FVector2D <span class="title">Spread</span><span class="params">(<span class="number">0.f</span>, -SpreadScaled)</span></span>;</span><br><span class="line">			<span class="built_in">DrawCrosshair</span>(HUDPackage.CrosshairTop, ViewportCenter, Spread, HUDPackage.CrosshairColor);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (HUDPackage.CrosshairBottom) &#123;</span><br><span class="line">			<span class="function">FVector2D <span class="title">Spread</span><span class="params">(<span class="number">0.f</span>, SpreadScaled)</span></span>;</span><br><span class="line">			<span class="built_in">DrawCrosshair</span>(HUDPackage.CrosshairBottom, ViewportCenter, Spread, HUDPackage.CrosshairColor);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当准星瞄准特定的对象时应该改变颜色。这里的特定对象不仅包含敌人，也可能包含场景中的可破坏道具等，所以不能简单地将瞄准的对象进行转换来实现。这里的实现方式是<strong>接口</strong>。</p>
<p>面向对象编程的一个核心思想是<strong>数据抽象</strong>，而接口的思想与这有些相似，我称之为<strong>功能抽象</strong>：它允许一些彼此可能类似也可能完全不同的对象去执行名称相同、概念相似的操作。例如门、开关和冰箱，它们是不同的对象，但都可以执行“开”这个动作，尽管动作的内部逻辑并不相同。</p>
<p>创建接口类后，如果想要使用接口，需要保证使用接口的类继承这个接口类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MULTIPLAYERTPS_API</span> AMultiplayerTPSCharacter : <span class="keyword">public</span> ACharacter, <span class="keyword">public</span> IInteractWithCrosshairsInterface</span><br></pre></td></tr></table></figure>
<p>这里使用的只是接口的一个小功能。我们可以通过<code>Implements&lt;UInteractWithCrosshairsInterface&gt;()</code>函数来判断一个类有没有实现特定的接口，如果瞄准的对象实现了这个接口，就设置准星的颜色为红色，否则为白色：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (TraceHitResult.<span class="built_in">GetActor</span>() &amp;&amp; TraceHitResult.<span class="built_in">GetActor</span>()-&gt;<span class="built_in">Implements</span>&lt;UInteractWithCrosshairsInterface&gt;()) &#123;</span><br><span class="line">	HUDPackage.CrosshairColor = FLinearColor::Red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	HUDPackage.CrosshairColor = FLinearColor::White;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一个小细节。在 UE 中，接口由两部分组成：</p>
<ul>
<li><code>U</code> 开头的类（如 <code>UInteractWithCrosshairsInterface</code>）：继承自 <code>UInterface</code>，用于反射系统识别接口类型，支持蓝图调用与类型检查。</li>
<li><code>I</code> 开头的类（如 <code>IInteractWithCrosshairsInterface</code>）：纯 C++ 接口，包含你要实现的函数声明。</li>
</ul>
<p>在继承接口类时，继承的是<code>IInteractWithCrosshairsInterface</code>，而在检测对象是否实现了接口时使用的是<code>UInteractWithCrosshairsInterface</code>。<em>**</em></p>
<h3 id="3-11-受击"><a href="#3-11-受击" class="headerlink" title="3.11 受击"></a>3.11 受击</h3><p>和开火时一样，受击动画也要通过多播RPC进行同步。不同的时，受击只会在服务器上发生，所以不需要在客户端调用<code>Server RPC</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSCharacter.h</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PlayHitReactMontage</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">UFUNCTION</span>(NetMulticast, Unreliable)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MulticastHit</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSCharacter.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::PlayHitReactMontage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!Combat || !Combat-&gt;EquippedWeapon) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	UAnimInstance* AnimInstance = <span class="built_in">GetMesh</span>()-&gt;<span class="built_in">GetAnimInstance</span>();</span><br><span class="line">	<span class="keyword">if</span> (AnimInstance &amp;&amp; HitReactMontage) &#123;</span><br><span class="line">		AnimInstance-&gt;<span class="built_in">Montage_Play</span>(HitReactMontage);</span><br><span class="line">		<span class="function">FName <span class="title">SectionName</span><span class="params">(<span class="string">&quot;FromFront&quot;</span>)</span></span>;</span><br><span class="line">		AnimInstance-&gt;<span class="built_in">Montage_JumpToSection</span>(SectionName);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::MulticastHit_Implementation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">PlayHitReactMontage</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当子弹碰到角色时调用多播RPC：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Projectile.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AProjectile::OnHit</span><span class="params">(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, <span class="type">const</span> FHitResult&amp; Hit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	AMultiplayerTPSCharacter* MultiplayerTPSCharacter = <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(OtherActor);</span><br><span class="line">	<span class="keyword">if</span> (MultiplayerTPSCharacter) &#123;</span><br><span class="line">		MultiplayerTPSCharacter-&gt;<span class="built_in">MulticastHit</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">Destroy</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了使子弹能精确击中敌人的网格体而不是胶囊，这里添加了一个检测碰撞通道，并将Projectile对这个通道的碰撞设为<code>Block</code>。为了使用能够理解的名字而不是“第一个通道”，添加了一个宏。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ECC_SkeletalMesh ECollisionChannel::ECC_GameTraceChannel1</span></span><br><span class="line"></span><br><span class="line">CollisionBox-&gt;<span class="built_in">SetCollisionResponseToChannel</span>(ECC_SkeletalMesh, ECollisionResponse::ECR_Block);</span><br></pre></td></tr></table></figure>
<p>将角色的骨骼网格体的碰撞通道设为自定义的通道即可。</p>
<h3 id="3-12-自动开火"><a href="#3-12-自动开火" class="headerlink" title="3.12 自动开火"></a>3.12 自动开火</h3><p>对于可以自动开火的武器，当一次射击完成，到达开火间隔后如果仍然按着开火键，应该自动进行下一次开火。可以通过计时器完成这个操作。</p>
<p>在战斗组件中声明计时器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CombatComponent.h</span></span><br><span class="line">FTimerHandle FireTimer;</span><br><span class="line"><span class="type">bool</span> bCanFire = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StartFireTimer</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FireTimerFinished</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>当开火时启动计时器，同时将<code>bCanFire</code>设为false，计时结束后重写将<code>bCanFire</code>设为true，同时如果是自动武器并且仍然按着开火键，就继续射击。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CombatComponent.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::FireButtonPressed</span><span class="params">(<span class="type">bool</span> bPressed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bFireButtonPressed = bPressed;</span><br><span class="line">	<span class="keyword">if</span> (bFireButtonPressed) &#123;</span><br><span class="line">		<span class="keyword">if</span> (EquippedWeapon) &#123;</span><br><span class="line">			<span class="built_in">Fire</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::Fire</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bCanFire) &#123;</span><br><span class="line">		<span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;Fire!&quot;</span>));</span><br><span class="line">		bCanFire = <span class="literal">false</span>;</span><br><span class="line">		<span class="built_in">ServerFire</span>(HitTarget);</span><br><span class="line">		<span class="keyword">if</span> (EquippedWeapon) &#123;</span><br><span class="line">			CrosshairShootingFactor = <span class="number">0.8f</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">StartFireTimer</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">计时结束后重写将bCanFire设为<span class="literal">true</span>，同时如果是自动武器并且仍然按着开火键，就继续射击。</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::StartFireTimer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!EquippedWeapon || !Character) <span class="keyword">return</span>;</span><br><span class="line">	Character-&gt;<span class="built_in">GetWorldTimerManager</span>().<span class="built_in">SetTimer</span>(</span><br><span class="line">		FireTimer,</span><br><span class="line">		<span class="keyword">this</span>,</span><br><span class="line">		&amp;UCombatComponent::FireTimerFinished,</span><br><span class="line">		EquippedWeapon-&gt;FireDelay</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::FireTimerFinished</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!EquippedWeapon) <span class="keyword">return</span>;</span><br><span class="line">	bCanFire = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (bFireButtonPressed &amp;&amp; EquippedWeapon-&gt;bAutomatic) &#123;</span><br><span class="line">		<span class="built_in">Fire</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-13-优化"><a href="#3-13-优化" class="headerlink" title="3.13 优化"></a>3.13 优化</h3><p>当瞄准的对象从远处的对象突然到近处的对象时，枪口会有瞬移的效果，所以在枪口移动时需要做一个插值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (MultiplayerTPSCharacter-&gt;<span class="built_in">IsLocallyControlled</span>()) &#123;</span><br><span class="line">	bLocallyControlled = <span class="literal">true</span>;</span><br><span class="line">	FTransform RightHnadTransform = EquippedWeapon-&gt;<span class="built_in">GetWeaponMesh</span>()-&gt;<span class="built_in">GetSocketTransform</span>(<span class="built_in">FName</span>(<span class="string">&quot;hand_r&quot;</span>), ERelativeTransformSpace::RTS_World);</span><br><span class="line">	FRotator LookAtRotation = UKismetMathLibrary::<span class="built_in">FindLookAtRotation</span>(RightHnadTransform.<span class="built_in">GetLocation</span>(), RightHnadTransform.<span class="built_in">GetLocation</span>() + (RightHnadTransform.<span class="built_in">GetLocation</span>() - MultiplayerTPSCharacter-&gt;<span class="built_in">GetHitTarget</span>()));</span><br><span class="line">	RightHandRotation = FMath::<span class="built_in">RInterpTo</span>(RightHandRotation, LookAtRotation, DeltaTime, <span class="number">30.f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当摄像机被墙挡住时会拉近和角色之间的距离，此时准星可能会对准角色身后的角色甚至自己，导致武器指向身后并且准星对准自己的时候会变红。解决方法是在射线检测时将起点移到角色前面：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FVector Start = CrosshairWorldPosition;</span><br><span class="line"><span class="keyword">if</span> (Character) &#123;</span><br><span class="line">	<span class="type">float</span> DistanceToCharacter = (Character-&gt;<span class="built_in">GetActorLocation</span>() - Start).<span class="built_in">Size</span>();</span><br><span class="line">	Start += CrosshairWorldDirection * (DistanceToCharacter + <span class="number">100.f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当摄像机撞墙时可能视野会被角色完全遮挡，此时需要隐藏角色：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line"><span class="type">float</span> CameraThreshold = <span class="number">200.f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在Tick中调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::HideCameraIfCharacterClose</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">IsLocallyControlled</span>()) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((FollowCamera-&gt;<span class="built_in">GetComponentLocation</span>() - <span class="built_in">GetActorLocation</span>()).<span class="built_in">Size</span>() &lt; CameraThreshold) &#123;</span><br><span class="line">		<span class="built_in">GetMesh</span>()-&gt;<span class="built_in">SetVisibility</span>(<span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">if</span> (Combat &amp;&amp; Combat-&gt;EquippedWeapon &amp;&amp; Combat-&gt;EquippedWeapon-&gt;<span class="built_in">GetWeaponMesh</span>()) &#123;</span><br><span class="line">			Combat-&gt;EquippedWeapon-&gt;<span class="built_in">GetWeaponMesh</span>()-&gt;bOwnerNoSee = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">GetMesh</span>()-&gt;<span class="built_in">SetVisibility</span>(<span class="literal">true</span>);</span><br><span class="line">		<span class="keyword">if</span> (Combat &amp;&amp; Combat-&gt;EquippedWeapon &amp;&amp; Combat-&gt;EquippedWeapon-&gt;<span class="built_in">GetWeaponMesh</span>()) &#123;</span><br><span class="line">			Combat-&gt;EquippedWeapon-&gt;<span class="built_in">GetWeaponMesh</span>()-&gt;bOwnerNoSee = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.keshiki.top">Keshiki</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.keshiki.top/undefined/e6c9f323.html">https://www.keshiki.top/undefined/e6c9f323.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://www.keshiki.top" target="_blank">Keshiki's Blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Keshiki</div><div class="author-info-description">我们的头脑比天空更辽阔.</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yuun4g1"><i class="fab fa-github"></i><span>我的github</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到Keshiki领域~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E3%80%90UE5%E3%80%91%E5%A4%9A%E4%BA%BA%E8%81%94%E6%9C%BATPS%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89-%E2%80%94%E2%80%94-%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6"><span class="toc-number">1.</span> <span class="toc-text">【UE5】多人联机TPS游戏开发（二） —— 基础框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AE%89%E8%A3%85%E8%81%94%E6%9C%BA%E6%8F%92%E4%BB%B6"><span class="toc-number">1.1.</span> <span class="toc-text">1.安装联机插件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA"><span class="toc-number">1.2.</span> <span class="toc-text">2.项目基础搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E8%A7%92%E8%89%B2"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 角色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%A4%A7%E5%8E%85%E6%B8%B8%E6%88%8F%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 大厅游戏模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%EF%BC%9ANet-Role"><span class="toc-number">1.2.3.</span> <span class="toc-text">补充知识：Net Role</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%B0%84%E5%87%BB%E6%B8%B8%E6%88%8F%E5%9F%BA%E7%A1%80"><span class="toc-number">1.3.</span> <span class="toc-text">3 射击游戏基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%AD%A6%E5%99%A8%E7%B1%BB"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 武器类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%8B%BE%E5%8F%96UI%E7%BB%84%E4%BB%B6%EF%BC%88%E5%A4%8D%E5%88%B6%EF%BC%89"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 拾取UI组件（复制）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E8%A3%85%E5%A4%87%E6%AD%A6%E5%99%A8%EF%BC%88RPC%EF%BC%89"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 装备武器（RPC）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E8%B9%B2%E4%BC%8F"><span class="toc-number">1.3.4.</span> <span class="toc-text">3.4 蹲伏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E7%9E%84%E5%87%86"><span class="toc-number">1.3.5.</span> <span class="toc-text">3.5 瞄准</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E7%9E%84%E5%87%86%E5%81%8F%E7%A7%BB"><span class="toc-number">1.3.6.</span> <span class="toc-text">3.6 瞄准偏移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-%E5%9F%BA%E7%A1%80%E5%B0%84%E5%87%BB"><span class="toc-number">1.3.7.</span> <span class="toc-text">3.7 基础射击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-%E5%BC%B9%E9%81%93%E6%AD%A6%E5%99%A8"><span class="toc-number">1.3.8.</span> <span class="toc-text">3.8 弹道武器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-%E5%8D%B3%E6%97%B6%E5%91%BD%E4%B8%AD%E6%AD%A6%E5%99%A8"><span class="toc-number">1.3.9.</span> <span class="toc-text">3.9 即时命中武器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-10-%E5%87%86%E6%98%9F"><span class="toc-number">1.3.10.</span> <span class="toc-text">3.10 准星</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-11-%E5%8F%97%E5%87%BB"><span class="toc-number">1.3.11.</span> <span class="toc-text">3.11 受击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-12-%E8%87%AA%E5%8A%A8%E5%BC%80%E7%81%AB"><span class="toc-number">1.3.12.</span> <span class="toc-text">3.12 自动开火</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-13-%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.13.</span> <span class="toc-text">3.13 优化</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/undefined/c1786556.html" title="【GDC】守望先锋的游戏架构和网络代码"><img src="https://s21.ax1x.com/2025/09/01/pVcj2qK.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【GDC】守望先锋的游戏架构和网络代码"/></a><div class="content"><a class="title" href="/undefined/c1786556.html" title="【GDC】守望先锋的游戏架构和网络代码">【GDC】守望先锋的游戏架构和网络代码</a><time datetime="2025-08-31T16:00:00.000Z" title="发表于 2025-09-01 00:00:00">2025-09-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/undefined/af2b6aaf.html" title="【UE5】多人联机TPS游戏开发（四） ——  延迟补偿">【UE5】多人联机TPS游戏开发（四） ——  延迟补偿</a><time datetime="2025-08-13T16:00:00.000Z" title="发表于 2025-08-14 00:00:00">2025-08-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/undefined/f9d4ce84.html" title="【UE5】多人联机TPS游戏开发（三） —— 射击游戏核心">【UE5】多人联机TPS游戏开发（三） —— 射击游戏核心</a><time datetime="2025-08-02T16:00:00.000Z" title="发表于 2025-08-03 00:00:00">2025-08-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/undefined/e6c9f323.html" title="【UE5】多人联机TPS游戏开发（二） —— 基础框架">【UE5】多人联机TPS游戏开发（二） —— 基础框架</a><time datetime="2025-07-16T16:00:00.000Z" title="发表于 2025-07-17 00:00:00">2025-07-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/undefined/f18ea7eb.html" title="【UE5】多人联机TPS游戏开发（一） ——  制作联机插件">【UE5】多人联机TPS游戏开发（一） ——  制作联机插件</a><time datetime="2025-07-04T16:00:00.000Z" title="发表于 2025-07-05 00:00:00">2025-07-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By Keshiki</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><div class="aplayer no-destroy" data-id="4875655013" data-server="netease" data-type="playlist"   data-order="list" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true" ></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><div class="app-refresh" id="app-refresh" style="position: fixed;top: -2.2rem;left: 0;right: 0;z-index: 99999;padding: 0 1rem;font-size: 15px;height: 2.2rem;transition: all 0.3s ease;"><div class="app-refresh-wrap" style=" display: flex;color: #fff;height: 100%;align-items: center;justify-content: center;"><label>好像有什么动静</label><a href="javascript:void(0)" onclick="location.reload()"><span style="color: #fff;text-decoration: underline;cursor: pointer;">去看看</span></a></div></div><script>if ('serviceWorker' in navigator) {
if (navigator.serviceWorker.controller) {
navigator.serviceWorker.addEventListener('controllerchange', function() {
showNotification()
})
}
window.addEventListener('load', function() {
navigator.serviceWorker.register('/sw.js')
})
}
function showNotification() {
if (GLOBAL_CONFIG.Snackbar) {
var snackbarBg =
document.documentElement.getAttribute('data-theme') === 'light' ?
GLOBAL_CONFIG.Snackbar.bgLight :
GLOBAL_CONFIG.Snackbar.bgDark
var snackbarPos = GLOBAL_CONFIG.Snackbar.position
Snackbar.show({
text: '好像有什么动静',
backgroundColor: snackbarBg,
duration: 500000,
pos: snackbarPos,
actionText: '去看看',
actionTextColor: '#fff',
onActionClick: function(e) {
location.reload()
},
})
} else {
var showBg =
document.documentElement.getAttribute('data-theme') === 'light' ?
'#3b70fc' :
'#1f1f1f'
var cssText = `top: 0; background: ${showBg};`
document.getElementById('app-refresh').style.cssText = cssText
}
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__slideInRight');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><script async src="/js/ali_font.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>