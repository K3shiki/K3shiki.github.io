<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>【UE5】多人联机TPS游戏开发（三） —— 射击游戏核心 | Keshiki's Blog</title><meta name="author" content="Keshiki"><meta name="copyright" content="Keshiki"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="【UE5】多人联机TPS游戏开发（三） —— 射击游戏核心 这一部分开始接近一个射击游戏的核心功能，包括HUD、开火、弹药，以及各种武器的实现等。 同时，在这一部分中也会开始通过Gameplay框架来实现游戏玩法的管理，以及使愈发复杂的游戏功能变得更加有条理。之前只是通过官方文档死记硬背，完全无法理解Gameplay框架到底是干什么的，而在实际上手之后才发现，Gameplay框架只是一些引擎提供的">
<meta property="og:type" content="article">
<meta property="og:title" content="【UE5】多人联机TPS游戏开发（三） —— 射击游戏核心">
<meta property="og:url" content="https://www.keshiki.top/undefined/f9d4ce84.html">
<meta property="og:site_name" content="Keshiki&#39;s Blog">
<meta property="og:description" content="【UE5】多人联机TPS游戏开发（三） —— 射击游戏核心 这一部分开始接近一个射击游戏的核心功能，包括HUD、开火、弹药，以及各种武器的实现等。 同时，在这一部分中也会开始通过Gameplay框架来实现游戏玩法的管理，以及使愈发复杂的游戏功能变得更加有条理。之前只是通过官方文档死记硬背，完全无法理解Gameplay框架到底是干什么的，而在实际上手之后才发现，Gameplay框架只是一些引擎提供的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.keshiki.top/img/avatar.png">
<meta property="article:published_time" content="2025-08-02T16:00:00.000Z">
<meta property="article:modified_time" content="2025-08-13T17:44:24.210Z">
<meta property="article:author" content="Keshiki">
<meta property="article:tag" content="Keshiki,Keshiki&#39;s Blog,Keshiki的博客,博客,Blog,blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.keshiki.top/img/avatar.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "【UE5】多人联机TPS游戏开发（三） —— 射击游戏核心",
  "url": "https://www.keshiki.top/undefined/f9d4ce84.html",
  "image": "https://www.keshiki.top/img/avatar.png",
  "datePublished": "2025-08-02T16:00:00.000Z",
  "dateModified": "2025-08-13T17:44:24.210Z",
  "author": [
    {
      "@type": "Person",
      "name": "Keshiki",
      "url": "https://www.keshiki.top/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://www.keshiki.top/undefined/f9d4ce84.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/manifest.json"/><meta name="msapplication-TileColor" content="#39C5BB"/><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/128.png"/><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/16.png"/><link rel="mask-icon" href="/img/siteicon/128.png" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【UE5】多人联机TPS游戏开发（三） —— 射击游戏核心',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Keshiki's Blog" type="application/atom+xml">
</head><body><div id="web_bg" style="background-image: url(https://s21.ax1x.com/2024/12/11/pAbSVg0.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/index.html"><i class="fa-fw fas fa-home"></i><span> 追番</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Keshiki's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">【UE5】多人联机TPS游戏开发（三） —— 射击游戏核心</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/index.html"><i class="fa-fw fas fa-home"></i><span> 追番</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">【UE5】多人联机TPS游戏开发（三） —— 射击游戏核心</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-08-02T16:00:00.000Z" title="发表于 2025-08-03 00:00:00">2025-08-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-13T17:44:24.210Z" title="更新于 2025-08-14 01:44:24">2025-08-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="【UE5】多人联机TPS游戏开发（三）-——-射击游戏核心"><a href="#【UE5】多人联机TPS游戏开发（三）-——-射击游戏核心" class="headerlink" title="【UE5】多人联机TPS游戏开发（三） —— 射击游戏核心"></a>【UE5】多人联机TPS游戏开发（三） —— 射击游戏核心</h1><blockquote>
<p>这一部分开始接近一个射击游戏的核心功能，包括HUD、开火、弹药，以及各种武器的实现等。</p>
<p>同时，在这一部分中也会开始通过Gameplay框架来实现游戏玩法的管理，以及使愈发复杂的游戏功能变得更加有条理。之前只是通过官方文档死记硬背，完全无法理解Gameplay框架到底是干什么的，而在实际上手之后才发现，Gameplay框架只是一些引擎提供的类，只要先了解这些类大概的作用，在有实际需求的时候自然就知道要用哪些类了。这个时候再去学习就比较轻松了。</p>
</blockquote>
<h2 id="1-HUD"><a href="#1-HUD" class="headerlink" title="1.HUD"></a>1.HUD</h2><p>在本项目中，主要通过<strong><code>HUD</code>类</strong>来管理各种UI，而HUD类又由<strong>玩家控制器</strong>来进行控制。</p>
<p>创建一个控件类<code>CharacterOverlay</code>用来显示玩家的主UI。从最基础的血量显示开始。</p>
<p>包含两个和控件蓝图绑定的元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(meta = (BindWidget))</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UProgressBar</span>* HealthBar;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(meta = (BindWidget))</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UTextBlock</span>* HealthText;</span><br></pre></td></tr></table></figure>
<p>在HUD类中将其添加到视口：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSHUD.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, Category = <span class="string">&quot;Player Stats&quot;</span>)</span><br><span class="line">TSubclassOf&lt;<span class="keyword">class</span> <span class="title class_">UUserWidget</span>&gt; CharacterOverlayClass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UCharacterOverlay</span>* CharacterOverlay;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSHUD.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSHUD::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line">	<span class="built_in">AddCharacterOverlay</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSHUD::AddCharacterOverlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	APlayerController* PlayerController = <span class="built_in">GetOwningPlayerController</span>();</span><br><span class="line">	<span class="keyword">if</span> (PlayerController &amp;&amp; CharacterOverlayClass) &#123;</span><br><span class="line">		CharacterOverlay = <span class="built_in">CreateWidget</span>&lt;UCharacterOverlay&gt;(PlayerController, CharacterOverlayClass);</span><br><span class="line">		CharacterOverlay-&gt;<span class="built_in">AddToViewport</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建自己的控制器类<code>MPTPSPlayerController</code>（我发誓以后再也不取这么长的项目名字了，类名还能超过字数显示的），在其中初始化HUD，并定义更新血量UI的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MPTPSPlayerController.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AMultiplayerTPSHUD</span>* MultiplayerTPSHUD;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MPTPSPlayerController.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line">	MultiplayerTPSHUD = <span class="built_in">Cast</span>&lt;AMultiplayerTPSHUD&gt;(<span class="built_in">GetHUD</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::SetHUDHealth</span><span class="params">(<span class="type">float</span> Health, <span class="type">float</span> MaxHealth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MultiplayerTPSHUD = MultiplayerTPSHUD == <span class="literal">nullptr</span> ? <span class="built_in">Cast</span>&lt;AMultiplayerTPSHUD&gt;(<span class="built_in">GetHUD</span>()) : MultiplayerTPSHUD;</span><br><span class="line">	<span class="keyword">if</span> (MultiplayerTPSHUD &amp;&amp; MultiplayerTPSHUD-&gt;CharacterOverlay &amp;&amp; MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HealthBar &amp;&amp; MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HealthText) &#123;</span><br><span class="line">		<span class="type">const</span> <span class="type">float</span> HealthPercent = Health / MaxHealth;</span><br><span class="line">		MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HealthBar-&gt;<span class="built_in">SetPercent</span>(HealthPercent);</span><br><span class="line">		FString HealthText = FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;%d/%d&quot;</span>), FMath::<span class="built_in">CeilToInt</span>(Health), FMath::<span class="built_in">CeilToInt</span>(MaxHealth));</span><br><span class="line">		MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HealthText-&gt;<span class="built_in">SetText</span>(FText::<span class="built_in">FromString</span>(HealthText));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::OnPossess</span><span class="params">(APawn* InPawn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">OnPossess</span>(InPawn);</span><br><span class="line"></span><br><span class="line">	AMultiplayerTPSCharacter* MultiplayerTPSCharacter = <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(InPawn);</span><br><span class="line">	<span class="keyword">if</span> (MultiplayerTPSCharacter) &#123;</span><br><span class="line">		<span class="built_in">SetHUDHealth</span>(MultiplayerTPSCharacter-&gt;<span class="built_in">GetHealth</span>(), MultiplayerTPSCharacter-&gt;<span class="built_in">GetMaxHealth</span>());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在角色类中定义血量相关的变量和处理函数。我之前想过血量作为角色的属性，为什么不放在“玩家状态”中？答案似乎是血量作为角色的核心属性，需要进行快速的同步，游戏状态的同步速度较慢无法达到要求，而角色的属性复制则可以满足同步需求。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSCharacter.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line"><span class="type">float</span> MaxHealth = <span class="number">100.f</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(ReplicatedUsing = OnRep_Health, VisibleAnywhere, Category = <span class="string">&quot;Player Stats&quot;</span>)</span><br><span class="line"><span class="type">float</span> Health = <span class="number">100.f</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnRep_Health</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AMPTPSPlayerController</span>* PlayerController;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSCharacter.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">	PlayerController = <span class="built_in">Cast</span>&lt;AMPTPSPlayerController&gt;(Controller);</span><br><span class="line">	<span class="keyword">if</span> (PlayerController) &#123;</span><br><span class="line">		PlayerController-&gt;<span class="built_in">SetHUDHealth</span>(Health, MaxHealth);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::UpdateHUDHealth</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PlayerController = PlayerController == <span class="literal">nullptr</span> ? <span class="built_in">Cast</span>&lt;AMPTPSPlayerController&gt;(Controller) : PlayerController;</span><br><span class="line">	<span class="keyword">if</span> (PlayerController) &#123;</span><br><span class="line">		PlayerController-&gt;<span class="built_in">SetHUDHealth</span>(Health, MaxHealth);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以直接在角色类中通过角色=》玩家控制器=》HUD=》<code>CharacterOverlay</code>的链条来控制血条的更新。</p>
<p>HUD的更新逻辑都差不多，主要还是要细心，在值可能更新的地方都要更新HUD，之后的HUD部分就不一一列举了。</p>
<h2 id="2-命中伤害"><a href="#2-命中伤害" class="headerlink" title="2.命中伤害"></a>2.命中伤害</h2><p>从<code>Projectile</code>类派生一个<code>ProjectileBullet</code>类，重写命中函数，对命中的角色应用伤害并更新UI。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AProjectileBullet::OnHit</span><span class="params">(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, <span class="type">const</span> FHitResult&amp; Hit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ACharacter* OwnerCharacter = <span class="built_in">Cast</span>&lt;ACharacter&gt;(<span class="built_in">GetOwner</span>());</span><br><span class="line">	<span class="keyword">if</span> (OwnerCharacter) &#123;</span><br><span class="line">		AController* OwnerController = OwnerCharacter-&gt;Controller;</span><br><span class="line">		<span class="keyword">if</span> (OwnerController) &#123;</span><br><span class="line">			UGameplayStatics::<span class="built_in">ApplyDamage</span>(OtherActor, Damage, OwnerController, <span class="keyword">this</span>, UDamageType::<span class="built_in">StaticClass</span>());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Super::<span class="built_in">OnHit</span>(HitComp, OtherActor, OtherComp, NormalImpulse, Hit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在角色类中注册伤害，绑定回调函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSCharacter.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UpdateHUDHealth</span>();</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">HasAuthority</span>()) &#123;</span><br><span class="line">		OnTakeAnyDamage.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;AMultiplayerTPSCharacter::ReceiveDamage);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (AttachedGrenade) &#123;</span><br><span class="line">		AttachedGrenade-&gt;<span class="built_in">SetVisibility</span>(<span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::ReceiveDamage</span><span class="params">(AActor* DamagedActor, <span class="type">float</span> Damage, <span class="type">const</span> UDamageType* DamageType, AController* InstigatorController, AActor* DamageCauser)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//UE_LOG(LogTemp, Warning, TEXT(&quot;Receive damage.&quot;));</span></span><br><span class="line">	Health = FMath::<span class="built_in">Clamp</span>(Health - Damage, <span class="number">0.f</span>, MaxHealth);</span><br><span class="line">	<span class="built_in">UpdateHUDHealth</span>();</span><br><span class="line">	<span class="built_in">PlayHitReactMontage</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前通过<code>Multicast RPC</code>实现了受击时的动画，但是RPC的和开销网络速度不如变量复制，所以现在可以通过血量的复制来实现受击动画。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::OnRep_Health</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">UpdateHUDHealth</span>();</span><br><span class="line">	<span class="built_in">PlayHitReactMontage</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-淘汰"><a href="#3-淘汰" class="headerlink" title="3.淘汰"></a>3.淘汰</h2><p>淘汰是对游戏中任意玩家进行的操作，很适合放在<strong>游戏模式</strong>中。</p>
<p>创建自己的游戏模式类，在其中定义淘汰玩家函数和重生玩家函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSGameMode.h</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSGameMode::PlayerEliminated</span><span class="params">(AMultiplayerTPSCharacter* ElimmedCharacter, AMPTPSPlayerController* VictimController, AMPTPSPlayerController* AttackerController)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ElimmedCharacter)</span><br><span class="line">	&#123;</span><br><span class="line">		ElimmedCharacter-&gt;<span class="built_in">Elim</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSGameMode::RequestRespawn</span><span class="params">(ACharacter* ElimmedCharacter, AController* ElimmedController)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ElimmedCharacter) &#123;</span><br><span class="line">		ElimmedCharacter-&gt;<span class="built_in">Reset</span>();</span><br><span class="line">		ElimmedCharacter-&gt;<span class="built_in">Destroy</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ElimmedController) &#123;</span><br><span class="line">		TArray&lt;AActor*&gt; PlayerStarts;</span><br><span class="line">		UGameplayStatics::<span class="built_in">GetAllActorsOfClass</span>(<span class="keyword">this</span>, APlayerStart::<span class="built_in">StaticClass</span>(), PlayerStarts);</span><br><span class="line">		int32 Selection = FMath::<span class="built_in">RandRange</span>(<span class="number">0</span>, PlayerStarts.<span class="built_in">Num</span>() - <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">RestartPlayerAtPlayerStart</span>(ElimmedController, PlayerStarts[Selection]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在角色类中，当受到伤害时，如果生命值变为0就通过游戏模式将其淘汰，并通过多播RPC播放淘汰动画。当淘汰时启用一个计时器，其回调函数会调用游戏模式的重生玩家函数来复活玩家。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSCharacter.h</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Elim</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>(NetMulticast, Reliable)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MulticastElim</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> bElimmed = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSCharacter.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::ReceiveDamage</span><span class="params">(AActor* DamagedActor, <span class="type">float</span> Damage, <span class="type">const</span> UDamageType* DamageType, AController* InstigatorController, AActor* DamageCauser)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Health = FMath::<span class="built_in">Clamp</span>(Health - Damage, <span class="number">0.f</span>, MaxHealth);</span><br><span class="line">	<span class="built_in">OnRep_Health</span>();</span><br><span class="line">	<span class="comment">//UpdateHUDHealth();</span></span><br><span class="line">	<span class="comment">//PlayHitReactMontage();</span></span><br><span class="line">	<span class="keyword">if</span> (Health == <span class="number">0.f</span>) &#123;</span><br><span class="line">		AMultiplayerTPSGameMode* MultiplayerTPSGameMode = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetAuthGameMode</span>&lt;AMultiplayerTPSGameMode&gt;();</span><br><span class="line">		<span class="keyword">if</span> (MultiplayerTPSGameMode) &#123;</span><br><span class="line">			PlayerController = PlayerController ? PlayerController : <span class="built_in">Cast</span>&lt;AMPTPSPlayerController&gt;(Controller);</span><br><span class="line">			AMPTPSPlayerController* AttackerController = <span class="built_in">Cast</span>&lt;AMPTPSPlayerController&gt;(InstigatorController);</span><br><span class="line">			MultiplayerTPSGameMode-&gt;<span class="built_in">PlayerEliminated</span>(<span class="keyword">this</span>, PlayerController, AttackerController);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::MulticastElim_Implementation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bElimmed = <span class="literal">true</span>;</span><br><span class="line">	<span class="built_in">PlayElimMontage</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSGameMode::PlayerEliminated</span><span class="params">(AMultiplayerTPSCharacter* ElimmedCharacter, AMPTPSPlayerController* VictimController, AMPTPSPlayerController* AttackerController)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ElimmedCharacter)</span><br><span class="line">	&#123;</span><br><span class="line">		ElimmedCharacter-&gt;<span class="built_in">Elim</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::Elim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">MulticastElim</span>();</span><br><span class="line">	<span class="built_in">GetWorldTimerManager</span>().<span class="built_in">SetTimer</span>(</span><br><span class="line">		ElimTimer,</span><br><span class="line">		<span class="keyword">this</span>,</span><br><span class="line">		&amp;AMultiplayerTPSCharacter::ElimTimerFinished,</span><br><span class="line">		ElimDelay</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::ElimTimerFinished</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	AMultiplayerTPSGameMode* MultiplayerTPSGameMode = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetAuthGameMode</span>&lt;AMultiplayerTPSGameMode&gt;();</span><br><span class="line">	<span class="keyword">if</span> (MultiplayerTPSGameMode) &#123;</span><br><span class="line">		MultiplayerTPSGameMode-&gt;<span class="built_in">RequestRespawn</span>(<span class="keyword">this</span>, Controller);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在角色淘汰时为角色添加一个无人机将角色溶解的效果，可以增加游戏性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Elim Bot</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UParticleSystem* ElimBotEffect;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere)</span><br><span class="line">UParticleSystemComponent* ElimBotComponent;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">USoundCue</span>* ElimBotSound;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Spawn elim bot</span></span><br><span class="line"><span class="keyword">if</span> (ElimBotEffect) &#123;</span><br><span class="line">	<span class="function">FVector <span class="title">ElimBotSpawnPoint</span><span class="params">(GetActorLocation().X, GetActorLocation().Y, GetActorLocation().Z + <span class="number">200.f</span>)</span></span>;</span><br><span class="line">	ElimBotComponent = UGameplayStatics::<span class="built_in">SpawnEmitterAtLocation</span>(</span><br><span class="line">		<span class="built_in">GetWorld</span>(),</span><br><span class="line">		ElimBotEffect,</span><br><span class="line">		ElimBotSpawnPoint,</span><br><span class="line">		<span class="built_in">GetActorRotation</span>()</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ElimBotSound) &#123;</span><br><span class="line">	UGameplayStatics::<span class="built_in">SpawnSoundAtLocation</span>(</span><br><span class="line">		<span class="keyword">this</span>,</span><br><span class="line">		ElimBotSound,</span><br><span class="line">		<span class="built_in">GetActorLocation</span>()</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::Destroyed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">Destroy</span>();</span><br><span class="line">	<span class="keyword">if</span> (ElimBotComponent) &#123;</span><br><span class="line">		ElimBotComponent-&gt;<span class="built_in">DestroyComponent</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//溶解效果</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere)</span><br><span class="line">UTimelineComponent* DissolveTimeline;</span><br><span class="line">FOnTimelineFloat DissolveTrack;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UCurveFloat* DissolveCurve;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UpdateDissolveMaterial</span><span class="params">(<span class="type">float</span> DissolveValue)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StartDissolve</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实时改变的动态材质实例</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere, Category = <span class="string">&quot;Elim&quot;</span>)</span><br><span class="line">UMaterialInstanceDynamic* DynamicDissolveMaterialInstance;</span><br><span class="line"></span><br><span class="line"><span class="comment">//蓝图中设置的动态材质实例</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, Category = <span class="string">&quot;Elim&quot;</span>)</span><br><span class="line">UMaterialInstance* DissolveMaterialInstance;</span><br><span class="line"></span><br><span class="line">两个时间轴相关的函数：</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::UpdateDissolveMaterial</span><span class="params">(<span class="type">float</span> DissolveValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (DynamicDissolveMaterialInstance) &#123;</span><br><span class="line">		DynamicDissolveMaterialInstance-&gt;<span class="built_in">SetScalarParameterValue</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Dissolve&quot;</span>), DissolveValue);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::StartDissolve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DissolveTrack.<span class="built_in">BindDynamic</span>(<span class="keyword">this</span>, &amp;AMultiplayerTPSCharacter::UpdateDissolveMaterial);</span><br><span class="line">	<span class="keyword">if</span> (DissolveCurve &amp;&amp; DissolveTimeline) &#123;</span><br><span class="line">		DissolveTimeline-&gt;<span class="built_in">AddInterpFloat</span>(DissolveCurve, DissolveTrack);</span><br><span class="line">		DissolveTimeline-&gt;<span class="built_in">Play</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::MulticastElim_Implementation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bElimmed = <span class="literal">true</span>;</span><br><span class="line">	<span class="built_in">PlayElimMontage</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (DissolveMaterialInstance) &#123;</span><br><span class="line">		DynamicDissolveMaterialInstance = UMaterialInstanceDynamic::<span class="built_in">Create</span>(DissolveMaterialInstance, <span class="keyword">this</span>);</span><br><span class="line">		<span class="built_in">GetMesh</span>()-&gt;<span class="built_in">SetMaterial</span>(<span class="number">0</span>, DynamicDissolveMaterialInstance);</span><br><span class="line">		DynamicDissolveMaterialInstance-&gt;<span class="built_in">SetScalarParameterValue</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Dissolve&quot;</span>), <span class="number">0.55f</span>);</span><br><span class="line">		DynamicDissolveMaterialInstance-&gt;<span class="built_in">SetScalarParameterValue</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Glow&quot;</span>), <span class="number">200.f</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">StartDissolve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当角色淘汰后要丢弃武器，为武器定义丢弃函数。丢弃武器时武器状态会改变，这时要对武器进行一些属性调整。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Weapon.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AWeapon::Dropped</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">SetWeaponState</span>(EWeaponState::EWS_Dropped);</span><br><span class="line">	<span class="function">FDetachmentTransformRules <span class="title">DetachRules</span><span class="params">(EDetachmentRule::KeepWorld, <span class="literal">true</span>)</span></span>;</span><br><span class="line">	WeaponMesh-&gt;<span class="built_in">DetachFromComponent</span>(DetachRules);</span><br><span class="line">	<span class="built_in">SetOwner</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AWeapon::OnRep_WeaponState</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (WeaponState) &#123;</span><br><span class="line">	<span class="keyword">case</span> EWeaponState::EWS_Equipped:</span><br><span class="line">		<span class="built_in">ShowPickWidget</span>(<span class="literal">false</span>);</span><br><span class="line">		AreaSphere-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);</span><br><span class="line">		WeaponMesh-&gt;<span class="built_in">SetSimulatePhysics</span>(<span class="literal">false</span>);</span><br><span class="line">		WeaponMesh-&gt;<span class="built_in">SetEnableGravity</span>(<span class="literal">false</span>);</span><br><span class="line">		WeaponMesh-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> EWeaponState::EWS_Dropped:</span><br><span class="line">		WeaponMesh-&gt;<span class="built_in">SetSimulatePhysics</span>(<span class="literal">true</span>);</span><br><span class="line">		WeaponMesh-&gt;<span class="built_in">SetEnableGravity</span>(<span class="literal">true</span>);</span><br><span class="line">		WeaponMesh-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::QueryAndPhysics);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AWeapon::SetWeaponState</span><span class="params">(EWeaponState State)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	WeaponState = State;</span><br><span class="line">	<span class="keyword">switch</span> (WeaponState) &#123;</span><br><span class="line">	<span class="keyword">case</span> EWeaponState::EWS_Equipped:</span><br><span class="line">		<span class="built_in">ShowPickWidget</span>(<span class="literal">false</span>);</span><br><span class="line">		AreaSphere-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);</span><br><span class="line">		WeaponMesh-&gt;<span class="built_in">SetSimulatePhysics</span>(<span class="literal">false</span>);</span><br><span class="line">		WeaponMesh-&gt;<span class="built_in">SetEnableGravity</span>(<span class="literal">false</span>);</span><br><span class="line">		WeaponMesh-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> EWeaponState::EWS_Dropped:</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">HasAuthority</span>()) &#123;</span><br><span class="line">			AreaSphere-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::QueryOnly);</span><br><span class="line">		&#125;</span><br><span class="line">		WeaponMesh-&gt;<span class="built_in">SetSimulatePhysics</span>(<span class="literal">true</span>);</span><br><span class="line">		WeaponMesh-&gt;<span class="built_in">SetEnableGravity</span>(<span class="literal">true</span>);</span><br><span class="line">		WeaponMesh-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::QueryAndPhysics);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记得拾取武器时也要设一下状态。</p>
<h2 id="4-玩家状态"><a href="#4-玩家状态" class="headerlink" title="4.玩家状态"></a>4.玩家状态</h2><p><strong>玩家状态</strong>是跟踪和记录玩家信息的一个类，存在于每一个客户端中。它不适合用来保存血量、弹药等需要及时同步的变量，而是通常用来保存得分、死亡数等信息。</p>
<p>创建自己的玩家状态类，通过复制来更新和同步分数及分数的HUD。其中Score是玩家状态自带的变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSPlayerState::AddToScore</span><span class="params">(<span class="type">float</span> ScoreAmount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">SetScore</span>(Score + ScoreAmount);</span><br><span class="line">	Character = Character ? Character : <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(<span class="built_in">GetPawn</span>());</span><br><span class="line">	<span class="keyword">if</span> (Character) &#123;</span><br><span class="line">		Controller = Controller ? Controller : <span class="built_in">Cast</span>&lt;AMPTPSPlayerController&gt;(Character-&gt;Controller);</span><br><span class="line">		<span class="keyword">if</span> (Controller) &#123;</span><br><span class="line">			Controller-&gt;<span class="built_in">SetHUDScore</span>(<span class="built_in">GetScore</span>());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSPlayerState::OnRep_Score</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">OnRep_Score</span>();</span><br><span class="line">	Character = Character ? Character : <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(<span class="built_in">GetPawn</span>());</span><br><span class="line">	<span class="keyword">if</span> (Character) &#123;</span><br><span class="line">		Controller = Controller ? Controller : <span class="built_in">Cast</span>&lt;AMPTPSPlayerController&gt;(Character-&gt;Controller);</span><br><span class="line">		<span class="keyword">if</span> (Controller) &#123;</span><br><span class="line">			Controller-&gt;<span class="built_in">SetHUDScore</span>(<span class="built_in">GetScore</span>());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MPTPSPlayerController.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::SetHUDScore</span><span class="params">(<span class="type">float</span> Score)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MultiplayerTPSHUD = MultiplayerTPSHUD == <span class="literal">nullptr</span> ? <span class="built_in">Cast</span>&lt;AMultiplayerTPSHUD&gt;(<span class="built_in">GetHUD</span>()) : MultiplayerTPSHUD;</span><br><span class="line">	<span class="keyword">if</span> (MultiplayerTPSHUD &amp;&amp; MultiplayerTPSHUD-&gt;CharacterOverlay &amp;&amp; MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;ScoreAmount) &#123;</span><br><span class="line">		FString ScoreText = FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;%d&quot;</span>), FMath::<span class="built_in">FloorToInt</span>(Score));</span><br><span class="line">		MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;ScoreAmount-&gt;<span class="built_in">SetText</span>(FText::<span class="built_in">FromString</span>(ScoreText));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>游戏开始时我们要将Score设为0，但是在角色的<code>BeginPlay</code>运行时，游戏状态可能还未初始化导致我们无法访问并对其进行操作，所以定义了一个轮询函数在Tick中调用来初始化游戏状态：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::PollInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!MultiplayerTPSPlayerState) &#123;</span><br><span class="line">		MultiplayerTPSPlayerState = <span class="built_in">GetPlayerState</span>&lt;AMultiplayerTPSPlayerState&gt;();</span><br><span class="line">		<span class="keyword">if</span> (MultiplayerTPSPlayerState) &#123;</span><br><span class="line">			MultiplayerTPSPlayerState-&gt;<span class="built_in">AddToScore</span>(<span class="number">0.f</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是淘汰数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSPlayerState.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(ReplicatedUsing = OnRep_Defeats)</span><br><span class="line">int32 Defeats;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnRep_Defeats</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSPlayerState::GetLifetimeReplicatedProps</span><span class="params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">GetLifetimeReplicatedProps</span>(OutLifetimeProps);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">DOREPLIFETIME</span>(AMultiplayerTPSPlayerState, Defeats);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSPlayerState::AddToDefeats</span><span class="params">(int32 DefeatsAmount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Defeats += DefeatsAmount;</span><br><span class="line">	Character = Character ? Character : <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(<span class="built_in">GetPawn</span>());</span><br><span class="line">	<span class="keyword">if</span> (Character) &#123;</span><br><span class="line">		Controller = Controller ? Controller : <span class="built_in">Cast</span>&lt;AMPTPSPlayerController&gt;(Character-&gt;Controller);</span><br><span class="line">		<span class="keyword">if</span> (Controller) &#123;</span><br><span class="line">			Controller-&gt;<span class="built_in">SetHUDDefeats</span>(Defeats);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSPlayerState::OnRep_Defeats</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Character = Character ? Character : <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(<span class="built_in">GetPawn</span>());</span><br><span class="line">	<span class="keyword">if</span> (Character) &#123;</span><br><span class="line">		Controller = Controller ? Controller : <span class="built_in">Cast</span>&lt;AMPTPSPlayerController&gt;(Character-&gt;Controller);</span><br><span class="line">		<span class="keyword">if</span> (Controller) &#123;</span><br><span class="line">			Controller-&gt;<span class="built_in">SetHUDDefeats</span>(Defeats);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制器中的HUD更新函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::SetHUDDefeats</span><span class="params">(int32 Defeats)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MultiplayerTPSHUD = MultiplayerTPSHUD == <span class="literal">nullptr</span> ? <span class="built_in">Cast</span>&lt;AMultiplayerTPSHUD&gt;(<span class="built_in">GetHUD</span>()) : MultiplayerTPSHUD;</span><br><span class="line">	<span class="keyword">if</span> (MultiplayerTPSHUD &amp;&amp; MultiplayerTPSHUD-&gt;CharacterOverlay &amp;&amp; MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;DefeatsAmount) &#123;</span><br><span class="line">		FString DefeatsText = FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;%d&quot;</span>), Defeats);</span><br><span class="line">		MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;DefeatsAmount-&gt;<span class="built_in">SetText</span>(FText::<span class="built_in">FromString</span>(DefeatsText));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在游戏模式中，当玩家被淘汰时，攻击者的得分+1，受害者的失败数+1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSGameMode::PlayerEliminated</span><span class="params">(AMultiplayerTPSCharacter* ElimmedCharacter, AMPTPSPlayerController* VictimController, AMPTPSPlayerController* AttackerController)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	AMultiplayerTPSPlayerState* AttackerPlayerState = AttackerController ? <span class="built_in">Cast</span>&lt;AMultiplayerTPSPlayerState&gt;(AttackerController-&gt;PlayerState) : <span class="literal">nullptr</span>;</span><br><span class="line">	AMultiplayerTPSPlayerState* VictimPlayerState = VictimController ? <span class="built_in">Cast</span>&lt;AMultiplayerTPSPlayerState&gt;(VictimController-&gt;PlayerState) : <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (AttackerPlayerState &amp;&amp; AttackerPlayerState != VictimPlayerState) &#123;</span><br><span class="line">		AttackerPlayerState-&gt;<span class="built_in">AddToScore</span>(<span class="number">1.f</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (VictimController) &#123;</span><br><span class="line">		VictimPlayerState-&gt;<span class="built_in">AddToDefeats</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ElimmedCharacter)</span><br><span class="line">	&#123;</span><br><span class="line">		ElimmedCharacter-&gt;<span class="built_in">Elim</span>();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-玩家携带弹药"><a href="#5-玩家携带弹药" class="headerlink" title="5.玩家携带弹药"></a>5.玩家携带弹药</h2><p>声明一个表示武器类型的枚举（之后会有更多类型）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UENUM</span>(BlueprintType)</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">EWeaponType</span> :uint8 &#123;</span><br><span class="line">	<span class="function">EWT_AssaultRifle <span class="title">UMETA</span><span class="params">(Displayname=<span class="string">&quot;Assult Rifle&quot;</span>)</span>,</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	EWT_MAX <span class="title">UMETA</span><span class="params">(Displayname = <span class="string">&quot;DefaultMAX&quot;</span>)</span></span></span><br><span class="line"><span class="function">&#125;</span>;</span><br></pre></td></tr></table></figure>
<p>之前我们用一个整型来表示玩家的携带弹药，而现在有多种武器类型，也就需要多种携带弹药。</p>
<p>然而并不需要为每一种武器类型都创建一个变量。我们可以使用一个<code>TMap</code>来保存所有武器类型对应的携带弹药。<code>TMap</code>的底层实现是哈希表，由于在每台机器上的哈希结果不一定相同，因此<code>TMap</code>是不能复制的。不过我们也不需要对其进行复制，因为备弹的相关处理逻辑都是在服务器上进行的，只需要同步好<code>CarriedAmmo</code>就行了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(ReplicatedUsing = OnRep_CarriedAmmo)</span><br><span class="line">int32 CarriedAmmo;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnRep_CarriedAmmo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">TMap&lt;EWeaponType, int32&gt; CarriedAmmoMap;</span><br></pre></td></tr></table></figure>
<p>在战斗组件中为每一种武器初始化备弹，装备武器时将备弹显示设为装备的武器类型的备弹。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Weapon.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">EWeaponType WeaponType;</span><br><span class="line"></span><br><span class="line"><span class="function">FORCEINLINE EWeaponType <span class="title">GetWeaponType</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> WeaponType; &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CombatComponent.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::InitializeCarriedAmmo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CarriedAmmoMap.<span class="built_in">Emplace</span>(EWeaponType::EWT_AssaultRifle, StartingARAmmo);</span><br><span class="line">    <span class="comment">//...更多武器类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::EquipWeapon</span><span class="params">(AWeapon* WeaponToEquip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (CarriedAmmoMap.<span class="built_in">Contains</span>(EquippedWeapon-&gt;<span class="built_in">GetWeaponType</span>())) &#123;</span><br><span class="line">		CarriedAmmo = CarriedAmmoMap[EquippedWeapon-&gt;<span class="built_in">GetWeaponType</span>()];</span><br><span class="line">	&#125;</span><br><span class="line">	Controller = Controller ? Controller : <span class="built_in">Cast</span>&lt;AMPTPSPlayerController&gt;(Character-&gt;Controller);</span><br><span class="line">	<span class="keyword">if</span> (Controller) &#123;</span><br><span class="line">		Controller-&gt;<span class="built_in">SetHUDCarriedAmmo</span>(CarriedAmmo);</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-换弹"><a href="#6-换弹" class="headerlink" title="6.换弹"></a>6.换弹</h2><p>声明一个枚举来表示玩家当前的角色状态：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UENUM</span>(BlueprintType)</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">ECombatState</span> :uint8 &#123;</span><br><span class="line">	<span class="function">ECS_Unoccupied <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Unoccupied&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">	ECS_Reloading <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Reloading&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">	ECS_MAX <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;DefaultMAX&quot;</span>)</span></span></span><br><span class="line"><span class="function">&#125;</span>;</span><br></pre></td></tr></table></figure>
<p>按下Reload键后触发回调函数，调用战斗组件中的换弹函数，只有战斗状态为<code>Unoccupied</code>时才能换弹。换弹只能在服务器上进行，所以调用换弹后要调用<code>Server RPC</code>。服务器上实现真正的换弹逻辑。这样就完成了服务器上的换弹逻辑，之后需要进行同步。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CombatComponent.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::Reload</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (CarriedAmmo &gt; <span class="number">0</span> &amp;&amp; CombatState == ECombatState::ECS_Unoccupied) &#123;</span><br><span class="line">		<span class="built_in">ServerReload</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::ServerReload_Implementation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!Character) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	CombatState = ECombatState::ECS_Reloading;</span><br><span class="line">	<span class="built_in">HandleReload</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>角色根据武器类型跳转到动画蒙太奇的对应片段。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSCharacter.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::PlayReloadMontage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!Combat || !Combat-&gt;EquippedWeapon) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	UAnimInstance* AnimInstance = <span class="built_in">GetMesh</span>()-&gt;<span class="built_in">GetAnimInstance</span>();</span><br><span class="line">	<span class="keyword">if</span> (AnimInstance &amp;&amp; ReloadMontage) &#123;</span><br><span class="line">		AnimInstance-&gt;<span class="built_in">Montage_Play</span>(ReloadMontage);</span><br><span class="line">		FName SectionName;</span><br><span class="line">		<span class="keyword">switch</span> (Combat-&gt;EquippedWeapon-&gt;<span class="built_in">GetWeaponType</span>()) &#123;</span><br><span class="line">		<span class="keyword">case</span> EWeaponType::EWT_AssaultRifle:</span><br><span class="line">			SectionName = <span class="built_in">FName</span>(<span class="string">&quot;Rifle&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		AnimInstance-&gt;<span class="built_in">Montage_JumpToSection</span>(SectionName);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>战斗组件中持有当前状态，设为复制，回调函数中根据战斗状态进行同步操作，如当战斗状态变为<code>Reloading</code>时播放换弹动画：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CombatComponent.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(ReplicatedUsing = OnRep_CombatState)</span><br><span class="line">ECombatState CombatState = ECombatState::ECS_Unoccupied;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnRep_CombatState</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CombatComponent.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::OnRep_CombatState</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (CombatState)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> ECombatState::ECS_Unoccupied:</span><br><span class="line">		<span class="keyword">if</span> (bFireButtonPressed) &#123;</span><br><span class="line">			<span class="built_in">Fire</span>();</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> ECombatState::ECS_Reloading:</span><br><span class="line">		<span class="built_in">HandleReload</span>();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> ECombatState::ECS_MAX:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在换弹的动画蒙太奇结尾加一个通知，调用结束换弹的函数；当可以开火时如果按着开火键，我们希望玩家能立刻开火，所以在换弹结束和战斗状态变为空闲时，如果开火键被按下就开火：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::FinishReloading</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CombatState = ECombatState::ECS_Unoccupied;</span><br><span class="line">	<span class="keyword">if</span> (bFireButtonPressed) &#123;</span><br><span class="line">		<span class="built_in">Fire</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当换弹的时候不能开火，在判断开火条件时加上：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UCombatComponent::CanFire</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!EquippedWeapon) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> !EquippedWeapon-&gt;<span class="built_in">IsEmpty</span>() &amp;&amp; bCanFire &amp;&amp; CombatState == ECombatState::ECS_Unoccupied;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就是真正的换弹逻辑了。在战斗组件中定义计算要上多少子弹的函数，当触发结束换弹动画通知的时候执行弹药的更新逻辑。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CombatComponent.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::FinishReloading</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!Character) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (Character-&gt;<span class="built_in">HasAuthority</span>()) &#123;</span><br><span class="line">		CombatState = ECombatState::ECS_Unoccupied;</span><br><span class="line">		<span class="built_in">UpdateAmmoValues</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (bFireButtonPressed) &#123;</span><br><span class="line">		<span class="built_in">Fire</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">int32 <span class="title">UCombatComponent::AmountToReload</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!EquippedWeapon) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	int32 RoomInMag = EquippedWeapon-&gt;<span class="built_in">GetMagCapacity</span>() - EquippedWeapon-&gt;<span class="built_in">GetAmmo</span>();</span><br><span class="line">	<span class="keyword">if</span> (CarriedAmmoMap.<span class="built_in">Contains</span>(EquippedWeapon-&gt;<span class="built_in">GetWeaponType</span>())) &#123;</span><br><span class="line">		int32 AmountCarried = CarriedAmmoMap[EquippedWeapon-&gt;<span class="built_in">GetWeaponType</span>()];</span><br><span class="line">		int32 Least = FMath::<span class="built_in">Min</span>(RoomInMag, AmountCarried);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> FMath::<span class="built_in">Clamp</span>(RoomInMag, <span class="number">0</span>, Least);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::UpdateAmmoValues</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!EquippedWeapon) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	int32 ReloadAmount = <span class="built_in">AmountToReload</span>();</span><br><span class="line">	<span class="keyword">if</span> (CarriedAmmoMap.<span class="built_in">Contains</span>(EquippedWeapon-&gt;<span class="built_in">GetWeaponType</span>())) &#123;</span><br><span class="line">		CarriedAmmoMap[EquippedWeapon-&gt;<span class="built_in">GetWeaponType</span>()] -= ReloadAmount;</span><br><span class="line">		CarriedAmmo = CarriedAmmoMap[EquippedWeapon-&gt;<span class="built_in">GetWeaponType</span>()];</span><br><span class="line">	&#125;</span><br><span class="line">	Controller = Controller ? Controller : <span class="built_in">Cast</span>&lt;AMPTPSPlayerController&gt;(Character-&gt;Controller);</span><br><span class="line">	<span class="keyword">if</span> (Controller) &#123;</span><br><span class="line">		Controller-&gt;<span class="built_in">SetHUDCarriedAmmo</span>(CarriedAmmo);</span><br><span class="line">	&#125;</span><br><span class="line">	EquippedWeapon-&gt;<span class="built_in">AddAmmo</span>(ReloadAmount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Weapon.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AWeapon::AddAmmo</span><span class="params">(int32 AmmoToAdd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Ammo = FMath::<span class="built_in">Clamp</span>(Ammo + AmmoToAdd, <span class="number">0</span>, MagCapacity);</span><br><span class="line">	<span class="built_in">SetHUDAmmo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-游戏时间与服务器计时"><a href="#7-游戏时间与服务器计时" class="headerlink" title="7.游戏时间与服务器计时"></a>7.游戏时间与服务器计时</h2><p>一局游戏是有一个时间的。对于服务器，只要获取游戏时间就行了，但是对于客户端，有可能存在中途加入游戏、加载时间过长等情况，因此不能直接使用本地的游戏时间，而是要获取服务器的游戏时间。然而，和服务器进行通信也需要时间，如果直接从服务器获取游戏时间仍然存在滞后。所有这里要进行一些小计算。</p>
<p>先放一下设置游戏倒计时的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::SetHUDMatchCountdown</span><span class="params">(<span class="type">float</span> CountdownTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MultiplayerTPSHUD = MultiplayerTPSHUD == <span class="literal">nullptr</span> ? <span class="built_in">Cast</span>&lt;AMultiplayerTPSHUD&gt;(<span class="built_in">GetHUD</span>()) : MultiplayerTPSHUD;</span><br><span class="line">	<span class="keyword">if</span> (MultiplayerTPSHUD &amp;&amp; MultiplayerTPSHUD-&gt;CharacterOverlay &amp;&amp; MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;MatchCountdownText) &#123;</span><br><span class="line">		int32 Minutes = FMath::<span class="built_in">FloorToInt</span>(CountdownTime / <span class="number">60.f</span>);</span><br><span class="line">		int32 Seconds = CountdownTime - Minutes * <span class="number">60</span>;</span><br><span class="line">		FString CountdowmText = FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;%02d:%02d&quot;</span>), Minutes, Seconds);</span><br><span class="line">		MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;MatchCountdownText-&gt;<span class="built_in">SetText</span>(FText::<span class="built_in">FromString</span>(CountdowmText));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>RTT(Round-Trip Time)</code></strong>是我们耳熟能详的概念，表示两台计算机进行网络通信时信息传输所花费的时间。当客户端获取到了服务器的游戏时间，只要再加上RTT，不就是客户端当前的游戏时间吗。</p>
<p>这里使用了一个<code>Server RPC</code>和一个<code>Client RPC</code>。当客户端请求服务器的游戏时间时，调用<code>Server RPC</code>，发送自己发送请求的时间；服务器在执行<code>Server RPC</code>时调用<code>Client RPC</code>，将客户端的请求时间和服务器的游戏时间一起发送给客户端。这样，客户端通过将本地时间减去自己发送请求的时间，就得到了<code>RTT</code>。需要注意，<code>RTT</code>是从自己发送请求到服务器，到服务器的回复送达客户端的时间，而这里得到了服务器的游戏时间，只要加上服务器的回复发送到客户端时间就行了。双向通信的时间不一定是对称的，但是这里近似为对称的。将服务器的游戏时间加上一半的<code>RTT</code>，就得到了比较准确的客户端本地游戏时间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::ServerRequestServerTime_Implementation</span><span class="params">(<span class="type">float</span> TimeOfClientRequest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">float</span> ServerTimeOfReceipt = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetTimeSeconds</span>();</span><br><span class="line">	<span class="built_in">ClientReportServerTime</span>(TimeOfClientRequest, ServerTimeOfReceipt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::ClientReportServerTime_Implementation</span><span class="params">(<span class="type">float</span> TimeOfClientRequest, <span class="type">float</span> TimeServerReveivedClientRequest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">float</span> RoundTripTime = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetTimeSeconds</span>() - TimeOfClientRequest;</span><br><span class="line">	<span class="type">float</span> CurrentServerTime = TimeServerReveivedClientRequest + (<span class="number">0.5f</span> * RoundTripTime);</span><br><span class="line">	ClientServerDelta = CurrentServerTime - <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetTimeSeconds</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">AMPTPSPlayerController::GetServerTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">HasAuthority</span>()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetTimeSeconds</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetTimeSeconds</span>() + ClientServerDelta;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每隔一段时间就同步一次游戏时间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求当前服务器时间，发送客户端发送请求的时间</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(Server, Reliable)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ServerRequestServerTime</span><span class="params">(<span class="type">float</span> TimeOfClientRequest)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回应客户端请求，向客户端报告当前服务器时间</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(Client, Reliable)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClientReportServerTime</span><span class="params">(<span class="type">float</span> TimeOfClientRequest, <span class="type">float</span> TimeServerReveivedClientRequest)</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> ClientServerDelta = <span class="number">0.f</span>; <span class="comment">//客户端和服务器之间的时间差</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, Category = <span class="string">&quot;Time&quot;</span>)</span><br><span class="line"><span class="type">float</span> TimeSyncFrequency = <span class="number">5.f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> TimeSyncRunningTime = <span class="number">0.f</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CheckTimeSync</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">Tick</span>(DeltaTime);</span><br><span class="line">	<span class="built_in">SetHUDTime</span>();</span><br><span class="line">	<span class="built_in">CheckTimeSync</span>(DeltaTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::CheckTimeSync</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TimeSyncRunningTime += DeltaTime;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsLocalController</span>() &amp;&amp; TimeSyncRunningTime &gt; TimeSyncFrequency) &#123;</span><br><span class="line">		<span class="built_in">ServerRequestServerTime</span>(<span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetTimeSeconds</span>());</span><br><span class="line">		TimeSyncRunningTime = <span class="number">0.f</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::SetHUDTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	uint32 SecondLeft = FMath::<span class="built_in">CeilToInt</span>(MatchTime - <span class="built_in">GetServerTime</span>());</span><br><span class="line">	<span class="keyword">if</span> (CountdownInt != SecondLeft) &#123;</span><br><span class="line">		<span class="built_in">SetHUDMatchCountdown</span>(MatchTime - <span class="built_in">GetServerTime</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	CountdownInt = SecondLeft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-比赛状态"><a href="#8-比赛状态" class="headerlink" title="8.比赛状态"></a>8.比赛状态</h2><p>在<code>GameMode</code>类中除了继承了<code>GameModeBase</code>类中的基础功能，还实现了<code>MatchState</code>的相关功能实现。简单来说，我们可以使用<code>GameMode</code>类提供的游戏状态和我们自己定义的比赛状态来控制和管理游戏的不同阶段，以及转换阶段时的操作。</p>
<p>从最简单的开始。当进入游戏后，我不希望直接开始游戏，而是有一个热身阶段，热身结束后正式开始比赛，并进入<code>InProgress</code>的比赛状态。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">AMultiplayerTPSGameMode::<span class="built_in">AMultiplayerTPSGameMode</span>()</span><br><span class="line">&#123;</span><br><span class="line">	bDelayedStart = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSGameMode::Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">Tick</span>(DeltaTime);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (MatchState == MatchState::WaitingToStart) &#123;</span><br><span class="line">		CountdownTime = WarmupTime - <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetTimeSeconds</span>() + LevelStartingTime;</span><br><span class="line">		<span class="keyword">if</span> (CountdownTime &lt;= <span class="number">0.f</span>) &#123;</span><br><span class="line">			<span class="built_in">StartMatch</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSGameMode::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">	LevelStartingTime = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetTimeSeconds</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当比赛状态改变时会调用<code>OnMatchStateSet</code>函数，可以在里面设置控制器的比赛状态变量，并由此进行相关的操作。例如，当比赛状态变成<code>InProgress</code>时，就开始显示<code>HUD</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSGameMode::OnMatchStateSet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">OnMatchStateSet</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (FConstPlayerControllerIterator It = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetPlayerControllerIterator</span>();It;++It) &#123;</span><br><span class="line">		AMPTPSPlayerController* MultiplayerTPSPlayer = <span class="built_in">Cast</span>&lt;AMPTPSPlayerController&gt;(*It);</span><br><span class="line">		<span class="keyword">if</span> (MultiplayerTPSPlayer) &#123;</span><br><span class="line">			MultiplayerTPSPlayer-&gt;<span class="built_in">OnMatchStateSet</span>(MatchState);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::OnRep_MatchState</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (MatchState == MatchState::InProgress) &#123;</span><br><span class="line">		MultiplayerTPSHUD = MultiplayerTPSHUD == <span class="literal">nullptr</span> ? <span class="built_in">Cast</span>&lt;AMultiplayerTPSHUD&gt;(<span class="built_in">GetHUD</span>()) : MultiplayerTPSHUD;</span><br><span class="line">		<span class="keyword">if</span> (MultiplayerTPSHUD) &#123;</span><br><span class="line">			MultiplayerTPSHUD-&gt;<span class="built_in">AddCharacterOverlay</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存在一个问题。之前当HUD创建后在<code>BeginPlay</code>中就创建Overlay，此时控制器可以直接在游戏刚开始时设置相关的属性。但是现在有了一个等待时间，Overlay还没有创建出来，导致控制器无法准确初始化数值。解决方法是如果设置Overlay时Overlay还没有创建，就用变量将这些值保存下来，在Tick中轮询Overlay，如果发现Overlay创建好了，就用之前保存的值来初始化Overlay。之后如果有新的变量需要设置，就不再重复了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MPTPSPlayerCharacter.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::SetHUDHealth</span><span class="params">(<span class="type">float</span> Health, <span class="type">float</span> MaxHealth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MultiplayerTPSHUD = MultiplayerTPSHUD == <span class="literal">nullptr</span> ? <span class="built_in">Cast</span>&lt;AMultiplayerTPSHUD&gt;(<span class="built_in">GetHUD</span>()) : MultiplayerTPSHUD;</span><br><span class="line">	<span class="keyword">if</span> (MultiplayerTPSHUD &amp;&amp; MultiplayerTPSHUD-&gt;CharacterOverlay &amp;&amp; MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HealthBar &amp;&amp; MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HealthText) &#123;</span><br><span class="line">		<span class="type">const</span> <span class="type">float</span> HealthPercent = Health / MaxHealth;</span><br><span class="line">		MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HealthBar-&gt;<span class="built_in">SetPercent</span>(HealthPercent);</span><br><span class="line">		FString HealthText = FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;%d/%d&quot;</span>), FMath::<span class="built_in">CeilToInt</span>(Health), FMath::<span class="built_in">CeilToInt</span>(MaxHealth));</span><br><span class="line">		MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HealthText-&gt;<span class="built_in">SetText</span>(FText::<span class="built_in">FromString</span>(HealthText));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		bInitializerCharacterOverlay = <span class="literal">true</span>;</span><br><span class="line">		HUDHealth = Health;</span><br><span class="line">		HUDMaxHealth = MaxHealth;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">Tick</span>(DeltaTime);</span><br><span class="line">	<span class="built_in">SetHUDTime</span>();</span><br><span class="line">	<span class="built_in">CheckTimeSync</span>(DeltaTime);</span><br><span class="line">	<span class="built_in">PollInit</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::PollInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!CharacterOverlay) &#123;</span><br><span class="line">		<span class="keyword">if</span> (MultiplayerTPSHUD &amp;&amp; MultiplayerTPSHUD-&gt;CharacterOverlay) &#123;</span><br><span class="line">			CharacterOverlay = MultiplayerTPSHUD-&gt;CharacterOverlay;</span><br><span class="line">			<span class="keyword">if</span> (CharacterOverlay) &#123;</span><br><span class="line">				<span class="built_in">SetHUDHealth</span>(HUDHealth, HUDMaxHealth);</span><br><span class="line">				<span class="built_in">SetHUDScore</span>(HUDScore);</span><br><span class="line">				<span class="built_in">SetHUDDefeats</span>(HUDDefeats);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是自定义的比赛状态。比赛状态是定义在一个命名空间中的，可以直接在这个命名空间中定义自己的比赛状态。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> MatchState</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">extern</span> MULTIPLAYERTPS_API <span class="type">const</span> FName Cooldown; <span class="comment">//比赛持续时间结束，显示胜者并开始冷却计时</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MatchState &#123;</span><br><span class="line">	<span class="type">const</span> FName Cooldown = <span class="built_in">FName</span>(<span class="string">&quot;Cooldown&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制器中新增了对加入Cooldown状态的处理： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::OnRep_MatchState</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (MatchState == MatchState::InProgress) &#123;</span><br><span class="line">		<span class="built_in">HandleMatchHasStarted</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (MatchState == MatchState::Cooldown) &#123;</span><br><span class="line">		<span class="built_in">HandleCooldown</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::HandleCooldown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MultiplayerTPSHUD = MultiplayerTPSHUD == <span class="literal">nullptr</span> ? <span class="built_in">Cast</span>&lt;AMultiplayerTPSHUD&gt;(<span class="built_in">GetHUD</span>()) : MultiplayerTPSHUD;</span><br><span class="line">	<span class="keyword">if</span> (MultiplayerTPSHUD) &#123;</span><br><span class="line">		MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;<span class="built_in">RemoveFromParent</span>();</span><br><span class="line">		<span class="keyword">if</span> (MultiplayerTPSHUD-&gt;Announcement) &#123;</span><br><span class="line">			MultiplayerTPSHUD-&gt;Announcement-&gt;<span class="built_in">SetVisibility</span>(ESlateVisibility::Visible);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-各种武器"><a href="#9-各种武器" class="headerlink" title="9.各种武器"></a>9.各种武器</h2><p>目前已经完成了射击游戏的大部分核心内容，包括完善的开火、换弹等逻辑，以及<strong>武器和弹药基类</strong>。要实现多种多样的武器，只需要在之前的基础上添加各种武器特有的功能就行了。这就是精心设计基类的好处啊。</p>
<p>之前已经设计好了武器类，及其两个派生类：<strong><code>ProjectileWeapon</code>（弹道武器）和<code>HitscanWeapon</code>（即时命中武器）</strong>。弹道武器的设计主要集中在投射物上，而即时命中武器的设计则集中于武器本身。</p>
<p><em>注意，对于每一种新武器，都要添加对应的武器类型以及初始弹药。</em></p>
<h3 id="9-1-火箭发射器（天降正义！）"><a href="#9-1-火箭发射器（天降正义！）" class="headerlink" title="9.1 火箭发射器（天降正义！）"></a>9.1 火箭发射器（天降正义！）</h3><p>和上面说的一样，火箭发射器和突击步枪没什么本质区别，区别只是发射的子弹不同罢了。从<code>Projectile</code>类派生<code>ProjectileRocket</code>类。</p>
<p>仔细思考，火箭弹和子弹有什么区别？首先<strong>命中时不是直接对命中的角色造成伤害，而是造成范围伤害</strong>；其次火箭弹的飞行速度较慢，因此必须要有<strong>自己的网格体</strong>；最后，火箭弹在飞行时会有<strong>逐渐消散的烟雾尾迹，以及飞行音效</strong>，不能和子弹一样直接绑定一个尾迹。</p>
<p>至于其它部分，如命中音效、特效等，就和基类没什么区别了，直接在编辑器中指定即可。</p>
<p>知道了火箭弹独有的特性，接下来去实现就可以了。网格体和范围伤害没什么好说的，对于尾迹，这里使用了<code>Niagara</code>系统，而随之而来的一个问题是，<code>Niagara</code>系统组件是绑定在火箭弹上的，<strong>如果火箭弹发射碰撞后直接被摧毁，那么<code>Niagara</code>系统组件也会被摧毁，导致尾迹直接全部消失</strong>。这里的解决方法是发生碰撞后不直接摧毁火箭弹，而是将其隐藏并关闭碰撞，并启动计时器，当计时器结束时尾迹已经消失了，这时候再摧毁火箭弹就没问题了。相应的，<code>Projectile</code>类中音效、特性和伤害等逻辑无论时在<code>OnHit</code>中触发还是在<code>Destroyed</code>中触发都没问题，而在火箭弹中必须在<code>OnHit</code>中触发。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ProjectileRocket.cpp</span></span><br><span class="line">AProjectileRocket::<span class="built_in">AProjectileRocket</span>()</span><br><span class="line">&#123;</span><br><span class="line">	RocketMesh = <span class="built_in">CreateDefaultSubobject</span>&lt;UStaticMeshComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;Rocket Mesh&quot;</span>));</span><br><span class="line">	RocketMesh-&gt;<span class="built_in">SetupAttachment</span>(RootComponent);</span><br><span class="line">	RocketMesh-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AProjectileRocket::OnHit</span><span class="params">(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, <span class="type">const</span> FHitResult&amp; Hit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	APawn* FiringPawn = <span class="built_in">GetInstigator</span>();</span><br><span class="line">	<span class="keyword">if</span> (FiringPawn &amp;&amp; <span class="built_in">HasAuthority</span>()) &#123;</span><br><span class="line">		AController* FiringController = FiringPawn-&gt;<span class="built_in">GetController</span>();</span><br><span class="line">		<span class="keyword">if</span> (FiringController) &#123;</span><br><span class="line">				<span class="comment">//添加径向伤害</span></span><br><span class="line">            	UGameplayStatics::<span class="built_in">ApplyRadialDamageWithFalloff</span>(</span><br><span class="line">					<span class="keyword">this</span>, <span class="comment">//世界上下文对象</span></span><br><span class="line">					Damage, <span class="comment">//基础伤害</span></span><br><span class="line">					<span class="number">10.f</span>, <span class="comment">//最低伤害</span></span><br><span class="line">					<span class="built_in">GetActorLocation</span>(), <span class="comment">//原点</span></span><br><span class="line">					<span class="number">200.f</span>, <span class="comment">//内圈半径</span></span><br><span class="line">					<span class="number">500.f</span>, <span class="comment">//外圈半径</span></span><br><span class="line">					<span class="number">1.f</span>, <span class="comment">//伤害衰减</span></span><br><span class="line">					UDamageType::<span class="built_in">StaticClass</span>(), <span class="comment">//伤害类</span></span><br><span class="line">					<span class="built_in">TArray</span>&lt;AActor*&gt;(), <span class="comment">//忽略的Actor</span></span><br><span class="line">					<span class="keyword">this</span>, <span class="comment">//造成伤害的Actor</span></span><br><span class="line">					FiringController <span class="comment">//发起者控制器</span></span><br><span class="line">				);</span><br><span class="line">			);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">GetWorldTimerManager</span>().<span class="built_in">SetTimer</span>(</span><br><span class="line">		DestroyTimer,</span><br><span class="line">		<span class="keyword">this</span>,</span><br><span class="line">		&amp;AProjectileRocket::DestroyTimerFinished,</span><br><span class="line">		DestroyTime</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ImpactParticles) &#123;</span><br><span class="line">		UGameplayStatics::<span class="built_in">SpawnEmitterAtLocation</span>(<span class="built_in">GetWorld</span>(), ImpactParticles, <span class="built_in">GetActorTransform</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ImpactSound) &#123;</span><br><span class="line">		UGameplayStatics::<span class="built_in">PlaySoundAtLocation</span>(<span class="keyword">this</span>, ImpactSound, <span class="built_in">GetActorLocation</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (RocketMesh) &#123;</span><br><span class="line">		RocketMesh-&gt;<span class="built_in">SetVisibility</span>(<span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (CollisionBox) &#123;</span><br><span class="line">		CollisionBox-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (TrailSystemComponent &amp;&amp; TrailSystemComponent-&gt;<span class="built_in">GetSystemInstance</span>()) &#123;</span><br><span class="line">		TrailSystemComponent-&gt;<span class="built_in">GetSystemInstance</span>()-&gt;<span class="built_in">Deactivate</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ProjectileLoopComponent &amp;&amp; ProjectileLoopComponent-&gt;<span class="built_in">IsPlaying</span>()) &#123;</span><br><span class="line">		ProjectileLoopComponent-&gt;<span class="built_in">Stop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AProjectileRocket::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">HasAuthority</span>()) &#123;</span><br><span class="line">		CollisionBox-&gt;OnComponentHit.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;ThisClass::OnHit);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (TrailSystem) &#123;</span><br><span class="line">		TrailSystemComponent = UNiagaraFunctionLibrary::<span class="built_in">SpawnSystemAttached</span>(</span><br><span class="line">			TrailSystem,</span><br><span class="line">			<span class="built_in">GetRootComponent</span>(),</span><br><span class="line">			<span class="built_in">FName</span>(),</span><br><span class="line">			<span class="built_in">GetActorLocation</span>(),</span><br><span class="line">			<span class="built_in">GetActorRotation</span>(),</span><br><span class="line">			EAttachLocation::KeepWorldPosition,</span><br><span class="line">			<span class="literal">false</span></span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ProjectileLoop &amp;&amp; LoopingSoundAttenuation) &#123;</span><br><span class="line">		ProjectileLoopComponent = UGameplayStatics::<span class="built_in">SpawnSoundAttached</span>(</span><br><span class="line">			ProjectileLoop,</span><br><span class="line">			<span class="built_in">GetRootComponent</span>(),</span><br><span class="line">			<span class="built_in">FName</span>(),</span><br><span class="line">			<span class="built_in">GetActorLocation</span>(),</span><br><span class="line">			EAttachLocation::KeepWorldPosition,</span><br><span class="line">			<span class="literal">false</span>,</span><br><span class="line">			<span class="number">1.f</span>,</span><br><span class="line">			<span class="number">1.f</span>,</span><br><span class="line">			<span class="number">0.f</span>,</span><br><span class="line">			LoopingSoundAttenuation,</span><br><span class="line">			(USoundConcurrency*)<span class="literal">nullptr</span>,</span><br><span class="line">			<span class="literal">false</span></span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AProjectileRocket::DestroyTimerFinished</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Destroy</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个小问题时，火箭弹的飞行速度较慢，而其生成位置是火箭发射器的枪口<code>Socket</code>，如果角色一边前进一边发射，可能会直接原地爆炸。当然最简单的方式就是将生成点向前移，但是总觉得这种妥协的做法有点不爽。</p>
<p>如果简单地在碰撞时判断碰撞对象是发射者就直接返回，确实不会触发爆炸，但是火箭弹会在原地停止不动。这是因为<strong>投射物运动组件的默认逻辑时发生碰撞后立即停止投射物的运动，但是事实上根本不需要这个逻辑</strong>。既然如此，那么重写投射物运动组件的碰撞逻辑就行了。</p>
<p>创建自己的<code>RocketMovementComponent</code>类，派生自<code>ProjectileMovementComponent</code>类。重写两个核心函数，当发生碰撞时返回<code>AdvanceNextSubstep</code>，并且讲碰撞事件置空。这样就可以完全通过火箭弹自己处理碰撞的相关逻辑了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RocketMovementComponent.cpp</span></span><br><span class="line"><span class="function">URocketMovementComponent::EHandleBlockingHitResult <span class="title">URocketMovementComponent::HandleBlockingHit</span><span class="params">(<span class="type">const</span> FHitResult&amp; Hit, <span class="type">float</span> TimeTick, <span class="type">const</span> FVector&amp; MoveDelta, <span class="type">float</span>&amp; SubTickTimeRemaining)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">HandleBlockingHit</span>(Hit, TimeTick, MoveDelta, SubTickTimeRemaining);</span><br><span class="line">	<span class="keyword">return</span> EHandleBlockingHitResult::AdvanceNextSubstep;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">URocketMovementComponent::HandleImpact</span><span class="params">(<span class="type">const</span> FHitResult&amp; Hit, <span class="type">float</span> TimeSlice, <span class="type">const</span> FVector&amp; MoveDelta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-2-冲锋枪（脉冲炸弹！）"><a href="#9-2-冲锋枪（脉冲炸弹！）" class="headerlink" title="9.2 冲锋枪（脉冲炸弹！）"></a>9.2 冲锋枪（脉冲炸弹！）</h3><p>在本项目中，武器分为弹道武器和即时命中武器，而<strong>只有即时命中武器会应用随机散布</strong>（总感觉弹道武器还有随机散布的话有点bt了，通过自己的努力把哈沃克压成一个点才是享受把，要是有随机散布负反馈就太多了）。</p>
<p>随机散布的原理是：之前直接将准星瞄准的地方作为命中目标，而随机散布会在命中目标的方向距离玩家一定距离处生成一个球，在球内随机选择一点作为命中目标的方向。</p>
<p><img src="/undefined/f9d4ce84/image-20250811172319785.png" alt="image-20250811172319785"></p>
<p>影响随机散布的参数有两个：<strong>球体的半径</strong>和<strong>球心与角色的距离</strong>。下面就来实现这个功能吧。</p>
<blockquote>
<p>说实话，这个功能表面上挺简单，实际上手却发现有很多小问题。这些问题和功能本身无关，而是在于网络同步方面。</p>
<p>目前的开火逻辑是在所有客户端上都调用武器的Fire函数，其参数是命中目标。随机散布就是根据这个参数来计算的。那么问题来了，随机散布的计算要在哪里进行？最简单的方式是直接在Fire函数中进行计算，这个方法的问题是每一个客户端的计算结果都是随机的，而只有服务器负责伤害的判定。那么就会出现玩家本地看到子弹轨迹命中了敌人，但是服务器上的计算结果却是未命中。这对游戏体验的破坏是致命性的。</p>
<p>接下来的方法就是我学到的，玩家在客户端直接计算命中目标，然后将其作为参数传给其它客户端和服务器用于开火，这样所有客户端的随机散布的计算结果就完全一样了。看起来是个完美的解决方案。</p>
<p>但是正如我上面说的，随机散布由两个参数决定：球体的半径和球心与角色的距离，那么，直接让客户端自行计算随机散布结果真的安全吗？只要在本地将球体半径的数据修改为接近于0，或者将球心与角色的距离修改为无限远，随机散布不就近乎于0了吗？</p>
<p>对于UE引擎的反作弊，一个要点是对于所有涉及到重要数据的操作都由服务器来处理，不使用客户端的数据，这对于上面的方法已经行不通了；另一个方法是在调用RPC时使用<code>WithValidation</code>来验证数据的合理性。问题是，这里传入的参数是计算结果，而不是半径或者距离，那么即使在调用Fire的RPC时使用<code>WithValidation</code>验证这两个值，是否会存在计算前修改这两个值，计算完后调用RPC前将这两个值复原的可能性？</p>
<p>我自己想到的解决方法是，在玩家开火时，只将命中目标通过<code>Server RPC</code>发送到服务器，由服务器进行命中点的计算，然后通过多播RPC将特效、音效、尾迹等同步到所有客户端。</p>
<p>但是这个做法也给之后实现延迟补偿埋下了一个坑，在下一部分会进行解释。除此之外还有一个明面上的问题：玩家开火后不能立刻看到效果，而是要等请求发送到了服务器，服务器处理完成后再将结果发送到客户端，才能看到开火的效果。</p>
<p>（在这部分功能完成后，我使用<code>clumsy</code>手动提高网络延迟，在<code>CS</code>、<code>Valorant</code>和<code>Overwatch</code>中进行了测试，结果是在高延迟的情况下开火都能立刻看到效果，而命中效果则会在延迟后产生。其中<code>Valorant</code>是高度依赖于随机扩散的，并且其同样是由虚幻引擎制作的。所以可能随机扩散确实是在本地计算的，并且不需要担心作弊的问题或者有其它的解决方法。接下来我会想办法搞清楚这个问题。）</p>
<p>总之，下面的随机扩散计算方法可能不算成熟，但是确实是我思考以后得出的最好方法（也有可能因为知识不足导致副作用就是了）。</p>
</blockquote>
<p>首先是随机散布的计算，传入一个向量，经过计算后返回随机散布的向量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FVector <span class="title">AHitScanWeapon::TraceEndWithScatter</span><span class="params">(<span class="type">const</span> FVector&amp; HitTarget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> USkeletalMeshSocket* MuzzleFlashSocket = <span class="built_in">GetWeaponMesh</span>()-&gt;<span class="built_in">GetSocketByName</span>(<span class="string">&quot;MuzzleFlash&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!MuzzleFlashSocket) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">FVector</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	FTransform SocketTransform = MuzzleFlashSocket-&gt;<span class="built_in">GetSocketTransform</span>(<span class="built_in">GetWeaponMesh</span>());</span><br><span class="line">	FVector TraceStart = SocketTransform.<span class="built_in">GetLocation</span>();</span><br><span class="line">	</span><br><span class="line">	FVector ToTargetNormalized = (HitTarget - TraceStart).<span class="built_in">GetSafeNormal</span>();</span><br><span class="line">	FVector SphereCenter = TraceStart + ToTargetNormalized * DistanceToSphere;</span><br><span class="line">	FVector RandVec = UKismetMathLibrary::<span class="built_in">RandomUnitVector</span>() * FMath::<span class="built_in">FRandRange</span>(<span class="number">0.f</span>, SphereRadius);</span><br><span class="line">	FVector EndLoc = SphereCenter + RandVec;</span><br><span class="line">	FVector ToEndLoc = EndLoc - TraceStart;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//DrawDebugSphere(GetWorld(), SphereCenter, SphereRadius, 12, FColor::Red, true);</span></span><br><span class="line">	<span class="comment">//DrawDebugSphere(GetWorld(), EndLoc, 4.f, 12, FColor::Green, true);</span></span><br><span class="line">	<span class="comment">//DrawDebugLine(GetWorld(), TraceStart, FVector(TraceStart + ToEndLoc * TRACE_LENGTH / ToEndLoc.Size()), FColor::Cyan, true);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">FVector</span>(TraceStart + ToEndLoc * TRACE_LENGTH / ToEndLoc.<span class="built_in">Size</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是射线检测，根据武器是否启用了随机散布来决定命中点，然后进行射线检测，检测结果通过参数中的引用进行传递。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AHitScanWeapon::WeaponTraceHit</span><span class="params">(<span class="type">const</span> FVector&amp; TraceStart, <span class="type">const</span> FVector&amp; HitTarget, FHitResult&amp; OutHit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UWorld* World = <span class="built_in">GetWorld</span>();</span><br><span class="line">	<span class="keyword">if</span> (World) &#123;</span><br><span class="line">		HitEnd = bUseScatter ? <span class="built_in">TraceEndWithScatter</span>(HitTarget) : TraceStart + (HitTarget - TraceStart) * <span class="number">1.25f</span>;</span><br><span class="line">		World-&gt;<span class="built_in">LineTraceSingleByChannel</span>(</span><br><span class="line">			OutHit,</span><br><span class="line">			TraceStart,</span><br><span class="line">			HitEnd,</span><br><span class="line">			ECollisionChannel::ECC_Visibility</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，开火时在服务器上进行命中结果的计算，然后通过多播<code>RPC</code>同步到所有客户端。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AHitScanWeapon::Fire</span><span class="params">(<span class="type">const</span> FVector&amp; HitTarget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">Fire</span>(HitTarget);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">HasAuthority</span>()) &#123;</span><br><span class="line">		APawn* OwnerPawn = <span class="built_in">Cast</span>&lt;APawn&gt;(<span class="built_in">GetOwner</span>());</span><br><span class="line">		<span class="keyword">if</span> (!OwnerPawn) <span class="keyword">return</span>;</span><br><span class="line">		AController* InstigatorController = OwnerPawn-&gt;<span class="built_in">GetController</span>();</span><br><span class="line"></span><br><span class="line">		<span class="type">const</span> USkeletalMeshSocket* MuzzleFlashSocket = <span class="built_in">GetWeaponMesh</span>()-&gt;<span class="built_in">GetSocketByName</span>(<span class="string">&quot;MuzzleFlash&quot;</span>);</span><br><span class="line">		FHitResult FireHit;</span><br><span class="line">		<span class="keyword">if</span> (MuzzleFlashSocket) &#123;</span><br><span class="line">			FTransform SocketTransform = MuzzleFlashSocket-&gt;<span class="built_in">GetSocketTransform</span>(<span class="built_in">GetWeaponMesh</span>());</span><br><span class="line">			FVector Start = SocketTransform.<span class="built_in">GetLocation</span>();</span><br><span class="line">			<span class="built_in">WeaponTraceHit</span>(Start, HitTarget, FireHit);</span><br><span class="line">			AMultiplayerTPSCharacter* MultiplayerTPSCharacter = <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(FireHit.<span class="built_in">GetActor</span>());</span><br><span class="line">			<span class="keyword">if</span> (InstigatorController &amp;&amp; MultiplayerTPSCharacter) &#123;</span><br><span class="line">				UGameplayStatics::<span class="built_in">ApplyDamage</span>(</span><br><span class="line">					MultiplayerTPSCharacter,</span><br><span class="line">					Damage,</span><br><span class="line">					InstigatorController,</span><br><span class="line">					<span class="keyword">this</span>,</span><br><span class="line">					UDamageType::<span class="built_in">StaticClass</span>()</span><br><span class="line">				);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">MulticastHitScanFire</span>(FireHit);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AHitScanWeapon::MulticastHitScanFire_Implementation</span><span class="params">(<span class="type">const</span> FHitResult&amp; FireHit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">DrawDebugSphere</span>(<span class="built_in">GetWorld</span>(), FireHit.ImpactPoint, <span class="number">16.f</span>, <span class="number">12</span>, FColor::Orange, <span class="literal">true</span>);</span><br><span class="line">	<span class="type">const</span> USkeletalMeshSocket* MuzzleFlashSocket = <span class="built_in">GetWeaponMesh</span>()-&gt;<span class="built_in">GetSocketByName</span>(<span class="string">&quot;MuzzleFlash&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (MuzzleFlashSocket) &#123;</span><br><span class="line">		FTransform SocketTransform = MuzzleFlashSocket-&gt;<span class="built_in">GetSocketTransform</span>(<span class="built_in">GetWeaponMesh</span>());</span><br><span class="line">		FVector Start = SocketTransform.<span class="built_in">GetLocation</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (FireHit.bBlockingHit) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ImpactParticles) &#123;</span><br><span class="line">				UGameplayStatics::<span class="built_in">SpawnEmitterAtLocation</span>(</span><br><span class="line">					<span class="built_in">GetWorld</span>(),</span><br><span class="line">					ImpactParticles,</span><br><span class="line">					FireHit.ImpactPoint,</span><br><span class="line">					FireHit.ImpactNormal.<span class="built_in">Rotation</span>()</span><br><span class="line">				);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (HitSound) &#123;</span><br><span class="line">				UGameplayStatics::<span class="built_in">PlaySoundAtLocation</span>(</span><br><span class="line">					<span class="keyword">this</span>,</span><br><span class="line">					HitSound,</span><br><span class="line">					FireHit.ImpactPoint</span><br><span class="line">				);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (MuzzleFlash) &#123;</span><br><span class="line">			UGameplayStatics::<span class="built_in">SpawnEmitterAtLocation</span>(</span><br><span class="line">				<span class="built_in">GetWorld</span>(),</span><br><span class="line">				MuzzleFlash,</span><br><span class="line">				SocketTransform</span><br><span class="line">			);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (FireSound) &#123;</span><br><span class="line">			UGameplayStatics::<span class="built_in">PlaySoundAtLocation</span>(</span><br><span class="line">				<span class="keyword">this</span>,</span><br><span class="line">				FireSound,</span><br><span class="line">				<span class="built_in">GetActorLocation</span>()</span><br><span class="line">			);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (BeamParticles) &#123;</span><br><span class="line">			UParticleSystemComponent* Beam = UGameplayStatics::<span class="built_in">SpawnEmitterAtLocation</span>(</span><br><span class="line">				<span class="built_in">GetWorld</span>(),</span><br><span class="line">				BeamParticles,</span><br><span class="line">				Start,</span><br><span class="line">				FRotator::ZeroRotator,</span><br><span class="line">				<span class="literal">true</span></span><br><span class="line">			);</span><br><span class="line">			<span class="keyword">if</span> (Beam) &#123;</span><br><span class="line">				FVector BeamEnd = HitEnd;</span><br><span class="line">				<span class="keyword">if</span> (FireHit.bBlockingHit) &#123;</span><br><span class="line">					BeamEnd = FireHit.ImpactPoint;</span><br><span class="line">				&#125;</span><br><span class="line">				Beam-&gt;<span class="built_in">SetVectorParameter</span>(<span class="built_in">FName</span>(<span class="string">&quot;Target&quot;</span>), BeamEnd);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-3-霰弹枪（Spa-Spa-）"><a href="#9-3-霰弹枪（Spa-Spa-）" class="headerlink" title="9.3 霰弹枪（Spa! Spa!）"></a>9.3 霰弹枪（Spa! Spa!）</h3><p>对于霰弹枪，唯一的区别就是每次射击时需要执行多次射线检测，因此将所有的检测结果存放在一个<code>Tarray</code>中。于此同时，霰弹枪可能会命中多个目标，因此需要用<code>TMap</code>存储所有命中的角色以及对应的命中数，最后遍历<code>TMap</code>来对所有命中角色造成对应的伤害。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AShotgun::Fire</span><span class="params">(<span class="type">const</span> FVector&amp; HitTarget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	AWeapon::<span class="built_in">Fire</span>(HitTarget);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">HasAuthority</span>()) &#123;</span><br><span class="line">		APawn* OwnerPawn = <span class="built_in">Cast</span>&lt;APawn&gt;(<span class="built_in">GetOwner</span>());</span><br><span class="line">		<span class="keyword">if</span> (!OwnerPawn) <span class="keyword">return</span>;</span><br><span class="line">		AController* InstigatorController = OwnerPawn-&gt;<span class="built_in">GetController</span>();</span><br><span class="line"></span><br><span class="line">		<span class="type">const</span> USkeletalMeshSocket* MuzzleFlashSocket = <span class="built_in">GetWeaponMesh</span>()-&gt;<span class="built_in">GetSocketByName</span>(<span class="string">&quot;MuzzleFlash&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (MuzzleFlashSocket) &#123;</span><br><span class="line">			FTransform SocketTransform = MuzzleFlashSocket-&gt;<span class="built_in">GetSocketTransform</span>(<span class="built_in">GetWeaponMesh</span>());</span><br><span class="line">			FVector Start = SocketTransform.<span class="built_in">GetLocation</span>();</span><br><span class="line"></span><br><span class="line">			TMap&lt;AMultiplayerTPSCharacter*, uint32&gt; HitMap;</span><br><span class="line">			<span class="keyword">for</span> (uint32 i = <span class="number">0</span>; i &lt; NumberOfPellets; ++i) &#123;</span><br><span class="line">				FHitResult FireHit;</span><br><span class="line">				<span class="built_in">WeaponTraceHit</span>(Start, HitTarget, FireHit);</span><br><span class="line">				HitResults.<span class="built_in">Add</span>(FireHit);</span><br><span class="line">				HitEnds.<span class="built_in">Add</span>(HitEnd);</span><br><span class="line"></span><br><span class="line">				AMultiplayerTPSCharacter* MultiplayerTPSCharacter = <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(FireHit.<span class="built_in">GetActor</span>());</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">HasAuthority</span>() &amp;&amp; MultiplayerTPSCharacter &amp;&amp; InstigatorController) &#123;</span><br><span class="line">					<span class="keyword">if</span> (HitMap.<span class="built_in">Contains</span>(MultiplayerTPSCharacter)) &#123;</span><br><span class="line">						++HitMap[MultiplayerTPSCharacter];</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						HitMap.<span class="built_in">Emplace</span>(MultiplayerTPSCharacter, <span class="number">1</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; HitPair : HitMap) &#123;</span><br><span class="line">				<span class="keyword">if</span> (HitPair.Key &amp;&amp; <span class="built_in">HasAuthority</span>() &amp;&amp; InstigatorController) &#123;</span><br><span class="line">					UGameplayStatics::<span class="built_in">ApplyDamage</span>(</span><br><span class="line">						HitPair.Key,</span><br><span class="line">						Damage * HitPair.Value,</span><br><span class="line">						InstigatorController,</span><br><span class="line">						<span class="keyword">this</span>,</span><br><span class="line">						UDamageType::<span class="built_in">StaticClass</span>()</span><br><span class="line">					);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">MulticastShotgunFire</span>(HitResults, HitEnds);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AShotgun::MulticastShotgunFire_Implementation</span><span class="params">(<span class="type">const</span> TArray&lt;FHitResult&gt;&amp; Hits, <span class="type">const</span> TArray&lt;FVector&gt;&amp; Ends)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> USkeletalMeshSocket* MuzzleFlashSocket = <span class="built_in">GetWeaponMesh</span>()-&gt;<span class="built_in">GetSocketByName</span>(<span class="string">&quot;MuzzleFlash&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (MuzzleFlashSocket) &#123;</span><br><span class="line">		FTransform SocketTransform = MuzzleFlashSocket-&gt;<span class="built_in">GetSocketTransform</span>(<span class="built_in">GetWeaponMesh</span>());</span><br><span class="line">		FVector Start = SocketTransform.<span class="built_in">GetLocation</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (uint32 i = <span class="number">0</span>; i &lt; NumberOfPellets; ++i) &#123;</span><br><span class="line">			<span class="built_in">DrawDebugSphere</span>(<span class="built_in">GetWorld</span>(), Hits[i].ImpactPoint, <span class="number">16.f</span>, <span class="number">12</span>, FColor::Orange, <span class="literal">true</span>);</span><br><span class="line">			<span class="keyword">if</span> (Hits[i].bBlockingHit &amp;&amp; ImpactParticles &amp;&amp; HitSound) &#123;</span><br><span class="line">				UGameplayStatics::<span class="built_in">SpawnEmitterAtLocation</span>(</span><br><span class="line">					<span class="built_in">GetWorld</span>(),</span><br><span class="line">					ImpactParticles,</span><br><span class="line">					Hits[i].ImpactPoint,</span><br><span class="line">					Hits[i].ImpactNormal.<span class="built_in">Rotation</span>()</span><br><span class="line">				);</span><br><span class="line"></span><br><span class="line">				UGameplayStatics::<span class="built_in">PlaySoundAtLocation</span>(</span><br><span class="line">					<span class="keyword">this</span>,</span><br><span class="line">					HitSound,</span><br><span class="line">					Hits[i].ImpactPoint,</span><br><span class="line">					<span class="number">.5f</span>,</span><br><span class="line">					FMath::<span class="built_in">FRandRange</span>(<span class="number">-.5f</span>, <span class="number">.5f</span>)</span><br><span class="line">				);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (BeamParticles) &#123;</span><br><span class="line">				UParticleSystemComponent* Beam = UGameplayStatics::<span class="built_in">SpawnEmitterAtLocation</span>(</span><br><span class="line">					<span class="built_in">GetWorld</span>(),</span><br><span class="line">					BeamParticles,</span><br><span class="line">					Start,</span><br><span class="line">					FRotator::ZeroRotator,</span><br><span class="line">					<span class="literal">true</span></span><br><span class="line">				);</span><br><span class="line">				<span class="keyword">if</span> (Beam) &#123;</span><br><span class="line">					FVector BeamEnd = Ends[i];</span><br><span class="line">					<span class="keyword">if</span> (Hits[i].bBlockingHit) &#123;</span><br><span class="line">						BeamEnd = Hits[i].ImpactPoint;</span><br><span class="line">					&#125;</span><br><span class="line">					Beam-&gt;<span class="built_in">SetVectorParameter</span>(<span class="built_in">FName</span>(<span class="string">&quot;Target&quot;</span>), BeamEnd);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		HitEnds.<span class="built_in">Empty</span>();</span><br><span class="line">		HitResults.<span class="built_in">Empty</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>霰弹枪有自己独特的换弹机制，那就是子弹都是一发一发上的，同时可以打断换弹的过程直接进行射击。</p>
<p>为霰弹枪的换弹单独写了一个函数，在动画蒙太奇中，每一次上弹都会有一个动画通知，会调用这个函数函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::UpdateShotgunAmmoValues</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!EquippedWeapon || !Character) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (CarriedAmmoMap.<span class="built_in">Contains</span>(EquippedWeapon-&gt;<span class="built_in">GetWeaponType</span>())) &#123;</span><br><span class="line">		CarriedAmmoMap[EquippedWeapon-&gt;<span class="built_in">GetWeaponType</span>()] -= <span class="number">1</span>;</span><br><span class="line">		CarriedAmmo = CarriedAmmoMap[EquippedWeapon-&gt;<span class="built_in">GetWeaponType</span>()];</span><br><span class="line">	&#125;</span><br><span class="line">	Controller = Controller ? Controller : <span class="built_in">Cast</span>&lt;AMPTPSPlayerController&gt;(Character-&gt;Controller);</span><br><span class="line">	<span class="keyword">if</span> (Controller) &#123;</span><br><span class="line">		Controller-&gt;<span class="built_in">SetHUDCarriedAmmo</span>(CarriedAmmo);</span><br><span class="line">	&#125;</span><br><span class="line">	EquippedWeapon-&gt;<span class="built_in">AddAmmo</span>(<span class="number">1</span>);</span><br><span class="line">	bCanFire = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (EquippedWeapon-&gt;<span class="built_in">IsFull</span>() || CarriedAmmo == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">JumpToShotgunEnd</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::ShotgunShellReload</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Character &amp;&amp; Character-&gt;<span class="built_in">HasAuthority</span>()) &#123;</span><br><span class="line">		<span class="built_in">UpdateShotgunAmmoValues</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当子弹满了或者没有备弹了，就会跳到结束片段。跳转片段的过程要进行同步，分别在携带弹药复制和武器的弹药复制中进行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::JumpToShotgunEnd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UAnimInstance* AnimInstance = Character-&gt;<span class="built_in">GetMesh</span>()-&gt;<span class="built_in">GetAnimInstance</span>();</span><br><span class="line">	<span class="keyword">if</span> (AnimInstance &amp;&amp; Character-&gt;<span class="built_in">GetReloadMontage</span>()) &#123;</span><br><span class="line">		AnimInstance-&gt;<span class="built_in">Montage_JumpToSection</span>(<span class="built_in">FName</span>(<span class="string">&quot;ShotgunEnd&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UCombatComponent::CanFire</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!EquippedWeapon) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> !EquippedWeapon-&gt;<span class="built_in">IsEmpty</span>() &amp;&amp; bCanFire &amp;&amp; (CombatState == ECombatState::ECS_Unoccupied || CombatState == ECombatState::ECS_Reloading &amp;&amp; EquippedWeapon-&gt;<span class="built_in">GetWeaponType</span>() == EWeaponType::EWT_Shotgun);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::OnRep_CarriedAmmo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Controller = Controller ? Controller : <span class="built_in">Cast</span>&lt;AMPTPSPlayerController&gt;(Character-&gt;Controller);</span><br><span class="line">	<span class="keyword">if</span> (Controller) &#123;</span><br><span class="line">		Controller-&gt;<span class="built_in">SetHUDCarriedAmmo</span>(CarriedAmmo);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> bJumpToShotgunEnd = CombatState == ECombatState::ECS_Reloading &amp;&amp; EquippedWeapon &amp;&amp; EquippedWeapon-&gt;<span class="built_in">GetWeaponType</span>() == EWeaponType::EWT_Shotgun &amp;&amp; CarriedAmmo == <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (bJumpToShotgunEnd) &#123;</span><br><span class="line">		<span class="built_in">JumpToShotgunEnd</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AWeapon::OnRep_Ammo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MultiplayerTPSOwnerCharacter = MultiplayerTPSOwnerCharacter ? MultiplayerTPSOwnerCharacter : <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(<span class="built_in">GetOwner</span>());</span><br><span class="line">	<span class="keyword">if</span> (MultiplayerTPSOwnerCharacter&amp;&amp;MultiplayerTPSOwnerCharacter-&gt;<span class="built_in">GetCombat</span>()) &#123;</span><br><span class="line">		MultiplayerTPSOwnerCharacter-&gt;<span class="built_in">GetCombat</span>()-&gt;<span class="built_in">JumpToShotgunEnd</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">SetHUDAmmo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开火时记得将战斗状态设为Unoccupied。</p>
<h3 id="9-4-狙击枪（没人可以躲过我的眼睛-）"><a href="#9-4-狙击枪（没人可以躲过我的眼睛-）" class="headerlink" title="9.4 狙击枪（没人可以躲过我的眼睛~）"></a>9.4 狙击枪（没人可以躲过我的眼睛~）</h3><p>狙击枪的特点就是瞄准时会出现瞄准镜。通过一个<code>UserWidget</code>就可以轻松搞定。当开镜时播放<code>UserWidget</code>的动画来显示瞄准键，关镜时将动画倒放即可，具体逻辑在蓝图中实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowSniperScopeWidget</span><span class="params">(<span class="type">bool</span> bShowScope)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::SetAiming</span><span class="params">(<span class="type">bool</span> bIsAiming)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!Character || !EquippedWeapon) <span class="keyword">return</span>;</span><br><span class="line">	bAiming = bIsAiming;</span><br><span class="line">	<span class="built_in">ServerSetAiming</span>(bIsAiming);</span><br><span class="line">	<span class="keyword">if</span> (Character) &#123;</span><br><span class="line">		Character-&gt;<span class="built_in">GetCharacterMovement</span>()-&gt;MaxWalkSpeed = bIsAiming ? AimWalkSpeed : BaseWalkSpeed;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (Character-&gt;<span class="built_in">IsLocallyControlled</span>() &amp;&amp; EquippedWeapon-&gt;<span class="built_in">GetWeaponType</span>() == EWeaponType::EWT_SniperRifle) &#123;</span><br><span class="line">		Character-&gt;<span class="built_in">ShowSniperScopeWidget</span>(bIsAiming);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当角色被淘汰时，如果正在用狙击枪瞄准，要为其关闭瞄准键： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">IsLocallyControlled</span>() &amp;&amp; Combat &amp;&amp; Combat-&gt;EquippedWeapon&amp;&amp; Combat-&gt;bAiming &amp;&amp; Combat-&gt;EquippedWeapon-&gt;<span class="built_in">GetWeaponType</span>() == EWeaponType::EWT_SniperRifle) &#123;</span><br><span class="line">	<span class="built_in">ShowSniperScopeWidget</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里还遇到了一个无语的Bug，在客户端，每次上弹动作都会上两次弹。找了一下午原因，在各种地方打Log，问AI，硬是每想起来直接搜一下，最后一搜就搜到了。这是UE自己的BUG，如果使用了上半身体与下半身体分开运行动画，客户端远程调用在服务器播放动画蒙太奇就会出现通知被触发两次的情况，解决方法是使用do once节点，当换弹后延迟一点时间将do once重置。</p>
<h3 id="9-5-榴弹发射器（炸弹轮胎滚起来了！）"><a href="#9-5-榴弹发射器（炸弹轮胎滚起来了！）" class="headerlink" title="9.5 榴弹发射器（炸弹轮胎滚起来了！）"></a>9.5 榴弹发射器（炸弹轮胎滚起来了！）</h3><p>榴弹的特点和火箭弹类似，就是爆炸。区别是榴弹启用了重力，同时会进行弹跳。</p>
<p>其实实现很简单，只要在投射物运动组件中将<code>bShouldBounce</code>设为true就行了（投射物运动组件万岁！），同时绑定弹跳事件的回调函数，播放弹跳的音效。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">AProjectileGrenade::<span class="built_in">AProjectileGrenade</span>()</span><br><span class="line">&#123;</span><br><span class="line">	ProjectileMesh = <span class="built_in">CreateDefaultSubobject</span>&lt;UStaticMeshComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;Grenade Mesh&quot;</span>));</span><br><span class="line">	ProjectileMesh-&gt;<span class="built_in">SetupAttachment</span>(RootComponent);</span><br><span class="line">	ProjectileMesh-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);</span><br><span class="line"></span><br><span class="line">	ProjectileMovementComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;UProjectileMovementComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;ProjectileMovementComponent&quot;</span>));</span><br><span class="line">	ProjectileMovementComponent-&gt;bRotationFollowsVelocity = <span class="literal">true</span>;</span><br><span class="line">	ProjectileMovementComponent-&gt;<span class="built_in">SetIsReplicated</span>(<span class="literal">true</span>);</span><br><span class="line">	ProjectileMovementComponent-&gt;bShouldBounce = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AProjectileGrenade::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	AActor::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">StartDestroyTimer</span>();</span><br><span class="line">	<span class="built_in">SpawnTrailSystem</span>();</span><br><span class="line"></span><br><span class="line">	ProjectileMovementComponent-&gt;OnProjectileBounce.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;AProjectileGrenade::OnBounce);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AProjectileGrenade::OnBounce</span><span class="params">(<span class="type">const</span> FHitResult&amp; ImpactResult, <span class="type">const</span> FVector&amp; ImpactVelocity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (BounceSound) &#123;</span><br><span class="line">		UGameplayStatics::<span class="built_in">PlaySoundAtLocation</span>(</span><br><span class="line">			<span class="keyword">this</span>,</span><br><span class="line">			BounceSound,</span><br><span class="line">			<span class="built_in">GetActorLocation</span>()</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AProjectileGrenade::Destroyed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">ExplodeDamage</span>();</span><br><span class="line">	</span><br><span class="line">	Super::<span class="built_in">Destroyed</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-总结"><a href="#10-总结" class="headerlink" title="10.总结"></a>10.总结</h2><p>说实话，做这个项目比我想的要有趣，尤其是在遇到具体问题和需求，思考解决方案的时候，有时候想着想着就把整个逻辑理通顺了。一直想不出来的时候是真红温，终于想出来了的时候也是真爽。</p>
<p>下一部分，延迟补偿篇，敬请期待。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.keshiki.top">Keshiki</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.keshiki.top/undefined/f9d4ce84.html">https://www.keshiki.top/undefined/f9d4ce84.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://www.keshiki.top" target="_blank">Keshiki's Blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Keshiki</div><div class="author-info-description">我们的头脑比天空更辽阔.</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yuun4g1"><i class="fab fa-github"></i><span>我的github</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到Keshiki领域~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E3%80%90UE5%E3%80%91%E5%A4%9A%E4%BA%BA%E8%81%94%E6%9C%BATPS%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89-%E2%80%94%E2%80%94-%E5%B0%84%E5%87%BB%E6%B8%B8%E6%88%8F%E6%A0%B8%E5%BF%83"><span class="toc-number">1.</span> <span class="toc-text">【UE5】多人联机TPS游戏开发（三） —— 射击游戏核心</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-HUD"><span class="toc-number">1.1.</span> <span class="toc-text">1.HUD</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%91%BD%E4%B8%AD%E4%BC%A4%E5%AE%B3"><span class="toc-number">1.2.</span> <span class="toc-text">2.命中伤害</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%B7%98%E6%B1%B0"><span class="toc-number">1.3.</span> <span class="toc-text">3.淘汰</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%8E%A9%E5%AE%B6%E7%8A%B6%E6%80%81"><span class="toc-number">1.4.</span> <span class="toc-text">4.玩家状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%8E%A9%E5%AE%B6%E6%90%BA%E5%B8%A6%E5%BC%B9%E8%8D%AF"><span class="toc-number">1.5.</span> <span class="toc-text">5.玩家携带弹药</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%8D%A2%E5%BC%B9"><span class="toc-number">1.6.</span> <span class="toc-text">6.换弹</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%B8%B8%E6%88%8F%E6%97%B6%E9%97%B4%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%A1%E6%97%B6"><span class="toc-number">1.7.</span> <span class="toc-text">7.游戏时间与服务器计时</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%AF%94%E8%B5%9B%E7%8A%B6%E6%80%81"><span class="toc-number">1.8.</span> <span class="toc-text">8.比赛状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%90%84%E7%A7%8D%E6%AD%A6%E5%99%A8"><span class="toc-number">1.9.</span> <span class="toc-text">9.各种武器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E7%81%AB%E7%AE%AD%E5%8F%91%E5%B0%84%E5%99%A8%EF%BC%88%E5%A4%A9%E9%99%8D%E6%AD%A3%E4%B9%89%EF%BC%81%EF%BC%89"><span class="toc-number">1.9.1.</span> <span class="toc-text">9.1 火箭发射器（天降正义！）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E5%86%B2%E9%94%8B%E6%9E%AA%EF%BC%88%E8%84%89%E5%86%B2%E7%82%B8%E5%BC%B9%EF%BC%81%EF%BC%89"><span class="toc-number">1.9.2.</span> <span class="toc-text">9.2 冲锋枪（脉冲炸弹！）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E9%9C%B0%E5%BC%B9%E6%9E%AA%EF%BC%88Spa-Spa-%EF%BC%89"><span class="toc-number">1.9.3.</span> <span class="toc-text">9.3 霰弹枪（Spa! Spa!）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-%E7%8B%99%E5%87%BB%E6%9E%AA%EF%BC%88%E6%B2%A1%E4%BA%BA%E5%8F%AF%E4%BB%A5%E8%BA%B2%E8%BF%87%E6%88%91%E7%9A%84%E7%9C%BC%E7%9D%9B-%EF%BC%89"><span class="toc-number">1.9.4.</span> <span class="toc-text">9.4 狙击枪（没人可以躲过我的眼睛~）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-%E6%A6%B4%E5%BC%B9%E5%8F%91%E5%B0%84%E5%99%A8%EF%BC%88%E7%82%B8%E5%BC%B9%E8%BD%AE%E8%83%8E%E6%BB%9A%E8%B5%B7%E6%9D%A5%E4%BA%86%EF%BC%81%EF%BC%89"><span class="toc-number">1.9.5.</span> <span class="toc-text">9.5 榴弹发射器（炸弹轮胎滚起来了！）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E6%80%BB%E7%BB%93"><span class="toc-number">1.10.</span> <span class="toc-text">10.总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/undefined/c1786556.html" title="【GDC】守望先锋的游戏架构和网络代码"><img src="https://s21.ax1x.com/2025/09/01/pVcj2qK.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【GDC】守望先锋的游戏架构和网络代码"/></a><div class="content"><a class="title" href="/undefined/c1786556.html" title="【GDC】守望先锋的游戏架构和网络代码">【GDC】守望先锋的游戏架构和网络代码</a><time datetime="2025-08-31T16:00:00.000Z" title="发表于 2025-09-01 00:00:00">2025-09-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/undefined/af2b6aaf.html" title="【UE5】多人联机TPS游戏开发（四） ——  延迟补偿">【UE5】多人联机TPS游戏开发（四） ——  延迟补偿</a><time datetime="2025-08-13T16:00:00.000Z" title="发表于 2025-08-14 00:00:00">2025-08-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/undefined/f9d4ce84.html" title="【UE5】多人联机TPS游戏开发（三） —— 射击游戏核心">【UE5】多人联机TPS游戏开发（三） —— 射击游戏核心</a><time datetime="2025-08-02T16:00:00.000Z" title="发表于 2025-08-03 00:00:00">2025-08-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/undefined/e6c9f323.html" title="【UE5】多人联机TPS游戏开发（二） —— 基础框架">【UE5】多人联机TPS游戏开发（二） —— 基础框架</a><time datetime="2025-07-16T16:00:00.000Z" title="发表于 2025-07-17 00:00:00">2025-07-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/undefined/f18ea7eb.html" title="【UE5】多人联机TPS游戏开发（一） ——  制作联机插件">【UE5】多人联机TPS游戏开发（一） ——  制作联机插件</a><time datetime="2025-07-04T16:00:00.000Z" title="发表于 2025-07-05 00:00:00">2025-07-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By Keshiki</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><div class="aplayer no-destroy" data-id="4875655013" data-server="netease" data-type="playlist"   data-order="list" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true" ></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><div class="app-refresh" id="app-refresh" style="position: fixed;top: -2.2rem;left: 0;right: 0;z-index: 99999;padding: 0 1rem;font-size: 15px;height: 2.2rem;transition: all 0.3s ease;"><div class="app-refresh-wrap" style=" display: flex;color: #fff;height: 100%;align-items: center;justify-content: center;"><label>好像有什么动静</label><a href="javascript:void(0)" onclick="location.reload()"><span style="color: #fff;text-decoration: underline;cursor: pointer;">去看看</span></a></div></div><script>if ('serviceWorker' in navigator) {
if (navigator.serviceWorker.controller) {
navigator.serviceWorker.addEventListener('controllerchange', function() {
showNotification()
})
}
window.addEventListener('load', function() {
navigator.serviceWorker.register('/sw.js')
})
}
function showNotification() {
if (GLOBAL_CONFIG.Snackbar) {
var snackbarBg =
document.documentElement.getAttribute('data-theme') === 'light' ?
GLOBAL_CONFIG.Snackbar.bgLight :
GLOBAL_CONFIG.Snackbar.bgDark
var snackbarPos = GLOBAL_CONFIG.Snackbar.position
Snackbar.show({
text: '好像有什么动静',
backgroundColor: snackbarBg,
duration: 500000,
pos: snackbarPos,
actionText: '去看看',
actionTextColor: '#fff',
onActionClick: function(e) {
location.reload()
},
})
} else {
var showBg =
document.documentElement.getAttribute('data-theme') === 'light' ?
'#3b70fc' :
'#1f1f1f'
var cssText = `top: 0; background: ${showBg};`
document.getElementById('app-refresh').style.cssText = cssText
}
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__slideInRight');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><script async src="/js/ali_font.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>