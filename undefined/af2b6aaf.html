<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>【UE5】多人联机TPS游戏开发（四） ——  延迟补偿 | Keshiki's Blog</title><meta name="author" content="Keshiki"><meta name="copyright" content="Keshiki"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="【UE5】多人联机TPS游戏开发（四） ——  延迟补偿 不知道为什么，最近脑子里经常响起《月光》的旋律，每当这时，因为压力而烦躁的内心都会慢慢平静下来。大概是因为被《恶灵附身》吓得失去生命体征了吧。 作为涉猎广泛的FPS老玩家，受到垃圾的网络环境的影响应该算是必经之路了。至今仍然记得初中顶着一百多毫秒延迟打OW在地图里乱飘的烦躁，还有躲到墙后仍然被打死的无语。之前只是知道有这些现象，却完全不知道">
<meta property="og:type" content="article">
<meta property="og:title" content="【UE5】多人联机TPS游戏开发（四） ——  延迟补偿">
<meta property="og:url" content="https://www.keshiki.top/undefined/af2b6aaf.html">
<meta property="og:site_name" content="Keshiki&#39;s Blog">
<meta property="og:description" content="【UE5】多人联机TPS游戏开发（四） ——  延迟补偿 不知道为什么，最近脑子里经常响起《月光》的旋律，每当这时，因为压力而烦躁的内心都会慢慢平静下来。大概是因为被《恶灵附身》吓得失去生命体征了吧。 作为涉猎广泛的FPS老玩家，受到垃圾的网络环境的影响应该算是必经之路了。至今仍然记得初中顶着一百多毫秒延迟打OW在地图里乱飘的烦躁，还有躲到墙后仍然被打死的无语。之前只是知道有这些现象，却完全不知道">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.keshiki.top/img/avatar.png">
<meta property="article:published_time" content="2025-08-13T16:00:00.000Z">
<meta property="article:modified_time" content="2025-08-13T17:49:19.301Z">
<meta property="article:author" content="Keshiki">
<meta property="article:tag" content="Keshiki,Keshiki&#39;s Blog,Keshiki的博客,博客,Blog,blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.keshiki.top/img/avatar.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "【UE5】多人联机TPS游戏开发（四） ——  延迟补偿",
  "url": "https://www.keshiki.top/undefined/af2b6aaf.html",
  "image": "https://www.keshiki.top/img/avatar.png",
  "datePublished": "2025-08-13T16:00:00.000Z",
  "dateModified": "2025-08-13T17:49:19.301Z",
  "author": [
    {
      "@type": "Person",
      "name": "Keshiki",
      "url": "https://www.keshiki.top/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://www.keshiki.top/undefined/af2b6aaf.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/manifest.json"/><meta name="msapplication-TileColor" content="#39C5BB"/><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/128.png"/><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/16.png"/><link rel="mask-icon" href="/img/siteicon/128.png" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【UE5】多人联机TPS游戏开发（四） ——  延迟补偿',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Keshiki's Blog" type="application/atom+xml">
</head><body><div id="web_bg" style="background-image: url(https://s21.ax1x.com/2024/12/11/pAbSVg0.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/index.html"><i class="fa-fw fas fa-home"></i><span> 追番</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Keshiki's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">【UE5】多人联机TPS游戏开发（四） ——  延迟补偿</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/index.html"><i class="fa-fw fas fa-home"></i><span> 追番</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">【UE5】多人联机TPS游戏开发（四） ——  延迟补偿</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-08-13T16:00:00.000Z" title="发表于 2025-08-14 00:00:00">2025-08-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-13T17:49:19.301Z" title="更新于 2025-08-14 01:49:19">2025-08-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="【UE5】多人联机TPS游戏开发（四）-——-延迟补偿"><a href="#【UE5】多人联机TPS游戏开发（四）-——-延迟补偿" class="headerlink" title="【UE5】多人联机TPS游戏开发（四） ——  延迟补偿"></a>【UE5】多人联机TPS游戏开发（四） ——  延迟补偿</h1><blockquote>
<p>不知道为什么，最近脑子里经常响起《月光》的旋律，每当这时，因为压力而烦躁的内心都会慢慢平静下来。大概是因为被《恶灵附身》吓得失去生命体征了吧。</p>
<p>作为涉猎广泛的FPS老玩家，受到垃圾的网络环境的影响应该算是必经之路了。至今仍然记得初中顶着一百多毫秒延迟打OW在地图里乱飘的烦躁，还有躲到墙后仍然被打死的无语。之前只是知道有这些现象，却完全不知道是什么原理，而现在却要自己动手尝试解决这些问题了，想到这里，不由得感到一阵恍惚，时间如流水啊。</p>
<p>可能是马上要面临的压力让我变得有些多愁善感了吧。总之，接下来将要着手解决（减轻）高延迟带来的游戏体验问题。当然，对于目前已经比较成熟的FPS竞技游戏品类，即使已经有数不清的方案被用来解决延迟问题，尚且不能完美达成目的，本项目所用到的只是最基础的几个而已，肯定还是有很大的缺陷。然而，千里之行始于足下，只要像这样持续去学习，又有什么是学不会的呢？反正这段时间我是学爽了。</p>
</blockquote>
<h2 id="1-延迟补偿"><a href="#1-延迟补偿" class="headerlink" title="1.延迟补偿"></a>1.延迟补偿</h2><p>自多人游戏诞生以来，网络延迟就是一个无法绕过的难题。对于不同的游戏品类，其对网络条件的要求是不同的，而<code>FPS</code>竞技游戏（虽然本项目是<code>TPS</code>就是了）则是其中对网络要求最高的品类之一。而网络问题又包括延迟、丢包、抖动等，本项目着重讨论的是延迟问题。</p>
<p>说实话，想要完全消除延迟是几乎不可能的事，除非哪天真的发明出了低成本的零延迟通讯技术，否则就只能想方设法在软件层面上找补。本项目使用了两个技术：<strong>客户端预测+服务器修正</strong>，以及<strong>服务器倒带</strong>，尽量降低延迟对玩家的影响。</p>
<p>为了模拟高延迟的情况，在<code>Config/DefaultEngine.ini</code>中进行相应配置：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[PacketSimulationSettings]</span></span><br><span class="line"><span class="attr">PktLag</span> = <span class="number">200</span></span><br></pre></td></tr></table></figure>
<p>在本文的最后一部分将会讨论<code>Valve</code>使用的延迟补偿技术，看看真正的游戏的做法是什么样的。</p>
<h2 id="2-延迟检测"><a href="#2-延迟检测" class="headerlink" title="2.延迟检测"></a>2.延迟检测</h2><p><code>UE</code>引擎内置了获取延迟的功能，那为什么不直接用呢？</p>
<p><code>HUD</code>部分依然放在<code>CharacterOverlay</code>中处理。包含一个图像以及一个动画，动画控制图像的闪烁。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CharacterOverlay.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(meta = (BindWidget))</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UImage</span>* HighPingImage;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(meta = (BindWidgetAnim), Transient)</span><br><span class="line">UWidgetAnimation* HighPingAnimation;</span><br></pre></td></tr></table></figure>
<p>在<code>Tick</code>中运行检查函数，当检查间隔到达一定时间后检查<code>Ping</code>，通过<code>GetCompressedPing()*4</code>获得客户端的<code>Ping</code>值，如果<code>Ping</code>高于门槛，就触发提示，播放动画。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MPTPSPlayerController.h</span></span><br><span class="line"><span class="type">float</span> HighPingRunningTime = <span class="number">0.f</span>; <span class="comment">//Ping检查间隔时间</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line"><span class="type">float</span> HighPingDuration = <span class="number">5.f</span>; <span class="comment">//高延迟提醒持续时间</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> PingAnimationRunningTime = <span class="number">0.f</span>; <span class="comment">//高延迟提醒运行时间</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line"><span class="type">float</span> CheckPingFrequency = <span class="number">5.f</span>; <span class="comment">//Ping的检查频率</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line"><span class="type">float</span> HighPingThreshold = <span class="number">50.f</span>; <span class="comment">//高Ping门槛</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MPTPSPlayerController.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::CheckPing</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HighPingRunningTime += DeltaTime;</span><br><span class="line">	<span class="keyword">if</span> (HighPingRunningTime &gt; CheckPingFrequency) &#123;</span><br><span class="line">		PlayerState = PlayerState == <span class="literal">nullptr</span> ? <span class="built_in">GetPlayerState</span>&lt;AMultiplayerTPSPlayerState&gt;() : PlayerState;</span><br><span class="line">		<span class="keyword">if</span> (PlayerState) &#123;</span><br><span class="line">			<span class="keyword">if</span> (PlayerState-&gt;<span class="built_in">GetCompressedPing</span>() * <span class="number">4</span> &gt; HighPingThreshold) &#123; <span class="comment">//得到的Ping是压缩的，要*4</span></span><br><span class="line">				<span class="built_in">HighPingWarning</span>();</span><br><span class="line">				PingAnimationRunningTime = <span class="number">0.f</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		HighPingRunningTime = <span class="number">0.f</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (MultiplayerTPSHUD &amp;&amp;</span><br><span class="line">		MultiplayerTPSHUD-&gt;CharacterOverlay &amp;&amp;</span><br><span class="line">		MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HighPingAnimation &amp;&amp;</span><br><span class="line">		MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;<span class="built_in">IsAnimationPlaying</span>(MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HighPingAnimation))</span><br><span class="line">	&#123;</span><br><span class="line">		PingAnimationRunningTime += DeltaTime;</span><br><span class="line">		<span class="keyword">if</span> (PingAnimationRunningTime &gt; HighPingDuration) &#123;</span><br><span class="line">			<span class="built_in">StopHighPingWarning</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::HighPingWarning</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MultiplayerTPSHUD = MultiplayerTPSHUD == <span class="literal">nullptr</span> ? <span class="built_in">Cast</span>&lt;AMultiplayerTPSHUD&gt;(<span class="built_in">GetHUD</span>()) : MultiplayerTPSHUD;</span><br><span class="line">	<span class="keyword">if</span> (MultiplayerTPSHUD &amp;&amp; MultiplayerTPSHUD-&gt;CharacterOverlay &amp;&amp; MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HighPingImage &amp;&amp; MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HighPingAnimation) &#123;</span><br><span class="line">		MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HighPingImage-&gt;<span class="built_in">SetOpacity</span>(<span class="number">1.f</span>);</span><br><span class="line">		MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;<span class="built_in">PlayAnimation</span>(MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HighPingAnimation, <span class="number">0.f</span>, <span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::StopHighPingWarning</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MultiplayerTPSHUD = MultiplayerTPSHUD == <span class="literal">nullptr</span> ? <span class="built_in">Cast</span>&lt;AMultiplayerTPSHUD&gt;(<span class="built_in">GetHUD</span>()) : MultiplayerTPSHUD;</span><br><span class="line">	<span class="keyword">if</span> (MultiplayerTPSHUD &amp;&amp; MultiplayerTPSHUD-&gt;CharacterOverlay &amp;&amp; MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HighPingImage &amp;&amp; MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HighPingAnimation) &#123;</span><br><span class="line">		MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HighPingImage-&gt;<span class="built_in">SetOpacity</span>(<span class="number">0.f</span>);</span><br><span class="line">		<span class="keyword">if</span> (MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;<span class="built_in">IsAnimationPlaying</span>(MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HighPingAnimation)) &#123;</span><br><span class="line">			MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;<span class="built_in">StopAnimation</span>(MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HighPingAnimation);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-客户端预测-服务器修正"><a href="#3-客户端预测-服务器修正" class="headerlink" title="3.客户端预测+服务器修正"></a>3.客户端预测+服务器修正</h2><p>在理想的情况下，客户端的一切操作都应该提交到服务器上，由服务器进行处理后将更新后的状态发送回客户端，这样能完全保证服务器权威。然而，以目前的网络发展水平，这样做是不可接受的，因为玩家的一切操作都要经过网络延迟后才能产生效果，对玩家的游戏体验来说具有极大的破坏性，尤其是那些高延迟的玩家。</p>
<p>客户端预测+服务器修正就是用来解决这个问题的。它的思想是，<strong>对于那些相对不想要那么高权威性的操作，客户端在将操作发往服务器的同时直接在本地执行这些操作</strong>，这一步为<strong>预测</strong>；而<strong>服务器收到客户端的操作并进行处理后将更新后的状态发送给客户端，此时如果该状态和客户端自己执行后的状态不同，就用服务器回复给客户端的状态将客户端自己的状态覆盖掉</strong>，这一步为<strong>修正</strong>。以移动为例，假如客户端的玩家向右移动了10米，但是因为某些原因，服务器收到的操作是玩家向右移动了5米，那么在客户端看来，玩家在收到操作指令后立即向右移动了10米，但随后服务器的计算结果来了，玩家就会被强行移动的左边5米的位置。</p>
<p>这个方法面临着一个问题：<strong>要对每一次操作都进行修正吗？</strong>同样以移动为例，客户端的玩家向右移动了10米，当这个操作发送到服务器进行处理后，服务器会将处理后的状态发送给客户端，然而如果客户端的玩家在此期间又向右移动了10米，那么当服务器的回复到达客户端时，客户端的玩家角色会被恢复到向右10米的位置，而当下一次服务器的操作处理结果到达时，客户端的玩家角色又被恢复到向右20米的位置。这显然是不合常理的。</p>
<p>对于这个问题，解决方案是：<strong>客户端每次将操作发送出去时，将这些发送记录保存下来，当收到服务器的回复时，首先检查保存的记录中有没有符合的操作，如果有，说明这次回复对应的是之前的操作，不需要进行修正；如果没有，则进行修正</strong>。</p>
<p>对于本项目，就有一个非常适合应用这项技术的地方：弹药消耗。</p>
<p>在之前的实现中，当进行开火时，会通过<code>RPC</code>在所有客户端上进行开火操作，而只有在服务器上才能进行消耗子弹的操作，当子弹数量改变后会通过复制同步到客户端，并在回调函数中进行<code>HUD</code>更新。在这种做法下，当延迟很高的时候，就会发现开火与子弹数量改变之间有很明显的时间差。</p>
<p>首先要去除<code>Ammo</code>变量的复制。弹药是一个整型变量，因此可以简单地用一个变量<code>Sequence</code>来记录对<code>Ammo</code>的操作记录。在<code>SpendRound</code>函数中，不再限制只有服务器能修改<code>Ammo</code>，取而代之的是，如果在客户端，将<code>Sequence</code>加1表示客户端消耗了一枚弹药。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AWeapon::SpendRound</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Ammo = FMath::<span class="built_in">Clamp</span>(Ammo - <span class="number">1</span>, <span class="number">0</span>, MagCapacity);</span><br><span class="line">	<span class="built_in">SetHUDAmmo</span>();</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">HasAuthority</span>()) &#123;</span><br><span class="line">		<span class="built_in">ClientUpdateAmmo</span>(Ammo);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		++Sequence;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在服务器，会调用<code>Client RPC</code>进行客户端<code>Ammo</code>变量的检查和修正。更新弹药值后将<code>Sequence</code>减1，表示这次更新对应了客户端的一次操作，然后根据<code>Sequence</code>进行客户端<code>Ammo</code>的修正。最后在客户端更新<code>HUD</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AWeapon::ClientUpdateAmmo_Implementation</span><span class="params">(int32 ServerAmmo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">HasAuthority</span>()) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Ammo = ServerAmmo;</span><br><span class="line">	--Sequence;</span><br><span class="line">	Ammo -= Sequence;</span><br><span class="line">	<span class="built_in">SetHUDAmmo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是客户端预测+服务器修正的基础运用。换弹也可以用同样的方式进行优化，因为这篇文章聚焦于技术原理，就不具体展示了。</p>
<h2 id="4-服务器倒带"><a href="#4-服务器倒带" class="headerlink" title="4.服务器倒带"></a>4.服务器倒带</h2><h3 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h3><p>在多人游戏中，我们很少注意到的一件事情是：<strong>玩家看到的一切都存在于过去（监听服务器除外）</strong>。因为只有服务器上的游戏状态是权威的，而无论是客户端向服务器发送自己的操作，还是服务器向所有客户端同步权威的游戏状态，都需要一定的时间，所以客户端看到的永远都是一段时间之前的游戏状态。对于<code>FPS</code>竞技游戏，这件事的后果就是：玩家看到了一个敌人，进行瞄准并射击，这个操作会被发送到服务器进行判定。然而对于服务器，当其收到客户端的瞄准操作时，客户端瞄准的那个玩家可能已经不在那个位置了，这时客户端得到的结果自然是未命中。延迟越高，这种情况就越明显，而这显然是不可接受的。</p>
<p><img src="/undefined/af2b6aaf/image-20250813222726592.png" alt="image-20250813222726592"></p>
<p><strong>服务器倒带</strong>就是用来解决这个问题的。服务器倒带的思想时，<strong>当客户端请求进行射击的判定时，服务器不会直接使用目标当前的状态，而是会使用目标在客户端射击时的状态进行判定</strong>。服务器倒带的核心是：<strong>记录所有玩家一定时间内的必要信息，用于在客户端射击时进行回溯，判断射击是否命中</strong>。这正是<code>FPS</code>竞技游戏中出现“明明躲到了掩体后面却被击杀”这种情况的原因。而<strong>为了避免这种情况出现得过于频繁和离谱，游戏需要对服务器倒带的范围进行一些限制</strong>，不然就太偏向于高延迟玩家，而破坏了低延迟玩家的体验了。</p>
<h3 id="4-2-角色历史信息保存"><a href="#4-2-角色历史信息保存" class="headerlink" title="4.2 角色历史信息保存"></a>4.2 角色历史信息保存</h3><p>上面说到，服务器倒带需要记录所有玩家一定时间内的必要信息。那么问题来了：<strong>所谓的“必要信息”是什么</strong>？位置？但是目标可能会蹲下，可能会跳跃，可能在做各种动作，只记录位置的话无法做到精确的判定。整个网格体？这样确实很精确，但是开销实在是太大了，尤其是在可能要存几百个记录的情况下。</p>
<p>目前的主流做法是，<strong>将玩家用一些命中盒(<code>HitBox</code>)来进行表示</strong>，这样既能相对精确地表示出模型的状态，又能节省资源，并且能直接进行爆头等命中特殊部位的判定，可以说是一举多得。</p>
<p>本项目中的角色用线框表示的结果如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于服务器倒带的HitBox</span></span><br><span class="line"><span class="comment">//为了保持命名和骨骼名称相同，不使用首字母大写</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UBoxComponent</span>* head;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UBoxComponent* pelvis;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UBoxComponent* spine_02;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UBoxComponent* spine_03;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UBoxComponent* upperarm_l;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UBoxComponent* upperarm_r;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UBoxComponent* lowerarm_l;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UBoxComponent* lowerarm_r;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UBoxComponent* hand_l;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UBoxComponent* hand_r;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UBoxComponent* backpack;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UBoxComponent* blanket;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UBoxComponent* thigh_l;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UBoxComponent* thigh_r;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UBoxComponent* calf_l;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UBoxComponent* calf_r;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UBoxComponent* foot_l;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UBoxComponent* foot_r;</span><br></pre></td></tr></table></figure>
<p>初始将这些命中盒和角色的骨骼进行绑定，并设置为无碰撞。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">head = <span class="built_in">CreateDefaultSubobject</span>&lt;UBoxComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;head&quot;</span>));</span><br><span class="line">head-&gt;<span class="built_in">SetupAttachment</span>(<span class="built_in">GetMesh</span>(), <span class="built_in">FName</span>(<span class="string">&quot;head&quot;</span>));</span><br><span class="line">head-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);</span><br><span class="line"></span><br><span class="line">pelvis = <span class="built_in">CreateDefaultSubobject</span>&lt;UBoxComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;pelvis&quot;</span>));</span><br><span class="line">pelvis-&gt;<span class="built_in">SetupAttachment</span>(<span class="built_in">GetMesh</span>(), <span class="built_in">FName</span>(<span class="string">&quot;pelvis&quot;</span>));</span><br><span class="line">pelvis-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><img src="/undefined/af2b6aaf/image-20250807165704097.png" alt="image-20250807165704097"></p>
<p>对于服务器倒带的相关逻辑，我想放在一起统一处理，所以我创建了一个<code>Actor</code>组件<code>LagCompensationComponent</code>。在其中声明两个结构体，分别用来保存命中盒自身的信息和角色的所有命中盒以及时间的信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">USTRUCT</span>(BlueprintType)</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FBoxInformation</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line">	FVector Location;</span><br><span class="line"></span><br><span class="line">	FVector Rotation;</span><br><span class="line"></span><br><span class="line">	FVector BoxExtent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">USTRUCT</span>(BlueprintType)</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FFramePackage</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> Time;</span><br><span class="line"></span><br><span class="line">	TMap&lt;FName, FBoxInformation&gt; HitBoxInfo;</span><br><span class="line">    </span><br><span class="line">    AMultiplayerTPSCharacter* Character;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在角色类中进行初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">LagCompensation = <span class="built_in">CreateDefaultSubobject</span>&lt;ULagCompensationComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;LagCompensation&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::PostInitializeComponents</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">PostInitializeComponents</span>();</span><br><span class="line">	<span class="comment">//初始化CombatComponent</span></span><br><span class="line">	... </span><br><span class="line">	<span class="comment">//初始化BuffComponent</span></span><br><span class="line">	... </span><br><span class="line">	<span class="comment">//初始化LagCompensationComponent</span></span><br><span class="line">	<span class="keyword">if</span> (LagCompensation) &#123;</span><br><span class="line">		LagCompensation-&gt;Character = <span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">if</span> (Controller) &#123;</span><br><span class="line">			LagCompensation-&gt;Controller = <span class="built_in">Cast</span>&lt;AMPTPSPlayerController&gt;(Controller);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个<code>TMap</code>，用来保存所有的命中盒信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>()</span><br><span class="line">TMap&lt;FName, UBoxComponent*&gt; HitCollisionBoxes;</span><br><span class="line"></span><br><span class="line">HitCollisionBoxes.<span class="built_in">Add</span>(<span class="built_in">FName</span>(<span class="string">&quot;head&quot;</span>), head);</span><br></pre></td></tr></table></figure>
<p>在<code>LagCompensationComponent</code>中定义用来保存当前帧的所有角色命中盒信息的函数以及绘制命中盒的函数。在<code>BeginPlay</code>中保存并绘制，就能看到命中盒在游戏中的样子了（我承认头确实有点大了）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ULagCompensationComponent::SaveFramePackage</span><span class="params">(FFramePackage&amp; Package)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Character) &#123;</span><br><span class="line">		Package.Time = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetTimeSeconds</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; BoxPair : Character-&gt;HitCollisionBoxes) &#123;</span><br><span class="line">			FBoxInformation BoxInformation;</span><br><span class="line">			BoxInformation.Location = BoxPair.Value-&gt;<span class="built_in">GetComponentLocation</span>();</span><br><span class="line">			BoxInformation.Rotation = BoxPair.Value-&gt;<span class="built_in">GetComponentRotation</span>();</span><br><span class="line">			BoxInformation.BoxExtent = BoxPair.Value-&gt;<span class="built_in">GetScaledBoxExtent</span>();</span><br><span class="line">			Package.HitBoxInfo.<span class="built_in">Add</span>(BoxPair.Key, BoxInformation);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ULagCompensationComponent::ShowFramePackage</span><span class="params">(<span class="type">const</span> FFramePackage&amp; Package, FColor Color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; BoxInfo:Package.HitBoxInfo) &#123;</span><br><span class="line">		<span class="built_in">DrawDebugBox</span>(</span><br><span class="line">			<span class="built_in">GetWorld</span>(),</span><br><span class="line">			BoxInfo.Value.Location,</span><br><span class="line">			BoxInfo.Value.BoxExtent,</span><br><span class="line">			<span class="built_in">FQuat</span>(BoxInfo.Value.Rotation),</span><br><span class="line">			Color,</span><br><span class="line">			<span class="literal">true</span></span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/undefined/af2b6aaf/image-20250807165731876.png" alt="image-20250807165731876"></p>
<p>接下来的问题是，要如何保存一定时间范围内的命中盒信息？</p>
<p>想象一下，随着时间的流逝，我们需要不断保存新的命中盒信息，同时丢弃那些超出服务器倒带范围的命中盒信息，这代表着<strong>要在数据结构的两端进行频繁增删</strong>；同时因为要按时间进行回溯，所以<strong>这些命中盒信息必须是有序的</strong>。而满足这些要求的数据结构正是<strong>双向链表</strong>。</p>
<p>在组件中声明一个保存命中盒信息的双向链表，同时声明服务器倒带的最长回溯时间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TDoubleLinkedList&lt;FFramePackage&gt; FrameHistory;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line"><span class="type">float</span> MaxRecordTime = <span class="number">4.f</span>;</span><br></pre></td></tr></table></figure>
<p>在<code>Tick</code>中保存每一帧的命中盒信息，同时如果双向链表尾部的节点已经超出了回溯范围，将其丢弃。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ULagCompensationComponent::TickComponent</span><span class="params">(<span class="type">float</span> DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">TickComponent</span>(DeltaTime, TickType, ThisTickFunction);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (FrameHistory.<span class="built_in">Num</span>() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		FrameHistory.<span class="built_in">AddHead</span>(<span class="built_in">FFramePackage</span>());</span><br><span class="line">		<span class="built_in">SaveFramePackage</span>(FrameHistory.<span class="built_in">GetHead</span>()-&gt;<span class="built_in">GetValue</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">float</span> HistoryLength = FrameHistory.<span class="built_in">GetHead</span>()-&gt;<span class="built_in">GetValue</span>().Time - FrameHistory.<span class="built_in">GetTail</span>()-&gt;<span class="built_in">GetValue</span>().Time;</span><br><span class="line">		<span class="keyword">while</span> (HistoryLength &gt; MaxRecordTime) &#123;</span><br><span class="line">			FrameHistory.<span class="built_in">RemoveNode</span>(FrameHistory.<span class="built_in">GetTail</span>());</span><br><span class="line">			HistoryLength = FrameHistory.<span class="built_in">GetHead</span>()-&gt;<span class="built_in">GetValue</span>().Time - FrameHistory.<span class="built_in">GetTail</span>()-&gt;<span class="built_in">GetValue</span>().Time;</span><br><span class="line">		&#125;</span><br><span class="line">		FrameHistory.<span class="built_in">AddHead</span>(<span class="built_in">FFramePackage</span>());</span><br><span class="line">		<span class="built_in">SaveFramePackage</span>(FrameHistory.<span class="built_in">GetHead</span>()-&gt;<span class="built_in">GetValue</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">ShowFramePackage</span>(FrameHistory.<span class="built_in">GetHead</span>()-&gt;<span class="built_in">GetValue</span>(), FColor::Red);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将这些命中盒绘制出来就可以看到效果了。在实际体验中，可以感觉到这种保存方式对游戏流畅性的影响基本没有。</p>
<p><img src="/undefined/af2b6aaf/image-20250807173747265.png" alt="image-20250807173747265"></p>
<p>为了方便进行检测命中盒，新建了一个碰撞通道<code>HitBox</code>，并定义了一个宏：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define ECC_HitBox ECollisionChannel::ECC_GameTraceChannel2</span><br></pre></td></tr></table></figure>
<p>在构造角色时遍历角色的TMap，设置每一个HitBox的碰撞通道。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; Box : HitCollisionBoxes) &#123;</span><br><span class="line">	Box.Value-&gt;<span class="built_in">SetCollisionObjectType</span>(ECC_HitBox);</span><br><span class="line">	Box.Value-&gt;<span class="built_in">SetCollisionResponseToAllChannels</span>(ECollisionResponse::ECR_Ignore);</span><br><span class="line">	Box.Value-&gt;<span class="built_in">SetCollisionResponseToChannel</span>(ECC_HitBox, ECollisionResponse::ECR_Block);</span><br><span class="line">	Box.Value-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-倒带"><a href="#4-3-倒带" class="headerlink" title="4.3 倒带"></a>4.3 倒带</h3><p>然后就是服务器倒带最重要的部分：倒带的实现了。</p>
<p>声明一个结构体，保存服务器倒带的检查结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">USTRUCT</span>(BlueprintType)</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FServerSideRewindResult</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> bHitConfirmed;</span><br><span class="line">	<span class="type">bool</span> bHeadShot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先从<code>HitScanWeapon</code>开始，讲解一遍服务器倒带的流程。</p>
<blockquote>
<p>上一篇中我自己挖的坑在这里被我自己踩了。为了杜绝作弊，我的做法是由服务器计算散布并进行检测，结果到了这里，客户端就无法提供命中的角色，也就无法通过这种方式实现服务器倒带了。</p>
<p>但是我想到了一个方法：只要将所有角色的命中盒进行倒带，不就能直接检测并且不需要提供命中角色了吗？而对于这种小体量并且玩家数不多的游戏，这种代价应该是可以接受的。</p>
<p>不过这里还是得到了教训：做之前先多了解目前已经成熟的技术方案，不要脑子一热觉得自己想到了什么盲点（哪怕是问了AI）。</p>
<p>下面介绍的是正常的服务器倒带实现方法。</p>
</blockquote>
<p>当客户端角色开火后，不再将判定都交由服务器进行处理，而是直接在本地进行射线检测。如果检测到命中了敌方角色，则将命中的角色作为参数传给服务器进行服务器倒带。其它参数分别是射击起始位置（枪口<code>Socket</code>），命中位置，命中时间，以及发起角色。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MultiplayerTPSOwnerCharacter-&gt;<span class="built_in">GetLagCompensation</span>()-&gt;<span class="built_in">ServerScoreRequest</span>(</span><br><span class="line">				MultiplayerTPSCharacter,</span><br><span class="line">				Start,</span><br><span class="line">				HitTarget,</span><br><span class="line">				MultiplayerTPSOwnerController-&gt;<span class="built_in">GetServerTime</span>()-MultiplayerTPSOwnerController-&gt;SingleTripTime, <span class="comment">//射击时间是服务器时间减去单程通信时间。</span></span><br><span class="line">				<span class="keyword">this</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>服务器会根据这些参数判断是否成功命中。首先判断命中时间是否超出了最大倒带范围，如果命中时间在双向链表尾部节点的时间之前，直接返回空结果。接下来寻找两个目标节点，使得命中时间在这两个目标节点的时间时间，然后通过插值的方式获取命中时间时对应的所有命中盒信息。</p>
<p>获得了要检查的命中盒后，接下来的过程就简单了。先将角色当前的命中盒信息保存下来，然后将角色的命中盒更改为要检测的命中盒，并关闭角色网格体的碰撞。这时候就可以进行射线检测了。首先开启头部命中盒的碰撞，检测后如果命中，说明命中了头部，直接返回结果，否则关闭头部命中盒的同时开启其它命中盒的碰撞进行检测，如果命中则返回结果。最终返回未命中的结果。在任何返回前记得将角色的命中盒、网格体碰撞以及碰撞盒的碰撞改为原样。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ULagCompensationComponent::ServerScoreRequest_Implementation</span><span class="params">(AMultiplayerTPSCharacter* HitCharacter, <span class="type">const</span> FVector_NetQuantize&amp; TraceStart, <span class="type">const</span> FVector_NetQuantize&amp; HitLocation, <span class="type">float</span> HitTime, AWeapon* DamageCasuer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FServerSideRewindResult Confirm = <span class="built_in">ServerSideRewind</span>(HitCharacter, TraceStart, HitLocation, HitTime);</span><br><span class="line">	<span class="keyword">if</span> (Character &amp;&amp; HitCharacter &amp;&amp; Confirm.bHitConfirmed &amp;&amp; DamageCasuer) &#123;</span><br><span class="line">		UGameplayStatics::<span class="built_in">ApplyDamage</span>(</span><br><span class="line">			HitCharacter,</span><br><span class="line">			DamageCasuer-&gt;<span class="built_in">GetDamage</span>(),</span><br><span class="line">			Character-&gt;Controller,</span><br><span class="line">			DamageCasuer,</span><br><span class="line">			UDamageType::<span class="built_in">StaticClass</span>()</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FServerSideRewindResult <span class="title">ULagCompensationComponent::ServerSideRewind</span><span class="params">(AMultiplayerTPSCharacter* HitCharacter, <span class="type">const</span> FVector_NetQuantize&amp; TraceStart, <span class="type">const</span> FVector_NetQuantize&amp; HitLocation, <span class="type">float</span> HitTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FFramePackage FrameToCheck = <span class="built_in">GetFrameToCheck</span>(HitCharacter, HitTime);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">ConfirmHit</span>(FrameToCheck, HitCharacter, TraceStart, HitLocation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FFramePackage <span class="title">ULagCompensationComponent::GetFrameToCheck</span><span class="params">(AMultiplayerTPSCharacter* HitCharacter, <span class="type">float</span> HitTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">bool</span> bReturn = !HitCharacter || !HitCharacter-&gt;LagCompensation || !HitCharacter-&gt;LagCompensation-&gt;FrameHistory.<span class="built_in">GetHead</span>() || !HitCharacter-&gt;LagCompensation-&gt;FrameHistory.<span class="built_in">GetTail</span>();</span><br><span class="line">	<span class="keyword">if</span> (bReturn) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">FFramePackage</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	FFramePackage FrameToCheck; <span class="comment">//最终用来检查是否命中的FramePackage</span></span><br><span class="line">	FrameToCheck.Character = HitCharacter;</span><br><span class="line">	<span class="type">const</span> TDoubleLinkedList&lt;FFramePackage&gt;&amp; History = HitCharacter-&gt;LagCompensation-&gt;FrameHistory;</span><br><span class="line">	<span class="type">const</span> <span class="type">float</span> OldestHistoryTime = History.<span class="built_in">GetTail</span>()-&gt;<span class="built_in">GetValue</span>().Time;</span><br><span class="line">	<span class="type">const</span> <span class="type">float</span> NewestHistoryTime = History.<span class="built_in">GetHead</span>()-&gt;<span class="built_in">GetValue</span>().Time;</span><br><span class="line">	<span class="keyword">if</span> (OldestHistoryTime &gt; HitTime) &#123;</span><br><span class="line">		<span class="comment">//命中时间超过了倒带的最远时间</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">FFramePackage</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (NewestHistoryTime &lt;= HitTime) &#123;</span><br><span class="line">		FrameToCheck = History.<span class="built_in">GetHead</span>()-&gt;<span class="built_in">GetValue</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> Younger = History.<span class="built_in">GetHead</span>();</span><br><span class="line">	<span class="keyword">auto</span> Older = Younger;</span><br><span class="line">	<span class="keyword">while</span> (Older-&gt;<span class="built_in">GetValue</span>().Time &gt; HitTime) &#123;</span><br><span class="line">		<span class="comment">//目标：OlderTime &lt; HitTime &lt; YoungerTime</span></span><br><span class="line">		<span class="keyword">if</span> (!Older-&gt;<span class="built_in">GetNextNode</span>()) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Older = Older-&gt;<span class="built_in">GetNextNode</span>();</span><br><span class="line">		<span class="keyword">if</span> (Older-&gt;<span class="built_in">GetValue</span>().Time &gt; HitTime) &#123;</span><br><span class="line">			Younger = Older;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	FrameToCheck = <span class="built_in">InterpBetweenFrames</span>(Older-&gt;<span class="built_in">GetValue</span>(), Younger-&gt;<span class="built_in">GetValue</span>(), HitTime);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> FrameToCheck;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FFramePackage <span class="title">ULagCompensationComponent::InterpBetweenFrames</span><span class="params">(<span class="type">const</span> FFramePackage&amp; OlderFrame, <span class="type">const</span> FFramePackage&amp; YoungerFrame, <span class="type">float</span> HitTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">float</span> Distance = YoungerFrame.Time - OlderFrame.Time;</span><br><span class="line">	<span class="type">const</span> <span class="type">float</span> InterpFraction = FMath::<span class="built_in">Clamp</span>((HitTime - OlderFrame.Time) / Distance, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">	FFramePackage InterpFramePackage;</span><br><span class="line">	InterpFramePackage.Character = OlderFrame.Character;</span><br><span class="line">	InterpFramePackage.Time = HitTime;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; YoungerPair : YoungerFrame.HitBoxInfo) &#123;</span><br><span class="line">		<span class="type">const</span> FName&amp; BoxInfoName = YoungerPair.Key;</span><br><span class="line">		<span class="type">const</span> FBoxInformation&amp; OlderBox = OlderFrame.HitBoxInfo[BoxInfoName];</span><br><span class="line">		<span class="comment">//const FBoxInformation&amp; YoungerBox = YoungerFrame.HitBoxInfo[BoxInfoName];</span></span><br><span class="line">		<span class="type">const</span> FBoxInformation&amp; YoungerBox = YoungerPair.Value;</span><br><span class="line"></span><br><span class="line">		FBoxInformation InterpBoxInfo;</span><br><span class="line">		InterpBoxInfo.Location = FMath::<span class="built_in">VInterpTo</span>(OlderBox.Location, YoungerBox.Location, <span class="number">1.f</span>, InterpFraction);</span><br><span class="line">		InterpBoxInfo.Rotation = FMath::<span class="built_in">RInterpTo</span>(OlderBox.Rotation, YoungerBox.Rotation, <span class="number">1.f</span>, InterpFraction);</span><br><span class="line">		InterpBoxInfo.BoxExtent = YoungerBox.BoxExtent;</span><br><span class="line"></span><br><span class="line">		InterpFramePackage.HitBoxInfo.<span class="built_in">Add</span>(BoxInfoName, InterpBoxInfo);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> InterpFramePackage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FServerSideRewindResult <span class="title">ULagCompensationComponent::ConfirmHit</span><span class="params">(<span class="type">const</span> FFramePackage&amp; Package, AMultiplayerTPSCharacter* HitCharacter, <span class="type">const</span> FVector_NetQuantize&amp; TraceStart, <span class="type">const</span> FVector_NetQuantize&amp; HitLocation)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!HitCharacter) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">FServerSideRewindResult</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	FFramePackage CurrentFrame;</span><br><span class="line">	<span class="built_in">CacheBoxPositions</span>(HitCharacter, CurrentFrame);</span><br><span class="line">	<span class="built_in">MoveBoxes</span>(HitCharacter, Package);</span><br><span class="line">	<span class="built_in">EnableCharacterMeshCollision</span>(HitCharacter, ECollisionEnabled::NoCollision);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//首先启用头部碰撞</span></span><br><span class="line">	UBoxComponent* HeadBox = HitCharacter-&gt;HitCollisionBoxes[<span class="built_in">FName</span>(<span class="string">&quot;head&quot;</span>)];</span><br><span class="line">	HeadBox-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::QueryAndPhysics);</span><br><span class="line">	HeadBox-&gt;<span class="built_in">SetCollisionResponseToChannel</span>(ECC_HitBox, ECollisionResponse::ECR_Block);</span><br><span class="line"></span><br><span class="line">	FHitResult ConfirmHitResult;</span><br><span class="line">	<span class="type">const</span> FVector TraceEnd = TraceStart + (HitLocation - TraceStart) * <span class="number">1.25f</span>;</span><br><span class="line">	UWorld* World = <span class="built_in">GetWorld</span>();</span><br><span class="line">	<span class="keyword">if</span> (World) &#123;</span><br><span class="line">		World-&gt;<span class="built_in">LineTraceSingleByChannel</span>(</span><br><span class="line">			ConfirmHitResult,</span><br><span class="line">			TraceStart,</span><br><span class="line">			TraceEnd,</span><br><span class="line">			ECC_HitBox</span><br><span class="line">		);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (ConfirmHitResult.bBlockingHit) &#123; <span class="comment">//如果命中，说明命中了头部，提前返回，将角色的HitBox移回原位</span></span><br><span class="line">			<span class="built_in">ResetBoxes</span>(HitCharacter, CurrentFrame);</span><br><span class="line">			<span class="built_in">EnableCharacterMeshCollision</span>(HitCharacter, ECollisionEnabled::QueryAndPhysics);</span><br><span class="line">			<span class="keyword">return</span> FServerSideRewindResult&#123; <span class="literal">true</span>,<span class="literal">true</span> &#125;;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123; <span class="comment">//没有命中，检查剩余HitBox</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; HitBoxPair : HitCharacter-&gt;HitCollisionBoxes) &#123;</span><br><span class="line">				<span class="keyword">if</span> (HitBoxPair.Value) &#123;</span><br><span class="line">					HitBoxPair.Value-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::QueryAndPhysics);</span><br><span class="line">					HitBoxPair.Value-&gt;<span class="built_in">SetCollisionResponseToChannel</span>(ECC_HitBox, ECollisionResponse::ECR_Block);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			World-&gt;<span class="built_in">LineTraceSingleByChannel</span>(</span><br><span class="line">				ConfirmHitResult,</span><br><span class="line">				TraceStart,</span><br><span class="line">				TraceEnd,</span><br><span class="line">				ECC_HitBox</span><br><span class="line">			);</span><br><span class="line">			<span class="keyword">if</span> (ConfirmHitResult.bBlockingHit) &#123;</span><br><span class="line">				<span class="built_in">ResetBoxes</span>(HitCharacter, CurrentFrame);</span><br><span class="line">				<span class="built_in">EnableCharacterMeshCollision</span>(HitCharacter, ECollisionEnabled::QueryAndPhysics);</span><br><span class="line">				<span class="keyword">return</span> FServerSideRewindResult&#123; <span class="literal">true</span>,<span class="literal">false</span> &#125;;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ResetBoxes</span>(HitCharacter, CurrentFrame);</span><br><span class="line">	<span class="built_in">EnableCharacterMeshCollision</span>(HitCharacter, ECollisionEnabled::QueryAndPhysics);</span><br><span class="line">	<span class="keyword">return</span> FServerSideRewindResult&#123; <span class="literal">false</span>,<span class="literal">false</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一些辅助函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ULagCompensationComponent::CacheBoxPositions</span><span class="params">(AMultiplayerTPSCharacter* HitCharacter, FFramePackage&amp; OutFramePackage)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!HitCharacter) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; HitBoxPair : Character-&gt;HitCollisionBoxes) &#123;</span><br><span class="line">		<span class="keyword">if</span> (HitBoxPair.Value) &#123;</span><br><span class="line">			FBoxInformation BoxInfo;</span><br><span class="line">			BoxInfo.Location = HitBoxPair.Value-&gt;<span class="built_in">GetComponentLocation</span>();</span><br><span class="line">			BoxInfo.Rotation = HitBoxPair.Value-&gt;<span class="built_in">GetComponentRotation</span>();</span><br><span class="line">			BoxInfo.BoxExtent = HitBoxPair.Value-&gt;<span class="built_in">GetScaledBoxExtent</span>();</span><br><span class="line">			OutFramePackage.HitBoxInfo.<span class="built_in">Add</span>(HitBoxPair.Key, BoxInfo);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ULagCompensationComponent::MoveBoxes</span><span class="params">(AMultiplayerTPSCharacter* HitCharacter, <span class="type">const</span> FFramePackage&amp; Package)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!HitCharacter) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; HitBoxPair : Character-&gt;HitCollisionBoxes) &#123;</span><br><span class="line">		<span class="keyword">if</span> (HitBoxPair.Value) &#123;</span><br><span class="line">			HitBoxPair.Value-&gt;<span class="built_in">SetWorldLocation</span>(Package.HitBoxInfo[HitBoxPair.Key].Location);</span><br><span class="line">			HitBoxPair.Value-&gt;<span class="built_in">SetWorldRotation</span>(Package.HitBoxInfo[HitBoxPair.Key].Rotation);</span><br><span class="line">			<span class="comment">//HitBoxPair.Value-&gt;SetBoxExtent(Package.HitBoxInfo[HitBoxPair.Key].BoxExtent);</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ULagCompensationComponent::ResetBoxes</span><span class="params">(AMultiplayerTPSCharacter* HitCharacter, <span class="type">const</span> FFramePackage&amp; Package)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!HitCharacter) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; HitBoxPair : Character-&gt;HitCollisionBoxes) &#123;</span><br><span class="line">		<span class="keyword">if</span> (HitBoxPair.Value) &#123;</span><br><span class="line">			HitBoxPair.Value-&gt;<span class="built_in">SetWorldLocation</span>(Package.HitBoxInfo[HitBoxPair.Key].Location);</span><br><span class="line">			HitBoxPair.Value-&gt;<span class="built_in">SetWorldRotation</span>(Package.HitBoxInfo[HitBoxPair.Key].Rotation);</span><br><span class="line">			<span class="comment">//HitBoxPair.Value-&gt;SetBoxExtent(Package.HitBoxInfo[HitBoxPair.Key].BoxExtent);</span></span><br><span class="line">			HitBoxPair.Value-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ULagCompensationComponent::EnableCharacterMeshCollision</span><span class="params">(AMultiplayerTPSCharacter* HitCharacter, ECollisionEnabled::Type CollisionEnable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (HitCharacter &amp;&amp; HitCharacter-&gt;<span class="built_in">GetMesh</span>()) &#123;</span><br><span class="line">		HitCharacter-&gt;<span class="built_in">GetMesh</span>()-&gt;<span class="built_in">SetCollisionEnabled</span>(CollisionEnable);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于霰弹枪的倒带，思想和即时命中武器是差不多的，但是因为可能会命中多个角色，需要做一些调整。</p>
<p>声明一个新的结构体，用来保存霰弹枪的命中结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FShotgunServerSideRewindResult</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line">	TMap&lt;AMultiplayerTPSCharacter*, uint32&gt; HeadShots;</span><br><span class="line">	TMap&lt;AMultiplayerTPSCharacter*, uint32&gt; BodyShots;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在进行检测的时候对所有的命中目标进行倒带并检测，返回检测结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FShotgunServerSideRewindResult <span class="title">ULagCompensationComponent::ShotgunServerSideRewind</span><span class="params">(<span class="type">const</span> TArray&lt;AMultiplayerTPSCharacter*&gt;&amp; HitCharacters, <span class="type">const</span> FVector_NetQuantize&amp; TraceStart, <span class="type">const</span> TArray&lt;FVector_NetQuantize&gt;&amp; HitLocations, <span class="type">float</span> HitTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TArray&lt;FFramePackage&gt; FramesToCheck;</span><br><span class="line">	<span class="keyword">for</span> (AMultiplayerTPSCharacter* HitCharacter : HitCharacters) &#123;</span><br><span class="line">		FramesToCheck.<span class="built_in">Add</span>(<span class="built_in">GetFrameToCheck</span>(HitCharacter, HitTime));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">ShotgunConfirmHit</span>(FramesToCheck, TraceStart, HitLocations);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FShotgunServerSideRewindResult <span class="title">ULagCompensationComponent::ShotgunConfirmHit</span><span class="params">(<span class="type">const</span> TArray&lt;FFramePackage&gt;&amp; FramePackages, <span class="type">const</span> FVector_NetQuantize&amp; TraceStart, <span class="type">const</span> TArray&lt;FVector_NetQuantize&gt;&amp; HitLocations)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; Frame : FramePackages) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!Frame.Character) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">FShotgunServerSideRewindResult</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	FShotgunServerSideRewindResult ShotgunResult;</span><br><span class="line">	TArray&lt;FFramePackage&gt; CurrentFrames;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; Frame : FramePackages) &#123;</span><br><span class="line">		FFramePackage CurrentFrame;</span><br><span class="line">		CurrentFrame.Character = Frame.Character;</span><br><span class="line">		<span class="built_in">CacheBoxPositions</span>(Frame.Character, CurrentFrame);</span><br><span class="line">		<span class="built_in">MoveBoxes</span>(Frame.Character, Frame);</span><br><span class="line">		<span class="built_in">EnableCharacterMeshCollision</span>(Frame.Character, ECollisionEnabled::NoCollision);</span><br><span class="line">		CurrentFrames.<span class="built_in">Add</span>(CurrentFrame);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; Frame : FramePackages) &#123;</span><br><span class="line">		<span class="comment">//首先启用头部碰撞</span></span><br><span class="line">		UBoxComponent* HeadBox = Frame.Character-&gt;HitCollisionBoxes[<span class="built_in">FName</span>(<span class="string">&quot;head&quot;</span>)];</span><br><span class="line">		HeadBox-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::QueryAndPhysics);</span><br><span class="line">		HeadBox-&gt;<span class="built_in">SetCollisionResponseToChannel</span>(ECollisionChannel::ECC_Visibility, ECollisionResponse::ECR_Block);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	UWorld* World = <span class="built_in">GetWorld</span>();</span><br><span class="line">	<span class="comment">//检测爆头</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; HitLocation : HitLocations) &#123;</span><br><span class="line">		FHitResult ConfirmHitResult;</span><br><span class="line">		<span class="type">const</span> FVector TraceEnd = TraceStart + (HitLocation - TraceStart) * <span class="number">1.25f</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (World) &#123;</span><br><span class="line">			World-&gt;<span class="built_in">LineTraceSingleByChannel</span>(</span><br><span class="line">				ConfirmHitResult,</span><br><span class="line">				TraceStart,</span><br><span class="line">				TraceEnd,</span><br><span class="line">				ECollisionChannel::ECC_Visibility</span><br><span class="line">			);</span><br><span class="line">			AMultiplayerTPSCharacter* MultiplayerTPSCharacter = <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(ConfirmHitResult.<span class="built_in">GetActor</span>());</span><br><span class="line">			<span class="keyword">if</span> (MultiplayerTPSCharacter) &#123;</span><br><span class="line">				<span class="keyword">if</span> (ShotgunResult.HeadShots.<span class="built_in">Contains</span>(MultiplayerTPSCharacter)) &#123;</span><br><span class="line">					++ShotgunResult.HeadShots[MultiplayerTPSCharacter];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					ShotgunResult.HeadShots.<span class="built_in">Emplace</span>(MultiplayerTPSCharacter, <span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//启用其它盒体的碰撞，禁用头部盒体的碰撞</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; Frame : FramePackages) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; HitBoxPair : Frame.Character-&gt;HitCollisionBoxes) &#123;</span><br><span class="line">			<span class="keyword">if</span> (HitBoxPair.Value) &#123;</span><br><span class="line">				HitBoxPair.Value-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::QueryAndPhysics);</span><br><span class="line">				HitBoxPair.Value-&gt;<span class="built_in">SetCollisionResponseToChannel</span>(ECollisionChannel::ECC_Visibility, ECollisionResponse::ECR_Block);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		UBoxComponent* HeadBox = Frame.Character-&gt;HitCollisionBoxes[<span class="built_in">FName</span>(<span class="string">&quot;head&quot;</span>)];</span><br><span class="line">		HeadBox-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//检测身体命中</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; HitLocation : HitLocations) &#123;</span><br><span class="line">		FHitResult ConfirmHitResult;</span><br><span class="line">		<span class="type">const</span> FVector TraceEnd = TraceStart + (HitLocation - TraceStart) * <span class="number">1.25f</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (World) &#123;</span><br><span class="line">			World-&gt;<span class="built_in">LineTraceSingleByChannel</span>(</span><br><span class="line">				ConfirmHitResult,</span><br><span class="line">				TraceStart,</span><br><span class="line">				TraceEnd,</span><br><span class="line">				ECollisionChannel::ECC_Visibility</span><br><span class="line">			);</span><br><span class="line">			AMultiplayerTPSCharacter* MultiplayerTPSCharacter = <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(ConfirmHitResult.<span class="built_in">GetActor</span>());</span><br><span class="line">			<span class="keyword">if</span> (MultiplayerTPSCharacter) &#123;</span><br><span class="line">				<span class="keyword">if</span> (ShotgunResult.BodyShots.<span class="built_in">Contains</span>(MultiplayerTPSCharacter)) &#123;</span><br><span class="line">					++ShotgunResult.BodyShots[MultiplayerTPSCharacter];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					ShotgunResult.BodyShots.<span class="built_in">Emplace</span>(MultiplayerTPSCharacter, <span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; Frame : CurrentFrames) &#123;</span><br><span class="line">		<span class="built_in">ResetBoxes</span>(Frame.Character, Frame);</span><br><span class="line">		<span class="built_in">EnableCharacterMeshCollision</span>(Frame.Character, ECollisionEnabled::QueryAndPhysics);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> ShotgunResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在射击时调用<code>Server RPC</code>请求服务器倒带。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">TMap&lt;AMultiplayerTPSCharacter*, uint32&gt; HitMap;</span><br><span class="line"><span class="keyword">for</span> (uint32 i = <span class="number">0</span>; i &lt; NumberOfPellets; ++i) &#123;</span><br><span class="line">	FHitResult FireHit;</span><br><span class="line">	<span class="built_in">WeaponTraceHit</span>(Start, HitTarget, FireHit);</span><br><span class="line">	HitResults.<span class="built_in">Add</span>(FireHit);</span><br><span class="line">	HitEnds.<span class="built_in">Add</span>(HitEnd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	AMultiplayerTPSCharacter* MultiplayerTPSCharacter = <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(FireHit.<span class="built_in">GetActor</span>());</span><br><span class="line">	<span class="keyword">if</span> (MultiplayerTPSCharacter &amp;&amp; InstigatorController) &#123;</span><br><span class="line">		<span class="keyword">if</span> (HitMap.<span class="built_in">Contains</span>(MultiplayerTPSCharacter)) &#123;</span><br><span class="line">			++HitMap[MultiplayerTPSCharacter];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			HitMap.<span class="built_in">Emplace</span>(MultiplayerTPSCharacter, <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">TArray&lt;AMultiplayerTPSCharacter*&gt; HitCharacters;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; HitPair : HitMap) &#123;</span><br><span class="line">	<span class="keyword">if</span> (HitPair.Key &amp;&amp; InstigatorController) &#123;</span><br><span class="line">		HitCharacters.<span class="built_in">Add</span>(HitPair.Key);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MultiplayerTPSOwnerCharacter = MultiplayerTPSOwnerCharacter ? MultiplayerTPSOwnerCharacter : <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(OwnerPawn);</span><br><span class="line">MultiplayerTPSOwnerController = MultiplayerTPSOwnerController ? MultiplayerTPSOwnerController : <span class="built_in">Cast</span>&lt;AMPTPSPlayerController&gt;(InstigatorController);</span><br><span class="line"><span class="keyword">if</span> (MultiplayerTPSOwnerCharacter &amp;&amp; MultiplayerTPSOwnerController &amp;&amp; MultiplayerTPSOwnerCharacter-&gt;<span class="built_in">GetLagCompensation</span>() &amp;&amp; MultiplayerTPSOwnerCharacter-&gt;<span class="built_in">IsLocallyControlled</span>()) &#123;</span><br><span class="line">	MultiplayerTPSOwnerCharacter-&gt;<span class="built_in">GetLagCompensation</span>()-&gt;<span class="built_in">ServerShotgunServerScoreRequest</span>(</span><br><span class="line">		HitCharacters,</span><br><span class="line">		Start,</span><br><span class="line">		HitEnds,</span><br><span class="line">		MultiplayerTPSOwnerController-&gt;<span class="built_in">GetServerTime</span>() - MultiplayerTPSOwnerController-&gt;SingleTripTime</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ULagCompensationComponent::ServerShotgunServerScoreRequest_Implementation</span><span class="params">(<span class="type">const</span> TArray&lt;AMultiplayerTPSCharacter*&gt;&amp; HitCharacters, <span class="type">const</span> FVector_NetQuantize&amp; TraceStart, <span class="type">const</span> TArray&lt;FVector_NetQuantize&gt;&amp; HitLocations, <span class="type">float</span> HitTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FShotgunServerSideRewindResult Confirm = <span class="built_in">ShotgunServerSideRewind</span>(HitCharacters, TraceStart, HitLocations, HitTime);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; HitCharacter : HitCharacters) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!HitCharacter || !Character || !Character-&gt;<span class="built_in">GetEquippedWeapon</span>()) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">float</span> TotalDamage = <span class="number">0.f</span>;</span><br><span class="line">		<span class="keyword">if</span> (Confirm.HeadShots.<span class="built_in">Contains</span>(HitCharacter)) &#123;</span><br><span class="line">			<span class="type">float</span> HeadShotDamage = Confirm.HeadShots[HitCharacter] * Character-&gt;<span class="built_in">GetEquippedWeapon</span>()-&gt;<span class="built_in">GetDamage</span>();</span><br><span class="line">			TotalDamage += HeadShotDamage;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (Confirm.BodyShots.<span class="built_in">Contains</span>(HitCharacter)) &#123;</span><br><span class="line">			<span class="type">float</span> BodyDamage = Confirm.BodyShots[HitCharacter] * Character-&gt;<span class="built_in">GetEquippedWeapon</span>()-&gt;<span class="built_in">GetDamage</span>();</span><br><span class="line">			TotalDamage += BodyDamage;</span><br><span class="line">		&#125;</span><br><span class="line">		UGameplayStatics::<span class="built_in">ApplyDamage</span>(</span><br><span class="line">			HitCharacter,</span><br><span class="line">			TotalDamage,</span><br><span class="line">			Character-&gt;Controller,</span><br><span class="line">			Character-&gt;<span class="built_in">GetEquippedWeapon</span>(),</span><br><span class="line">			UDamageType::<span class="built_in">StaticClass</span>()</span><br><span class="line">		);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后是弹道武器的服务器倒带。<code>UE</code>引擎自带了投射物路径预测的功能，这使得弹道武器的服务器倒带实现起来容易了很多。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FPredictProjectilePathParams PathParams;</span><br><span class="line">PathParams.bTraceWithChannel = <span class="literal">true</span>;</span><br><span class="line">PathParams.bTraceWithCollision = <span class="literal">true</span>;</span><br><span class="line">PathParams.DrawDebugTime = <span class="number">5.f</span>;</span><br><span class="line">PathParams.DrawDebugType = EDrawDebugTrace::ForDuration;</span><br><span class="line">PathParams.LaunchVelocity = <span class="built_in">GetActorForwardVector</span>() * InitialSpeed;</span><br><span class="line">PathParams.MaxSimTime = <span class="number">4.f</span>;</span><br><span class="line">PathParams.ProjectileRadius = <span class="number">5.f</span>;</span><br><span class="line">PathParams.SimFrequency = <span class="number">30.f</span>;PathParams.StartLocation = <span class="built_in">GetActorLocation</span>();</span><br><span class="line">PathParams.TraceChannel = ECollisionChannel::ECC_Visibility;</span><br><span class="line">PathParams.ActorsToIgnore.<span class="built_in">Add</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">FPredictProjectilePathResult PathResult;</span><br><span class="line">UGameplayStatics::<span class="built_in">PredictProjectilePath</span>(<span class="keyword">this</span>, PathParams, PathResult);</span><br></pre></td></tr></table></figure>
<p><img src="/undefined/af2b6aaf/image-20250809151616224.png" alt="image-20250809151616224"></p>
<p>在投射物基类中声明用于服务器倒带的变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> bUseServerSideRewind = <span class="literal">false</span>;</span><br><span class="line">FVector_NetQuantize TraceStart;</span><br><span class="line">FVector_NetQuantize100 InitialVelocity;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line"><span class="type">float</span> InitialSpeed = <span class="number">15000.f</span>;</span><br></pre></td></tr></table></figure>
<p>在构造函数中将投射物运动组件的初速度设为我们自己的变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ProjectileMovementComponent-&gt;InitialSpeed = InitialSpeed;</span><br><span class="line">ProjectileMovementComponent-&gt;MaxSpeed = InitialSpeed;</span><br></pre></td></tr></table></figure>
<p>这里有一个问题。我需要初速度和最大速度这两个变量来进行服务器倒带，但是投射物运动组件中使用的并不是这两个变量，而是直接在蓝图中由我们设置的。如果我们手动更改<code>InitialSpeed</code>，蓝图中的初速度和最大速度也是不会自动变化的。为了使其自动跟随<code>InitialSpeed</code>自动变化，这里使用了一个黑科技。</p>
<p>重写下面这个函数，并使用<code>#if</code>进行标记。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> WITH_EDITOR</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PostEditChangeProperty</span><span class="params">(<span class="keyword">struct</span> FPropertyChangedEvent&amp; Event)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>在函数定义中同样使用<code>#if</code>进行定义，这样在蓝图中更改<code>InitialSpeed</code>的值，初速度和最大速度就会跟着改变了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> WITH_EDITOR</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AProjectileBullet::PostEditChangeProperty</span><span class="params">(FPropertyChangedEvent&amp; Event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">PostEditChangeProperty</span>(Event);</span><br><span class="line"></span><br><span class="line">	FName PropertyName = Event.Property ? Event.Property-&gt;<span class="built_in">GetFName</span>() : NAME_None;</span><br><span class="line">	<span class="keyword">if</span> (PropertyName == <span class="built_in">GET_MEMBER_NAME_CHECKED</span>(AProjectileBullet, InitialSpeed)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ProjectileMovementComponent) &#123;</span><br><span class="line">			ProjectileMovementComponent-&gt;InitialSpeed = InitialSpeed;</span><br><span class="line">			ProjectileMovementComponent-&gt;MaxSpeed = InitialSpeed;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>来到投射物的生成部分。在弹道武器中再加一个用于服务器倒带的投射物类，它的唯一区别是不启用复制。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">TSubclassOf&lt;<span class="keyword">class</span> <span class="title class_">AProjectile</span>&gt; ProjectileClass;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">TSubclassOf&lt;AProjectile&gt; ServerSideRewindProjectileClass;</span><br></pre></td></tr></table></figure>
<p>重写弹道武器的开火逻辑，根据是否是服务器，是否启用服务器倒带以及是否是本地控制来决定生成投射物的逻辑。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AProjectileWeapon::Fire</span><span class="params">(<span class="type">const</span> FVector&amp; HitTarget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">Fire</span>(HitTarget);</span><br><span class="line"></span><br><span class="line">	APawn* InstigatorPawn = <span class="built_in">Cast</span>&lt;APawn&gt;(<span class="built_in">GetOwner</span>());</span><br><span class="line">	<span class="type">const</span> USkeletalMeshSocket* MuzzleFlashSocket = <span class="built_in">GetWeaponMesh</span>()-&gt;<span class="built_in">GetSocketByName</span>(<span class="built_in">FName</span>(<span class="string">&quot;MuzzleFlash&quot;</span>));</span><br><span class="line">	UWorld* World = <span class="built_in">GetWorld</span>();</span><br><span class="line">	<span class="keyword">if</span> (MuzzleFlashSocket &amp;&amp; InstigatorPawn &amp;&amp; World) &#123;</span><br><span class="line">		FTransform SocketTransform = MuzzleFlashSocket-&gt;<span class="built_in">GetSocketTransform</span>(<span class="built_in">GetWeaponMesh</span>());</span><br><span class="line">		<span class="comment">//从MuzzleSocket到命中点</span></span><br><span class="line">		FVector ToTarget = HitTarget - SocketTransform.<span class="built_in">GetLocation</span>();</span><br><span class="line">		FRotator TargetRotatrion = ToTarget.<span class="built_in">Rotation</span>();</span><br><span class="line"></span><br><span class="line">		FActorSpawnParameters SpawnParams;</span><br><span class="line">		SpawnParams.Owner = <span class="built_in">GetOwner</span>();</span><br><span class="line">		SpawnParams.Instigator = InstigatorPawn;</span><br><span class="line"></span><br><span class="line">		AProjectile* SpawnedProjectile = <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="keyword">if</span> (bUseServerSideRewind) &#123;</span><br><span class="line">			<span class="keyword">if</span> (InstigatorPawn-&gt;<span class="built_in">HasAuthority</span>()) &#123; <span class="comment">//服务器</span></span><br><span class="line">				<span class="keyword">if</span> (InstigatorPawn-&gt;<span class="built_in">IsLocallyControlled</span>()) &#123; <span class="comment">//监听服务器，不需要进行服务器倒带，直接生成复制的投射物</span></span><br><span class="line">					SpawnedProjectile = World-&gt;<span class="built_in">SpawnActor</span>&lt;AProjectile&gt;(ProjectileClass,SocketTransform.<span class="built_in">GetLocation</span>(),TargetRotatrion,SpawnParams);</span><br><span class="line">					SpawnedProjectile-&gt;bUseServerSideRewind = <span class="literal">false</span>;</span><br><span class="line">					SpawnedProjectile-&gt;Damage = Damage;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123; <span class="comment">//服务器，客户端请求的的开火，生成不复制的投射物，并且不使用服务器倒带，因为客户端自己会生成投射物并请求服务器倒带</span></span><br><span class="line">					SpawnedProjectile = World-&gt;<span class="built_in">SpawnActor</span>&lt;AProjectile&gt;(ServerSideRewindProjectileClass, SocketTransform.<span class="built_in">GetLocation</span>(), TargetRotatrion, SpawnParams);</span><br><span class="line">					SpawnedProjectile-&gt;bUseServerSideRewind = <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123; <span class="comment">//客户端</span></span><br><span class="line">				<span class="keyword">if</span> (InstigatorPawn-&gt;<span class="built_in">IsLocallyControlled</span>()) &#123; <span class="comment">//客户端，本地控制，生成不复制的投射物，并且启用服务器倒带</span></span><br><span class="line">					SpawnedProjectile = World-&gt;<span class="built_in">SpawnActor</span>&lt;AProjectile&gt;(ProjectileClass, SocketTransform.<span class="built_in">GetLocation</span>(), TargetRotatrion, SpawnParams);</span><br><span class="line">					SpawnedProjectile-&gt;bUseServerSideRewind = <span class="literal">true</span>;</span><br><span class="line">					SpawnedProjectile-&gt;TraceStart = SocketTransform.<span class="built_in">GetLocation</span>();</span><br><span class="line">					SpawnedProjectile-&gt;InitialVelocity = SpawnedProjectile-&gt;<span class="built_in">GetActorForwardVector</span>() * SpawnedProjectile-&gt;InitialSpeed;</span><br><span class="line">					SpawnedProjectile-&gt;Damage = Damage;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123; <span class="comment">//客户端，非本地控制，生成不复制且不启用服务器倒带的投射物</span></span><br><span class="line">					SpawnedProjectile = World-&gt;<span class="built_in">SpawnActor</span>&lt;AProjectile&gt;(ServerSideRewindProjectileClass, SocketTransform.<span class="built_in">GetLocation</span>(), TargetRotatrion, SpawnParams);</span><br><span class="line">					SpawnedProjectile-&gt;bUseServerSideRewind = <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123; <span class="comment">//不使用服务器倒带</span></span><br><span class="line">			<span class="keyword">if</span> (InstigatorPawn-&gt;<span class="built_in">HasAuthority</span>()) &#123;</span><br><span class="line">				SpawnedProjectile = World-&gt;<span class="built_in">SpawnActor</span>&lt;AProjectile&gt;(ProjectileClass, SocketTransform.<span class="built_in">GetLocation</span>(), TargetRotatrion, SpawnParams);</span><br><span class="line">				SpawnedProjectile-&gt;bUseServerSideRewind = <span class="literal">false</span>;</span><br><span class="line">				SpawnedProjectile-&gt;Damage = Damage;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后就是倒带的具体实现了。当子弹命中时，如果是在服务器并且没有使用服务器倒带或者是服务器自己发射的子弹，直接造成伤害，否则如果是本地发射的子弹并且启用的服务器倒带，就调用Server RPC来进行服务器倒带进行命中判定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AProjectileBullet::OnHit</span><span class="params">(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, <span class="type">const</span> FHitResult&amp; Hit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	AMultiplayerTPSCharacter* OwnerCharacter = <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(<span class="built_in">GetOwner</span>());</span><br><span class="line">	<span class="keyword">if</span> (OwnerCharacter) &#123;</span><br><span class="line">		AMPTPSPlayerController* OwnerController = <span class="built_in">Cast</span>&lt;AMPTPSPlayerController&gt;(OwnerCharacter-&gt;Controller);</span><br><span class="line">		<span class="keyword">if</span> (OwnerController) &#123;</span><br><span class="line">			<span class="keyword">if</span> (OwnerCharacter-&gt;<span class="built_in">HasAuthority</span>() &amp;&amp; (!bUseServerSideRewind || OwnerCharacter-&gt;<span class="built_in">IsLocallyControlled</span>())) &#123;</span><br><span class="line">				UGameplayStatics::<span class="built_in">ApplyDamage</span>(OtherActor, Damage, OwnerController, <span class="keyword">this</span>, UDamageType::<span class="built_in">StaticClass</span>());</span><br><span class="line">				Super::<span class="built_in">OnHit</span>(HitComp, OtherActor, OtherComp, NormalImpulse, Hit);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			AMultiplayerTPSCharacter* HitCharacter = <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(OtherActor);</span><br><span class="line">			<span class="keyword">if</span> (bUseServerSideRewind &amp;&amp; OwnerCharacter-&gt;<span class="built_in">GetLagCompensation</span>() &amp;&amp; OwnerCharacter-&gt;<span class="built_in">IsLocallyControlled</span>() &amp;&amp; HitCharacter) &#123;</span><br><span class="line">				<span class="built_in">ServerProjectileScoreRequest</span>(</span><br><span class="line">					HitCharacter,</span><br><span class="line">					TraceStart,</span><br><span class="line">					InitialVelocity,</span><br><span class="line">					OwnerController-&gt;<span class="built_in">GetServerTime</span>() - OwnerController-&gt;SingleTripTime</span><br><span class="line">				);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Super::<span class="built_in">OnHit</span>(HitComp, OtherActor, OtherComp, NormalImpulse, Hit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ULagCompensationComponent::ServerProjectileScoreRequest_Implementation</span><span class="params">(AMultiplayerTPSCharacter* HitCharacter, <span class="type">const</span> FVector_NetQuantize&amp; TraceStart, <span class="type">const</span> FVector_NetQuantize100&amp; InitialVelocity, <span class="type">float</span> HitTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FServerSideRewindResult Confirm = <span class="built_in">ProjectileServerSideRewind</span>(HitCharacter, TraceStart, InitialVelocity, HitTime);</span><br><span class="line">	<span class="keyword">if</span> (Character &amp;&amp; HitCharacter &amp;&amp; Confirm.bHitConfirmed) &#123;</span><br><span class="line">		UGameplayStatics::<span class="built_in">ApplyDamage</span>(</span><br><span class="line">			HitCharacter,</span><br><span class="line">			Character-&gt;<span class="built_in">GetEquippedWeapon</span>()-&gt;<span class="built_in">GetDamage</span>(),</span><br><span class="line">			Character-&gt;Controller,</span><br><span class="line">			Character-&gt;<span class="built_in">GetEquippedWeapon</span>(),</span><br><span class="line">			UDamageType::<span class="built_in">StaticClass</span>()</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FServerSideRewindResult <span class="title">ULagCompensationComponent::ProjectileServerSideRewind</span><span class="params">(AMultiplayerTPSCharacter* HitCharacter, <span class="type">const</span> FVector_NetQuantize&amp; TraceStart, <span class="type">const</span> FVector_NetQuantize&amp; InitialVelocity, <span class="type">float</span> HitTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FFramePackage FrameToCheck = <span class="built_in">GetFrameToCheck</span>(HitCharacter, HitTime);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">ProjectileConfirmHit</span>(FrameToCheck, HitCharacter, TraceStart, InitialVelocity, HitTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FServerSideRewindResult <span class="title">ULagCompensationComponent::ProjectileConfirmHit</span><span class="params">(<span class="type">const</span> FFramePackage&amp; Package, AMultiplayerTPSCharacter* HitCharacter, <span class="type">const</span> FVector_NetQuantize&amp; TraceStart, <span class="type">const</span> FVector_NetQuantize&amp; InitialVelocity, <span class="type">float</span> HitTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!HitCharacter) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">FServerSideRewindResult</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	FFramePackage CurrentFrame;</span><br><span class="line">	<span class="built_in">CacheBoxPositions</span>(HitCharacter, CurrentFrame);</span><br><span class="line">	<span class="built_in">MoveBoxes</span>(HitCharacter, Package);</span><br><span class="line">	<span class="built_in">EnableCharacterMeshCollision</span>(HitCharacter, ECollisionEnabled::NoCollision);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//首先启用头部碰撞</span></span><br><span class="line">	UBoxComponent* HeadBox = HitCharacter-&gt;HitCollisionBoxes[<span class="built_in">FName</span>(<span class="string">&quot;head&quot;</span>)];</span><br><span class="line">	HeadBox-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::QueryAndPhysics);</span><br><span class="line">	HeadBox-&gt;<span class="built_in">SetCollisionResponseToChannel</span>(ECC_HitBox, ECollisionResponse::ECR_Block);</span><br><span class="line"></span><br><span class="line">	FPredictProjectilePathParams PathParams;</span><br><span class="line">	PathParams.bTraceWithCollision = <span class="literal">true</span>;</span><br><span class="line">	PathParams.DrawDebugTime = MaxRecordTime;</span><br><span class="line">	PathParams.LaunchVelocity = InitialVelocity;</span><br><span class="line">	PathParams.StartLocation = TraceStart;</span><br><span class="line">	PathParams.ProjectileRadius = <span class="number">5.f</span>;</span><br><span class="line">	PathParams.SimFrequency = <span class="number">15.f</span>;</span><br><span class="line">	PathParams.TraceChannel = ECC_HitBox;</span><br><span class="line">	PathParams.ActorsToIgnore.<span class="built_in">Add</span>(<span class="built_in">GetOwner</span>());</span><br><span class="line">	PathParams.DrawDebugTime = <span class="number">5.f</span>;</span><br><span class="line">	PathParams.DrawDebugType = EDrawDebugTrace::ForDuration;</span><br><span class="line"></span><br><span class="line">	FPredictProjectilePathResult PathResult;</span><br><span class="line">	UGameplayStatics::<span class="built_in">PredictProjectilePath</span>(<span class="keyword">this</span>, PathParams, PathResult);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (PathResult.HitResult.bBlockingHit) &#123;</span><br><span class="line">		<span class="built_in">ResetBoxes</span>(HitCharacter, CurrentFrame);</span><br><span class="line">		<span class="built_in">EnableCharacterMeshCollision</span>(HitCharacter, ECollisionEnabled::QueryAndPhysics);</span><br><span class="line">		<span class="keyword">return</span> FServerSideRewindResult&#123; <span class="literal">true</span>,<span class="literal">true</span> &#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; HitBoxPair : HitCharacter-&gt;HitCollisionBoxes) &#123;</span><br><span class="line">			<span class="keyword">if</span> (HitBoxPair.Value) &#123;</span><br><span class="line">				HitBoxPair.Value-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::QueryAndPhysics);</span><br><span class="line">				HitBoxPair.Value-&gt;<span class="built_in">SetCollisionResponseToChannel</span>(ECC_HitBox, ECollisionResponse::ECR_Block);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		UGameplayStatics::<span class="built_in">PredictProjectilePath</span>(<span class="keyword">this</span>, PathParams, PathResult);</span><br><span class="line">		<span class="keyword">if</span> (PathResult.HitResult.bBlockingHit) &#123;</span><br><span class="line">			<span class="built_in">ResetBoxes</span>(HitCharacter, CurrentFrame);</span><br><span class="line">			<span class="built_in">EnableCharacterMeshCollision</span>(HitCharacter, ECollisionEnabled::QueryAndPhysics);</span><br><span class="line">			<span class="keyword">return</span> FServerSideRewindResult&#123; <span class="literal">true</span>,<span class="literal">false</span> &#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ResetBoxes</span>(HitCharacter, CurrentFrame);</span><br><span class="line">	<span class="built_in">EnableCharacterMeshCollision</span>(HitCharacter, ECollisionEnabled::QueryAndPhysics);</span><br><span class="line">	<span class="keyword">return</span> FServerSideRewindResult&#123; <span class="literal">false</span>,<span class="literal">false</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-4-禁用服务器倒带"><a href="#4-4-禁用服务器倒带" class="headerlink" title="4.4 禁用服务器倒带"></a>4.4 禁用服务器倒带</h3><p>之前说过，当玩家的延迟高到一定程度时，使用服务器倒带会为其它低延迟玩家带来较差的游戏体验，因此当玩家延迟高到一定程度的时候应该禁用服务器倒带。</p>
<p>首先这个变量应该是有条件复制的，因为只要控制角色的客户端才需要这个变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DOREPLIFETIME_CONDITION</span>(AWeapon, bUseServerSideRewind, COND_OwnerOnly);</span><br></pre></td></tr></table></figure>
<p>之前在控制器中实现了定期检查Ping，现在检查Ping后调用<code>Server RPC</code>，根据ping的高低决定是否启用服务器倒带。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::CheckPing</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HighPingRunningTime += DeltaTime;</span><br><span class="line">	<span class="keyword">if</span> (HighPingRunningTime &gt; CheckPingFrequency) &#123;</span><br><span class="line">		PlayerState = PlayerState == <span class="literal">nullptr</span> ? <span class="built_in">GetPlayerState</span>&lt;AMultiplayerTPSPlayerState&gt;() : PlayerState;</span><br><span class="line">		<span class="keyword">if</span> (PlayerState) &#123;</span><br><span class="line">			<span class="keyword">if</span> (PlayerState-&gt;<span class="built_in">GetCompressedPing</span>() * <span class="number">4</span> &gt; HighPingThreshold) &#123;</span><br><span class="line">				<span class="built_in">HighPingWarning</span>();</span><br><span class="line">				PingAnimationRunningTime = <span class="number">0.f</span>;</span><br><span class="line">				<span class="built_in">ServerReportPingStatus</span>(<span class="literal">true</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">ServerReportPingStatus</span>(<span class="literal">false</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		HighPingRunningTime = <span class="number">0.f</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (MultiplayerTPSHUD &amp;&amp;</span><br><span class="line">		MultiplayerTPSHUD-&gt;CharacterOverlay &amp;&amp;</span><br><span class="line">		MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HighPingAnimation &amp;&amp;</span><br><span class="line">		MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;<span class="built_in">IsAnimationPlaying</span>(MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HighPingAnimation))</span><br><span class="line">	&#123;</span><br><span class="line">		PingAnimationRunningTime += DeltaTime;</span><br><span class="line">		<span class="keyword">if</span> (PingAnimationRunningTime &gt; HighPingDuration) &#123;</span><br><span class="line">			<span class="built_in">StopHighPingWarning</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::ServerReportPingStatus</span><span class="params">(<span class="type">bool</span> bHighPing)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	AMultiplayerTPSCharacter* Character = <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(Owner);</span><br><span class="line">	<span class="keyword">if</span> (Character &amp;&amp; Character-&gt;<span class="built_in">GetEquippedWeapon</span>()) &#123;</span><br><span class="line">		Character-&gt;<span class="built_in">GetEquippedWeapon</span>()-&gt;bUseServerSideRewind = !bHighPing;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-讨论和总结"><a href="#5-讨论和总结" class="headerlink" title="5.讨论和总结"></a>5.讨论和总结</h2><p>完成了上面的部分后，出于好奇，我找到了两篇<code>Valve</code>的文章，介绍了起源引擎中使用的多人游戏网络技术。</p>
<p><a target="_blank" rel="noopener" href="https://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking">Source Multiplayer Networking - Valve Developer Community</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.valvesoftware.com/wiki/Latency_Compensating_Methods_in_Client/Server_In-game_Protocol_Design_and_Optimization">服务器游戏内协议设计与优化 - Valve 开发者社区</a></p>
<p>事实上，我发现文章中的重点正是本文中介绍的两种技术，除此之外，还有在两个快照之间进行插值等使游戏体验更加丝滑的手段。（另外，我看到文中介绍的服务器倒带在实现中确实是将所有玩家进行回溯再进行检测的，所以我的想法算是歪打正着了？）然而，这已经是二十多年前的文章了，也就是说，我目前所了解了知识仍然只是一个基础而已，而在这二十多年里肯定也有相当多的相关技术手段诞生。前路漫长啊。</p>
<p>在完成延迟补偿部分后，可以说本项目的重点部分已经结束了。目前项目中的玩法部分还没有实现，但是秋招已经开始一段时间了，我不能等到所有工作都完全准备好再开始行动，毕竟哪里会有真正的准备好呢？总之，玩法部分的开发会缓慢进行，至于现在，先祝我自己好运吧。</p>
<blockquote>
<p>朝焼けた色 空を舞って<br>朝晖之下 在空中起舞</p>
<p>何を願うかなんて愚問だ<br>竟然可笑到问我愿望为何</p>
<p>大人になって忘れていた<br>成为大人后就已经忘了</p>
<p>君を映す目が邪魔だ<br>映照出你的这双眼睛 竟是累赘</p>
<p>ずっと下で花が鳴った<br>千里之下鲜花低唱</p>
<p>大きな火の花が鳴った<br>巨大的火焰响彻夜空</p>
<p>音だけでも泣いてしまう、だなんて憶う<br>「只听声音就已泫然欲泣」 记得曾有这番情景</p>
<p>そんな夏を聞いた<br>听到了如此声响的夏天</p>
<p>——ヨルシカ《靴の花火》</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.keshiki.top">Keshiki</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.keshiki.top/undefined/af2b6aaf.html">https://www.keshiki.top/undefined/af2b6aaf.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://www.keshiki.top" target="_blank">Keshiki's Blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Keshiki</div><div class="author-info-description">我们的头脑比天空更辽阔.</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yuun4g1"><i class="fab fa-github"></i><span>我的github</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到Keshiki领域~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E3%80%90UE5%E3%80%91%E5%A4%9A%E4%BA%BA%E8%81%94%E6%9C%BATPS%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%EF%BC%88%E5%9B%9B%EF%BC%89-%E2%80%94%E2%80%94-%E5%BB%B6%E8%BF%9F%E8%A1%A5%E5%81%BF"><span class="toc-number">1.</span> <span class="toc-text">【UE5】多人联机TPS游戏开发（四） ——  延迟补偿</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%BB%B6%E8%BF%9F%E8%A1%A5%E5%81%BF"><span class="toc-number">1.1.</span> <span class="toc-text">1.延迟补偿</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%BB%B6%E8%BF%9F%E6%A3%80%E6%B5%8B"><span class="toc-number">1.2.</span> <span class="toc-text">2.延迟检测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%A2%84%E6%B5%8B-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BF%AE%E6%AD%A3"><span class="toc-number">1.3.</span> <span class="toc-text">3.客户端预测+服务器修正</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%80%92%E5%B8%A6"><span class="toc-number">1.4.</span> <span class="toc-text">4.服务器倒带</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1 基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E8%A7%92%E8%89%B2%E5%8E%86%E5%8F%B2%E4%BF%A1%E6%81%AF%E4%BF%9D%E5%AD%98"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2 角色历史信息保存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%80%92%E5%B8%A6"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3 倒带</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E7%A6%81%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%80%92%E5%B8%A6"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.4 禁用服务器倒带</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%AE%A8%E8%AE%BA%E5%92%8C%E6%80%BB%E7%BB%93"><span class="toc-number">1.5.</span> <span class="toc-text">5.讨论和总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/undefined/c1786556.html" title="【GDC】守望先锋的游戏架构和网络代码"><img src="https://s21.ax1x.com/2025/09/01/pVcj2qK.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【GDC】守望先锋的游戏架构和网络代码"/></a><div class="content"><a class="title" href="/undefined/c1786556.html" title="【GDC】守望先锋的游戏架构和网络代码">【GDC】守望先锋的游戏架构和网络代码</a><time datetime="2025-08-31T16:00:00.000Z" title="发表于 2025-09-01 00:00:00">2025-09-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/undefined/af2b6aaf.html" title="【UE5】多人联机TPS游戏开发（四） ——  延迟补偿">【UE5】多人联机TPS游戏开发（四） ——  延迟补偿</a><time datetime="2025-08-13T16:00:00.000Z" title="发表于 2025-08-14 00:00:00">2025-08-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/undefined/f9d4ce84.html" title="【UE5】多人联机TPS游戏开发（三） —— 射击游戏核心">【UE5】多人联机TPS游戏开发（三） —— 射击游戏核心</a><time datetime="2025-08-02T16:00:00.000Z" title="发表于 2025-08-03 00:00:00">2025-08-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/undefined/e6c9f323.html" title="【UE5】多人联机TPS游戏开发（二） —— 基础框架">【UE5】多人联机TPS游戏开发（二） —— 基础框架</a><time datetime="2025-07-16T16:00:00.000Z" title="发表于 2025-07-17 00:00:00">2025-07-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/undefined/f18ea7eb.html" title="【UE5】多人联机TPS游戏开发（一） ——  制作联机插件">【UE5】多人联机TPS游戏开发（一） ——  制作联机插件</a><time datetime="2025-07-04T16:00:00.000Z" title="发表于 2025-07-05 00:00:00">2025-07-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By Keshiki</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><div class="aplayer no-destroy" data-id="4875655013" data-server="netease" data-type="playlist"   data-order="list" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true" ></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><div class="app-refresh" id="app-refresh" style="position: fixed;top: -2.2rem;left: 0;right: 0;z-index: 99999;padding: 0 1rem;font-size: 15px;height: 2.2rem;transition: all 0.3s ease;"><div class="app-refresh-wrap" style=" display: flex;color: #fff;height: 100%;align-items: center;justify-content: center;"><label>好像有什么动静</label><a href="javascript:void(0)" onclick="location.reload()"><span style="color: #fff;text-decoration: underline;cursor: pointer;">去看看</span></a></div></div><script>if ('serviceWorker' in navigator) {
if (navigator.serviceWorker.controller) {
navigator.serviceWorker.addEventListener('controllerchange', function() {
showNotification()
})
}
window.addEventListener('load', function() {
navigator.serviceWorker.register('/sw.js')
})
}
function showNotification() {
if (GLOBAL_CONFIG.Snackbar) {
var snackbarBg =
document.documentElement.getAttribute('data-theme') === 'light' ?
GLOBAL_CONFIG.Snackbar.bgLight :
GLOBAL_CONFIG.Snackbar.bgDark
var snackbarPos = GLOBAL_CONFIG.Snackbar.position
Snackbar.show({
text: '好像有什么动静',
backgroundColor: snackbarBg,
duration: 500000,
pos: snackbarPos,
actionText: '去看看',
actionTextColor: '#fff',
onActionClick: function(e) {
location.reload()
},
})
} else {
var showBg =
document.documentElement.getAttribute('data-theme') === 'light' ?
'#3b70fc' :
'#1f1f1f'
var cssText = `top: 0; background: ${showBg};`
document.getElementById('app-refresh').style.cssText = cssText
}
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__slideInRight');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><script async src="/js/ali_font.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>