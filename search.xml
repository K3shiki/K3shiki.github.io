<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【GDC】守望先锋的游戏架构和网络代码</title>
      <link href="/undefined/c1786556.html"/>
      <url>/undefined/c1786556.html</url>
      
        <content type="html"><![CDATA[<h1 id="【GDC】守望先锋的游戏架构和网络代码"><a href="#【GDC】守望先锋的游戏架构和网络代码" class="headerlink" title="【GDC】守望先锋的游戏架构和网络代码"></a>【GDC】守望先锋的游戏架构和网络代码</h1><p>在完成了上一个项目的网络部分后，想着在网上找找相关的资料，结果意外发现了我最喜欢的守望先锋的GDC。这篇演讲可以说是真正的宝藏，虽然并未完全揭露守望先锋的优秀代码是如何写成的（事实上这里只展示了冰山一角），但是看到有这种优秀的程序员为其努力，那结果也是理所当然的。</p><p>这篇演讲主要包含了两大部分：守望先锋的<strong><code>ECS</code>架构</strong>，以及网络代码。而在网络部分，则还是主要围绕着两大问题：<strong>预测回滚</strong>，以及<strong>服务器回溯</strong>。事实上，在任何网络游戏中，网络部分的主要工作都围绕着这两点展开，而最困难的问题则是如何在这两个基本思想下进行性能和游玩体验的优化。虽然是2017年的演讲，但是我认为其内容直到今天都值得学习。</p><p>翻译视频链接：【【青幻译制】GDC讲座系列之三 守望先锋的游戏架构和网络代码】 <a href="https://www.bilibili.com/video/BV1p4411k7N8">https://www.bilibili.com/video/BV1p4411k7N8</a></p><h2 id="1-ECS架构"><a href="#1-ECS架构" class="headerlink" title="1.ECS架构"></a>1.<code>ECS</code>架构</h2><h3 id="1-1-ECS"><a href="#1-1-ECS" class="headerlink" title="1.1 ECS"></a>1.1 <code>ECS</code></h3><p>这篇演讲的主旨是分享一些在不断增长的代码库中降低复杂度的方法，而这个方法的底层逻辑是严格遵守<strong><code>ECS</code>架构。</strong>何谓<code>ECS</code>架构？<code>ECS</code>是三个单词的简称：<strong><code>Enity</code>（实体）</strong>，<strong><code>Component</code>（组件）</strong>，<strong><code>System</code>（系统）</strong>，而整个架构就是围绕着这三部分展开。</p><p><img src="/undefined/c1786556/942c9d9724bf5f7ae255bb1ad74d6367.png" alt="img"></p><p>这是一张很经典的图，展现了<code>ECS</code>架构的大概面貌。游戏世界由一些系统和实体构成，而实体实际上就是一个对应着一组组件的<code>ID</code>。<strong>组件用于存储游戏状态，而不具备行为；系统具有行为，却不保存游戏状态</strong>。简单来说，组件没有函数（除了一些辅助函数），而系统没有成员变量。</p><p>对于系统，它不需要知道每一个实体的存在，它只需要对某些组件进行操作。当系统进行更新时，它会遍历所有的相关组件并对其进行操作，而由于实体实际上就是组件的集合，系统的这些操作就会自然而然地反映在实体上。演讲中举了一个例子：在守望先锋中，对于玩家联网系统，它会遍历联网组件，这个组件是在服务器上对应每个每个玩家连接的组件，它存在于玩家控制的实体中，包括游戏的参与者与旁观者，但是系统不关心这个。系统会读取联网组件的操作流和状态，确保玩家做出了一些事情，而当玩家一段时间没有行动时，系统就会发出挂机警告。从宏观上来看，系统做的事情就是操作所有的联网组件，根据情况对其发出挂机警告或者将其踢出游戏。所有拥有联网组件的实体（玩家）都会受到这一约束，而对于AI控制的实体，它们没有联网组件，所以不会收到挂机警告，也不会被踢出游戏。<strong>对于一个实体，当它具有行为所需的组件元组时，即会成为该行为的对象</strong>。</p><p>这种行为和状态分离的做法有什么好处？</p><h3 id="1-1-2-更好地使用ECS架构"><a href="#1-1-2-更好地使用ECS架构" class="headerlink" title="1.1.2 更好地使用ECS架构"></a>1.1.2 更好地使用<code>ECS</code>架构</h3><p>虽然<code>ECS</code>架构的思想比较容易理解，但是在实际的项目开发中必然存在着一些问题。</p><p>守望先锋中的输入系统是从非<code>ECS</code>架构的项目中迁移过来的，输入状态会被保存在输入系统中，任何对输入状态的访问可以通过一个指向输入系统的指针来实现。这听起来也不是不行，虽然它违反了“组件没有函数，系统没有状态”这条规则，但是由于输入状态只有一个实例，这样做似乎没什么破坏性，并且“只有在出现多个组件实例的时候才需要建立一个新的组件类型”是一个常见的思想。</p><p>但是这么做的后果就是，当一个系统需要查询输入状态的时候，它需要包含输入系统，这会增加编译时间；并且这种做法造成了一些耦合，将系统的行为暴露给了其它的系统。最致命的问题是，当守望先锋引入死亡回放时，回放的原理是创建一个新的<code>ECS</code>世界，服务器会传送回来一个8-12秒的数据包，然后转而渲染新的世界，将数据包用于世界的运行。在这种情况下，不再只有一个全局的实体管理，而是变成了两个，系统A无法直接访问系统B，只能通过共享的实体管理来访问系统B，这种做法十分难受。</p><p>经过团队一段时间的反省和复盘后，最终的解决方案是，<strong>在每个实体管理中定义仅存在一个实例的组件类型，称之为单例组件</strong>。单例组件的引入解决了“系统状态”带来的麻烦，减少了耦合以及随之而来的复杂度。</p><p>另一个问题是，有一些行为会在多个系统中被调用。对于这些具有共享行为的辅助函数，有一些规则。如果想要从不同的地方调用这个辅助函数，这个函数应该访问尽可能少的组件，并且最好只有很小的副作用或者没有副作用。如果由一个辅助函数读取了多个组件以及有不少副作用，应该尽可能少地调用它。</p><p>演讲中还分享了一些减少耦合的技巧。</p><p>“延迟”是指将执行具有明显副作用的行为所需的状态保存起来，将调用延迟到帧间某个单一的、更加合适的时间点。事实上，延迟是在任何性能优化中都被广泛运用的思想，例如单例模式的懒汉模式，以及对象拷贝。在守望先锋中，当子弹发生命中时会在命中位置产生特效，而这些特效之间也有不同的层级关系，总之，调用产生特效的函数的副作用是巨大的。如果每次命中都调用产生特效的代码，那么代码的复杂度会飞升，一旦修改了相关代码，所有调用这些代码的地方都需要进行测试。守望先锋中的做法是，当发生命中时，不直接调用产生特效的函数，而是在一个触碰的单例中增加一个相应的记录，在场景更新和渲染准备前，系统会遍历所有即将发生的触碰，根据多层次细节的规则、覆盖的规则等输生成特效。这样一来，每一帧只会调用一次产生特效的函数，代码的复杂度大大降低了，同时提升了性能和美术表现。</p><p>“遵照这些约束，意味着你必须通过一种特定的方式来解决问题，然而这些技术所带来的是持续的可维护、解耦以及简介的代码。我们限制你，把你扔进一个坑里，但这是一个通往成功的坑。”</p><h2 id="2-预测回滚"><a href="#2-预测回滚" class="headerlink" title="2.预测回滚"></a>2.预测回滚</h2><p>对于快速响应的网络动作游戏，必须预测玩家的行动，因为如果等着服务器来告诉玩家发生了什么事情是没法做到快速响应的。并且，不能在重要的模拟中信任客户端上除了输入以外的东西。</p><p>快速响应的需求是：当玩家按下按键的时候，要能立刻看到响应，即使是在高延迟的情况下。这是通过客户端的预测来实现的，而错误预测则是以服务器作为权威来验证以及网络延迟的副作用。在演讲提供的例子中，温斯顿在被小美冻住的前一瞬间跳了出去，然而这是在客户端预测的结果，服务器判断温斯顿最终被冻住了，因此在客户端上，温斯顿先是跳了出去，然后被拉回了原地并被冻住。</p><p>守望先锋的确定性模拟算法依赖于一个同步的时钟、固定间隔的更新以及离散化。服务器和客户端都根据同步的时钟以及离散化的值来进行操作。时间被离散化成称之为“命令帧”的单位，固定为16毫秒。在守望先锋的<code>ECS</code>架构中，然后模拟都是基于玩家的输入来进行的，游戏会在每一个命令帧中调用<code>UpdateFixed</code>函数来进行模拟。客户端在进行模拟的同时会将命令帧内的输入发送到服务器进行权威性模拟，时间间隔为半个<code>RTT</code>+缓存大小，而客户端收到服务器的权威模拟结果的时间为一个完整的<code>RTT</code>+缓存大小。</p><p><img src="/undefined/c1786556/image-20250901213405130.png" alt="image-20250901213405130"></p><p>如果客户端计算的结果和服务器一致，那么客户端继续继续模拟；如果不一致，那么出现了预测错误，需要进行调解。最简单的方法就是用服务器端的结果覆盖客户端的结果，但是毕竟服务器的结果是过去的，所以守望先锋的做法是不仅保存了运动状态的环状缓存，同时也保存了输入的环状缓存，因为角色移动的代码是非常确定性的，如果有一个起始运动状态，然后用输入去模拟运行，那么每一次都会得到相同的结果（实际上技能系统也是如此，但是技能不会被模拟）。当发生错误预测时，客户端会根据历史输入重新模拟从出错的时间一直到现在的状态。</p><p>接下来的问题是丢包。服务器有一小段<code>Buffer</code>用来缓存玩家的输入，而当<code>Buffer</code>中的输入用完了以后仍然没有新的输入，说明发生了丢包。这时，服务器会进行猜测，重复上一个输入，而当真正的输入到来时，服务器会进行调解来确保没有错过任何一次按键。与此同时，服务器会告诉客户端：“我没有收到输入”，而客户端收到这个消息后会加快模拟的速度，同时服务器的<code>Buffer</code>也会增大，来得到更多的输入，弥补数据的丢失，直到服务器意识到客户端恢复了正常，它会通知客户端，客户端会向另一个方向调整时间，使<code>Buffer</code>缩小，直到恢复正常。</p><p><img src="/undefined/c1786556/image-20250901213444217.png" alt="image-20250901213444217"></p><p>为了防止丢失因为服务器的猜测而被跳过的客户端的输入，客户端发送的不只是当前命令帧的输入，而是自从上一个已经得到服务器验证的运动状态之后的所有输入。</p><h2 id="3-服务器回溯"><a href="#3-服务器回溯" class="headerlink" title="3.服务器回溯"></a>3.服务器回溯</h2><p>对于射击游戏，通常会在本地进行命中预测，同时在服务器进行命中判定。然而，当角色瞄准的位置发送到服务器的时候，其瞄准的角色可能已经不在那了，因此需要将角色回溯到开火时的状态来进行验证。对于不同的游戏，进行回溯的方式不同。在我的上一个项目中，是直接在本地进行命中判定，然后将命中的角色发送到服务器，对特定的角色进行回溯，但是我并不认为这是一个好主意。在CS中，因为地图是固定的，并且只有10个玩家，角色的状态也比较简单，所以只需要将所有角色进行回溯即可。而守望先锋的做法在我看来充分体现了<code>ECS</code>架构的优势。在守望先锋中，不止玩家，有各种各样移动的物体，比如艾什的Bob，秩序之光的摄像头，运载目标以及沃斯卡亚工业区和66号公路的移动的浮板等。因为它们都可以移动，都有阻挡子弹的可能性，因此都应该被回溯。这听起来很麻烦，然而在<code>ECS</code>架构中，回溯系统只需要做一件事：对所有的运动组件进行回溯操作。这样一来，所有可能会移动并阻挡子弹的实体都会被回溯并实现正确的命中判定。</p><p>当然，如果每次射击都将所有移动组件进行回溯的话，肯定会有不少性能浪费。守望先锋中使用了一个巧妙的优化方式：使用包围框表示所有运动组件在倒带范围内可能的移动范围。只有射线和包围框发生碰撞时才会进行相应的回溯。在碰撞检测中，先判断有没有命中大的包围盒再进行具体判断是很常见的操作（如AABB盒），但是将其在服务器回溯盒命中判定中进行实现真的很酷。</p><p><img src="/undefined/c1786556/image-20250901202522079.png" alt="image-20250901202522079"></p><p>和常见的做法一样，当客户端的延迟过高时，服务器只会回溯一段时间，然后通过预测来进行命中判断，防止躲到掩体后仍然被命中的情况太过严重。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【UE5】多人联机TPS游戏开发（四） ——  延迟补偿</title>
      <link href="/undefined/af2b6aaf.html"/>
      <url>/undefined/af2b6aaf.html</url>
      
        <content type="html"><![CDATA[<h1 id="【UE5】多人联机TPS游戏开发（四）-——-延迟补偿"><a href="#【UE5】多人联机TPS游戏开发（四）-——-延迟补偿" class="headerlink" title="【UE5】多人联机TPS游戏开发（四） ——  延迟补偿"></a>【UE5】多人联机TPS游戏开发（四） ——  延迟补偿</h1><blockquote><p>不知道为什么，最近脑子里经常响起《月光》的旋律，每当这时，因为压力而烦躁的内心都会慢慢平静下来。大概是因为被《恶灵附身》吓得失去生命体征了吧。</p><p>作为涉猎广泛的FPS老玩家，受到垃圾的网络环境的影响应该算是必经之路了。至今仍然记得初中顶着一百多毫秒延迟打OW在地图里乱飘的烦躁，还有躲到墙后仍然被打死的无语。之前只是知道有这些现象，却完全不知道是什么原理，而现在却要自己动手尝试解决这些问题了，想到这里，不由得感到一阵恍惚，时间如流水啊。</p><p>可能是马上要面临的压力让我变得有些多愁善感了吧。总之，接下来将要着手解决（减轻）高延迟带来的游戏体验问题。当然，对于目前已经比较成熟的FPS竞技游戏品类，即使已经有数不清的方案被用来解决延迟问题，尚且不能完美达成目的，本项目所用到的只是最基础的几个而已，肯定还是有很大的缺陷。然而，千里之行始于足下，只要像这样持续去学习，又有什么是学不会的呢？反正这段时间我是学爽了。</p></blockquote><h2 id="1-延迟补偿"><a href="#1-延迟补偿" class="headerlink" title="1.延迟补偿"></a>1.延迟补偿</h2><p>自多人游戏诞生以来，网络延迟就是一个无法绕过的难题。对于不同的游戏品类，其对网络条件的要求是不同的，而<code>FPS</code>竞技游戏（虽然本项目是<code>TPS</code>就是了）则是其中对网络要求最高的品类之一。而网络问题又包括延迟、丢包、抖动等，本项目着重讨论的是延迟问题。</p><p>说实话，想要完全消除延迟是几乎不可能的事，除非哪天真的发明出了低成本的零延迟通讯技术，否则就只能想方设法在软件层面上找补。本项目使用了两个技术：<strong>客户端预测+服务器修正</strong>，以及<strong>服务器倒带</strong>，尽量降低延迟对玩家的影响。</p><p>为了模拟高延迟的情况，在<code>Config/DefaultEngine.ini</code>中进行相应配置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[PacketSimulationSettings]</span></span><br><span class="line"><span class="attr">PktLag</span> = <span class="number">200</span></span><br></pre></td></tr></table></figure><p>在本文的最后一部分将会讨论<code>Valve</code>使用的延迟补偿技术，看看真正的游戏的做法是什么样的。</p><h2 id="2-延迟检测"><a href="#2-延迟检测" class="headerlink" title="2.延迟检测"></a>2.延迟检测</h2><p><code>UE</code>引擎内置了获取延迟的功能，那为什么不直接用呢？</p><p><code>HUD</code>部分依然放在<code>CharacterOverlay</code>中处理。包含一个图像以及一个动画，动画控制图像的闪烁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CharacterOverlay.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(meta = (BindWidget))</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UImage</span>* HighPingImage;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(meta = (BindWidgetAnim), Transient)</span><br><span class="line">UWidgetAnimation* HighPingAnimation;</span><br></pre></td></tr></table></figure><p>在<code>Tick</code>中运行检查函数，当检查间隔到达一定时间后检查<code>Ping</code>，通过<code>GetCompressedPing()*4</code>获得客户端的<code>Ping</code>值，如果<code>Ping</code>高于门槛，就触发提示，播放动画。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MPTPSPlayerController.h</span></span><br><span class="line"><span class="type">float</span> HighPingRunningTime = <span class="number">0.f</span>; <span class="comment">//Ping检查间隔时间</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line"><span class="type">float</span> HighPingDuration = <span class="number">5.f</span>; <span class="comment">//高延迟提醒持续时间</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> PingAnimationRunningTime = <span class="number">0.f</span>; <span class="comment">//高延迟提醒运行时间</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line"><span class="type">float</span> CheckPingFrequency = <span class="number">5.f</span>; <span class="comment">//Ping的检查频率</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line"><span class="type">float</span> HighPingThreshold = <span class="number">50.f</span>; <span class="comment">//高Ping门槛</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MPTPSPlayerController.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::CheckPing</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HighPingRunningTime += DeltaTime;</span><br><span class="line"><span class="keyword">if</span> (HighPingRunningTime &gt; CheckPingFrequency) &#123;</span><br><span class="line">PlayerState = PlayerState == <span class="literal">nullptr</span> ? <span class="built_in">GetPlayerState</span>&lt;AMultiplayerTPSPlayerState&gt;() : PlayerState;</span><br><span class="line"><span class="keyword">if</span> (PlayerState) &#123;</span><br><span class="line"><span class="keyword">if</span> (PlayerState-&gt;<span class="built_in">GetCompressedPing</span>() * <span class="number">4</span> &gt; HighPingThreshold) &#123; <span class="comment">//得到的Ping是压缩的，要*4</span></span><br><span class="line"><span class="built_in">HighPingWarning</span>();</span><br><span class="line">PingAnimationRunningTime = <span class="number">0.f</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">HighPingRunningTime = <span class="number">0.f</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (MultiplayerTPSHUD &amp;&amp;</span><br><span class="line">MultiplayerTPSHUD-&gt;CharacterOverlay &amp;&amp;</span><br><span class="line">MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HighPingAnimation &amp;&amp;</span><br><span class="line">MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;<span class="built_in">IsAnimationPlaying</span>(MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HighPingAnimation))</span><br><span class="line">&#123;</span><br><span class="line">PingAnimationRunningTime += DeltaTime;</span><br><span class="line"><span class="keyword">if</span> (PingAnimationRunningTime &gt; HighPingDuration) &#123;</span><br><span class="line"><span class="built_in">StopHighPingWarning</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::HighPingWarning</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MultiplayerTPSHUD = MultiplayerTPSHUD == <span class="literal">nullptr</span> ? <span class="built_in">Cast</span>&lt;AMultiplayerTPSHUD&gt;(<span class="built_in">GetHUD</span>()) : MultiplayerTPSHUD;</span><br><span class="line"><span class="keyword">if</span> (MultiplayerTPSHUD &amp;&amp; MultiplayerTPSHUD-&gt;CharacterOverlay &amp;&amp; MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HighPingImage &amp;&amp; MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HighPingAnimation) &#123;</span><br><span class="line">MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HighPingImage-&gt;<span class="built_in">SetOpacity</span>(<span class="number">1.f</span>);</span><br><span class="line">MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;<span class="built_in">PlayAnimation</span>(MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HighPingAnimation, <span class="number">0.f</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::StopHighPingWarning</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MultiplayerTPSHUD = MultiplayerTPSHUD == <span class="literal">nullptr</span> ? <span class="built_in">Cast</span>&lt;AMultiplayerTPSHUD&gt;(<span class="built_in">GetHUD</span>()) : MultiplayerTPSHUD;</span><br><span class="line"><span class="keyword">if</span> (MultiplayerTPSHUD &amp;&amp; MultiplayerTPSHUD-&gt;CharacterOverlay &amp;&amp; MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HighPingImage &amp;&amp; MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HighPingAnimation) &#123;</span><br><span class="line">MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HighPingImage-&gt;<span class="built_in">SetOpacity</span>(<span class="number">0.f</span>);</span><br><span class="line"><span class="keyword">if</span> (MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;<span class="built_in">IsAnimationPlaying</span>(MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HighPingAnimation)) &#123;</span><br><span class="line">MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;<span class="built_in">StopAnimation</span>(MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HighPingAnimation);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-客户端预测-服务器修正"><a href="#3-客户端预测-服务器修正" class="headerlink" title="3.客户端预测+服务器修正"></a>3.客户端预测+服务器修正</h2><p>在理想的情况下，客户端的一切操作都应该提交到服务器上，由服务器进行处理后将更新后的状态发送回客户端，这样能完全保证服务器权威。然而，以目前的网络发展水平，这样做是不可接受的，因为玩家的一切操作都要经过网络延迟后才能产生效果，对玩家的游戏体验来说具有极大的破坏性，尤其是那些高延迟的玩家。</p><p>客户端预测+服务器修正就是用来解决这个问题的。它的思想是，<strong>对于那些相对不想要那么高权威性的操作，客户端在将操作发往服务器的同时直接在本地执行这些操作</strong>，这一步为<strong>预测</strong>；而<strong>服务器收到客户端的操作并进行处理后将更新后的状态发送给客户端，此时如果该状态和客户端自己执行后的状态不同，就用服务器回复给客户端的状态将客户端自己的状态覆盖掉</strong>，这一步为<strong>修正</strong>。以移动为例，假如客户端的玩家向右移动了10米，但是因为某些原因，服务器收到的操作是玩家向右移动了5米，那么在客户端看来，玩家在收到操作指令后立即向右移动了10米，但随后服务器的计算结果来了，玩家就会被强行移动的左边5米的位置。</p><p>这个方法面临着一个问题：<strong>要对每一次操作都进行修正吗？</strong>同样以移动为例，客户端的玩家向右移动了10米，当这个操作发送到服务器进行处理后，服务器会将处理后的状态发送给客户端，然而如果客户端的玩家在此期间又向右移动了10米，那么当服务器的回复到达客户端时，客户端的玩家角色会被恢复到向右10米的位置，而当下一次服务器的操作处理结果到达时，客户端的玩家角色又被恢复到向右20米的位置。这显然是不合常理的。</p><p>对于这个问题，解决方案是：<strong>客户端每次将操作发送出去时，将这些发送记录保存下来，当收到服务器的回复时，首先检查保存的记录中有没有符合的操作，如果有，说明这次回复对应的是之前的操作，不需要进行修正；如果没有，则进行修正</strong>。</p><p>对于本项目，就有一个非常适合应用这项技术的地方：弹药消耗。</p><p>在之前的实现中，当进行开火时，会通过<code>RPC</code>在所有客户端上进行开火操作，而只有在服务器上才能进行消耗子弹的操作，当子弹数量改变后会通过复制同步到客户端，并在回调函数中进行<code>HUD</code>更新。在这种做法下，当延迟很高的时候，就会发现开火与子弹数量改变之间有很明显的时间差。</p><p>首先要去除<code>Ammo</code>变量的复制。弹药是一个整型变量，因此可以简单地用一个变量<code>Sequence</code>来记录对<code>Ammo</code>的操作记录。在<code>SpendRound</code>函数中，不再限制只有服务器能修改<code>Ammo</code>，取而代之的是，如果在客户端，将<code>Sequence</code>加1表示客户端消耗了一枚弹药。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AWeapon::SpendRound</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Ammo = FMath::<span class="built_in">Clamp</span>(Ammo - <span class="number">1</span>, <span class="number">0</span>, MagCapacity);</span><br><span class="line"><span class="built_in">SetHUDAmmo</span>();</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">HasAuthority</span>()) &#123;</span><br><span class="line"><span class="built_in">ClientUpdateAmmo</span>(Ammo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">++Sequence;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在服务器，会调用<code>Client RPC</code>进行客户端<code>Ammo</code>变量的检查和修正。更新弹药值后将<code>Sequence</code>减1，表示这次更新对应了客户端的一次操作，然后根据<code>Sequence</code>进行客户端<code>Ammo</code>的修正。最后在客户端更新<code>HUD</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AWeapon::ClientUpdateAmmo_Implementation</span><span class="params">(int32 ServerAmmo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">HasAuthority</span>()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Ammo = ServerAmmo;</span><br><span class="line">--Sequence;</span><br><span class="line">Ammo -= Sequence;</span><br><span class="line"><span class="built_in">SetHUDAmmo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是客户端预测+服务器修正的基础运用。换弹也可以用同样的方式进行优化，因为这篇文章聚焦于技术原理，就不具体展示了。</p><h2 id="4-服务器倒带"><a href="#4-服务器倒带" class="headerlink" title="4.服务器倒带"></a>4.服务器倒带</h2><h3 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h3><p>在多人游戏中，我们很少注意到的一件事情是：<strong>玩家看到的一切都存在于过去（监听服务器除外）</strong>。因为只有服务器上的游戏状态是权威的，而无论是客户端向服务器发送自己的操作，还是服务器向所有客户端同步权威的游戏状态，都需要一定的时间，所以客户端看到的永远都是一段时间之前的游戏状态。对于<code>FPS</code>竞技游戏，这件事的后果就是：玩家看到了一个敌人，进行瞄准并射击，这个操作会被发送到服务器进行判定。然而对于服务器，当其收到客户端的瞄准操作时，客户端瞄准的那个玩家可能已经不在那个位置了，这时客户端得到的结果自然是未命中。延迟越高，这种情况就越明显，而这显然是不可接受的。</p><p><img src="/undefined/af2b6aaf/image-20250813222726592.png" alt="image-20250813222726592"></p><p><strong>服务器倒带</strong>就是用来解决这个问题的。服务器倒带的思想时，<strong>当客户端请求进行射击的判定时，服务器不会直接使用目标当前的状态，而是会使用目标在客户端射击时的状态进行判定</strong>。服务器倒带的核心是：<strong>记录所有玩家一定时间内的必要信息，用于在客户端射击时进行回溯，判断射击是否命中</strong>。这正是<code>FPS</code>竞技游戏中出现“明明躲到了掩体后面却被击杀”这种情况的原因。而<strong>为了避免这种情况出现得过于频繁和离谱，游戏需要对服务器倒带的范围进行一些限制</strong>，不然就太偏向于高延迟玩家，而破坏了低延迟玩家的体验了。</p><h3 id="4-2-角色历史信息保存"><a href="#4-2-角色历史信息保存" class="headerlink" title="4.2 角色历史信息保存"></a>4.2 角色历史信息保存</h3><p>上面说到，服务器倒带需要记录所有玩家一定时间内的必要信息。那么问题来了：<strong>所谓的“必要信息”是什么</strong>？位置？但是目标可能会蹲下，可能会跳跃，可能在做各种动作，只记录位置的话无法做到精确的判定。整个网格体？这样确实很精确，但是开销实在是太大了，尤其是在可能要存几百个记录的情况下。</p><p>目前的主流做法是，<strong>将玩家用一些命中盒(<code>HitBox</code>)来进行表示</strong>，这样既能相对精确地表示出模型的状态，又能节省资源，并且能直接进行爆头等命中特殊部位的判定，可以说是一举多得。</p><p>本项目中的角色用线框表示的结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于服务器倒带的HitBox</span></span><br><span class="line"><span class="comment">//为了保持命名和骨骼名称相同，不使用首字母大写</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UBoxComponent</span>* head;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UBoxComponent* pelvis;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UBoxComponent* spine_02;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UBoxComponent* spine_03;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UBoxComponent* upperarm_l;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UBoxComponent* upperarm_r;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UBoxComponent* lowerarm_l;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UBoxComponent* lowerarm_r;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UBoxComponent* hand_l;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UBoxComponent* hand_r;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UBoxComponent* backpack;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UBoxComponent* blanket;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UBoxComponent* thigh_l;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UBoxComponent* thigh_r;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UBoxComponent* calf_l;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UBoxComponent* calf_r;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UBoxComponent* foot_l;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UBoxComponent* foot_r;</span><br></pre></td></tr></table></figure><p>初始将这些命中盒和角色的骨骼进行绑定，并设置为无碰撞。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">head = <span class="built_in">CreateDefaultSubobject</span>&lt;UBoxComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;head&quot;</span>));</span><br><span class="line">head-&gt;<span class="built_in">SetupAttachment</span>(<span class="built_in">GetMesh</span>(), <span class="built_in">FName</span>(<span class="string">&quot;head&quot;</span>));</span><br><span class="line">head-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);</span><br><span class="line"></span><br><span class="line">pelvis = <span class="built_in">CreateDefaultSubobject</span>&lt;UBoxComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;pelvis&quot;</span>));</span><br><span class="line">pelvis-&gt;<span class="built_in">SetupAttachment</span>(<span class="built_in">GetMesh</span>(), <span class="built_in">FName</span>(<span class="string">&quot;pelvis&quot;</span>));</span><br><span class="line">pelvis-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="/undefined/af2b6aaf/image-20250807165704097.png" alt="image-20250807165704097"></p><p>对于服务器倒带的相关逻辑，我想放在一起统一处理，所以我创建了一个<code>Actor</code>组件<code>LagCompensationComponent</code>。在其中声明两个结构体，分别用来保存命中盒自身的信息和角色的所有命中盒以及时间的信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">USTRUCT</span>(BlueprintType)</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FBoxInformation</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line">FVector Location;</span><br><span class="line"></span><br><span class="line">FVector Rotation;</span><br><span class="line"></span><br><span class="line">FVector BoxExtent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">USTRUCT</span>(BlueprintType)</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FFramePackage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Time;</span><br><span class="line"></span><br><span class="line">TMap&lt;FName, FBoxInformation&gt; HitBoxInfo;</span><br><span class="line">    </span><br><span class="line">    AMultiplayerTPSCharacter* Character;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在角色类中进行初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">LagCompensation = <span class="built_in">CreateDefaultSubobject</span>&lt;ULagCompensationComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;LagCompensation&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::PostInitializeComponents</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">PostInitializeComponents</span>();</span><br><span class="line"><span class="comment">//初始化CombatComponent</span></span><br><span class="line">... </span><br><span class="line"><span class="comment">//初始化BuffComponent</span></span><br><span class="line">... </span><br><span class="line"><span class="comment">//初始化LagCompensationComponent</span></span><br><span class="line"><span class="keyword">if</span> (LagCompensation) &#123;</span><br><span class="line">LagCompensation-&gt;Character = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">if</span> (Controller) &#123;</span><br><span class="line">LagCompensation-&gt;Controller = <span class="built_in">Cast</span>&lt;AMPTPSPlayerController&gt;(Controller);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个<code>TMap</code>，用来保存所有的命中盒信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>()</span><br><span class="line">TMap&lt;FName, UBoxComponent*&gt; HitCollisionBoxes;</span><br><span class="line"></span><br><span class="line">HitCollisionBoxes.<span class="built_in">Add</span>(<span class="built_in">FName</span>(<span class="string">&quot;head&quot;</span>), head);</span><br></pre></td></tr></table></figure><p>在<code>LagCompensationComponent</code>中定义用来保存当前帧的所有角色命中盒信息的函数以及绘制命中盒的函数。在<code>BeginPlay</code>中保存并绘制，就能看到命中盒在游戏中的样子了（我承认头确实有点大了）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ULagCompensationComponent::SaveFramePackage</span><span class="params">(FFramePackage&amp; Package)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Character) &#123;</span><br><span class="line">Package.Time = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetTimeSeconds</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; BoxPair : Character-&gt;HitCollisionBoxes) &#123;</span><br><span class="line">FBoxInformation BoxInformation;</span><br><span class="line">BoxInformation.Location = BoxPair.Value-&gt;<span class="built_in">GetComponentLocation</span>();</span><br><span class="line">BoxInformation.Rotation = BoxPair.Value-&gt;<span class="built_in">GetComponentRotation</span>();</span><br><span class="line">BoxInformation.BoxExtent = BoxPair.Value-&gt;<span class="built_in">GetScaledBoxExtent</span>();</span><br><span class="line">Package.HitBoxInfo.<span class="built_in">Add</span>(BoxPair.Key, BoxInformation);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ULagCompensationComponent::ShowFramePackage</span><span class="params">(<span class="type">const</span> FFramePackage&amp; Package, FColor Color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; BoxInfo:Package.HitBoxInfo) &#123;</span><br><span class="line"><span class="built_in">DrawDebugBox</span>(</span><br><span class="line"><span class="built_in">GetWorld</span>(),</span><br><span class="line">BoxInfo.Value.Location,</span><br><span class="line">BoxInfo.Value.BoxExtent,</span><br><span class="line"><span class="built_in">FQuat</span>(BoxInfo.Value.Rotation),</span><br><span class="line">Color,</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/undefined/af2b6aaf/image-20250807165731876.png" alt="image-20250807165731876"></p><p>接下来的问题是，要如何保存一定时间范围内的命中盒信息？</p><p>想象一下，随着时间的流逝，我们需要不断保存新的命中盒信息，同时丢弃那些超出服务器倒带范围的命中盒信息，这代表着<strong>要在数据结构的两端进行频繁增删</strong>；同时因为要按时间进行回溯，所以<strong>这些命中盒信息必须是有序的</strong>。而满足这些要求的数据结构正是<strong>双向链表</strong>。</p><p>在组件中声明一个保存命中盒信息的双向链表，同时声明服务器倒带的最长回溯时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TDoubleLinkedList&lt;FFramePackage&gt; FrameHistory;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line"><span class="type">float</span> MaxRecordTime = <span class="number">4.f</span>;</span><br></pre></td></tr></table></figure><p>在<code>Tick</code>中保存每一帧的命中盒信息，同时如果双向链表尾部的节点已经超出了回溯范围，将其丢弃。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ULagCompensationComponent::TickComponent</span><span class="params">(<span class="type">float</span> DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">TickComponent</span>(DeltaTime, TickType, ThisTickFunction);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (FrameHistory.<span class="built_in">Num</span>() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">FrameHistory.<span class="built_in">AddHead</span>(<span class="built_in">FFramePackage</span>());</span><br><span class="line"><span class="built_in">SaveFramePackage</span>(FrameHistory.<span class="built_in">GetHead</span>()-&gt;<span class="built_in">GetValue</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">float</span> HistoryLength = FrameHistory.<span class="built_in">GetHead</span>()-&gt;<span class="built_in">GetValue</span>().Time - FrameHistory.<span class="built_in">GetTail</span>()-&gt;<span class="built_in">GetValue</span>().Time;</span><br><span class="line"><span class="keyword">while</span> (HistoryLength &gt; MaxRecordTime) &#123;</span><br><span class="line">FrameHistory.<span class="built_in">RemoveNode</span>(FrameHistory.<span class="built_in">GetTail</span>());</span><br><span class="line">HistoryLength = FrameHistory.<span class="built_in">GetHead</span>()-&gt;<span class="built_in">GetValue</span>().Time - FrameHistory.<span class="built_in">GetTail</span>()-&gt;<span class="built_in">GetValue</span>().Time;</span><br><span class="line">&#125;</span><br><span class="line">FrameHistory.<span class="built_in">AddHead</span>(<span class="built_in">FFramePackage</span>());</span><br><span class="line"><span class="built_in">SaveFramePackage</span>(FrameHistory.<span class="built_in">GetHead</span>()-&gt;<span class="built_in">GetValue</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">ShowFramePackage</span>(FrameHistory.<span class="built_in">GetHead</span>()-&gt;<span class="built_in">GetValue</span>(), FColor::Red);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将这些命中盒绘制出来就可以看到效果了。在实际体验中，可以感觉到这种保存方式对游戏流畅性的影响基本没有。</p><p><img src="/undefined/af2b6aaf/image-20250807173747265.png" alt="image-20250807173747265"></p><p>为了方便进行检测命中盒，新建了一个碰撞通道<code>HitBox</code>，并定义了一个宏：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define ECC_HitBox ECollisionChannel::ECC_GameTraceChannel2</span><br></pre></td></tr></table></figure><p>在构造角色时遍历角色的TMap，设置每一个HitBox的碰撞通道。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; Box : HitCollisionBoxes) &#123;</span><br><span class="line">Box.Value-&gt;<span class="built_in">SetCollisionObjectType</span>(ECC_HitBox);</span><br><span class="line">Box.Value-&gt;<span class="built_in">SetCollisionResponseToAllChannels</span>(ECollisionResponse::ECR_Ignore);</span><br><span class="line">Box.Value-&gt;<span class="built_in">SetCollisionResponseToChannel</span>(ECC_HitBox, ECollisionResponse::ECR_Block);</span><br><span class="line">Box.Value-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-倒带"><a href="#4-3-倒带" class="headerlink" title="4.3 倒带"></a>4.3 倒带</h3><p>然后就是服务器倒带最重要的部分：倒带的实现了。</p><p>声明一个结构体，保存服务器倒带的检查结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">USTRUCT</span>(BlueprintType)</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FServerSideRewindResult</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> bHitConfirmed;</span><br><span class="line"><span class="type">bool</span> bHeadShot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先从<code>HitScanWeapon</code>开始，讲解一遍服务器倒带的流程。</p><blockquote><p>上一篇中我自己挖的坑在这里被我自己踩了。为了杜绝作弊，我的做法是由服务器计算散布并进行检测，结果到了这里，客户端就无法提供命中的角色，也就无法通过这种方式实现服务器倒带了。</p><p>但是我想到了一个方法：只要将所有角色的命中盒进行倒带，不就能直接检测并且不需要提供命中角色了吗？而对于这种小体量并且玩家数不多的游戏，这种代价应该是可以接受的。</p><p>不过这里还是得到了教训：做之前先多了解目前已经成熟的技术方案，不要脑子一热觉得自己想到了什么盲点（哪怕是问了AI）。</p><p>下面介绍的是正常的服务器倒带实现方法。</p></blockquote><p>当客户端角色开火后，不再将判定都交由服务器进行处理，而是直接在本地进行射线检测。如果检测到命中了敌方角色，则将命中的角色作为参数传给服务器进行服务器倒带。其它参数分别是射击起始位置（枪口<code>Socket</code>），命中位置，命中时间，以及发起角色。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MultiplayerTPSOwnerCharacter-&gt;<span class="built_in">GetLagCompensation</span>()-&gt;<span class="built_in">ServerScoreRequest</span>(</span><br><span class="line">MultiplayerTPSCharacter,</span><br><span class="line">Start,</span><br><span class="line">HitTarget,</span><br><span class="line">MultiplayerTPSOwnerController-&gt;<span class="built_in">GetServerTime</span>()-MultiplayerTPSOwnerController-&gt;SingleTripTime, <span class="comment">//射击时间是服务器时间减去单程通信时间。</span></span><br><span class="line"><span class="keyword">this</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>服务器会根据这些参数判断是否成功命中。首先判断命中时间是否超出了最大倒带范围，如果命中时间在双向链表尾部节点的时间之前，直接返回空结果。接下来寻找两个目标节点，使得命中时间在这两个目标节点的时间时间，然后通过插值的方式获取命中时间时对应的所有命中盒信息。</p><p>获得了要检查的命中盒后，接下来的过程就简单了。先将角色当前的命中盒信息保存下来，然后将角色的命中盒更改为要检测的命中盒，并关闭角色网格体的碰撞。这时候就可以进行射线检测了。首先开启头部命中盒的碰撞，检测后如果命中，说明命中了头部，直接返回结果，否则关闭头部命中盒的同时开启其它命中盒的碰撞进行检测，如果命中则返回结果。最终返回未命中的结果。在任何返回前记得将角色的命中盒、网格体碰撞以及碰撞盒的碰撞改为原样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ULagCompensationComponent::ServerScoreRequest_Implementation</span><span class="params">(AMultiplayerTPSCharacter* HitCharacter, <span class="type">const</span> FVector_NetQuantize&amp; TraceStart, <span class="type">const</span> FVector_NetQuantize&amp; HitLocation, <span class="type">float</span> HitTime, AWeapon* DamageCasuer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FServerSideRewindResult Confirm = <span class="built_in">ServerSideRewind</span>(HitCharacter, TraceStart, HitLocation, HitTime);</span><br><span class="line"><span class="keyword">if</span> (Character &amp;&amp; HitCharacter &amp;&amp; Confirm.bHitConfirmed &amp;&amp; DamageCasuer) &#123;</span><br><span class="line">UGameplayStatics::<span class="built_in">ApplyDamage</span>(</span><br><span class="line">HitCharacter,</span><br><span class="line">DamageCasuer-&gt;<span class="built_in">GetDamage</span>(),</span><br><span class="line">Character-&gt;Controller,</span><br><span class="line">DamageCasuer,</span><br><span class="line">UDamageType::<span class="built_in">StaticClass</span>()</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FServerSideRewindResult <span class="title">ULagCompensationComponent::ServerSideRewind</span><span class="params">(AMultiplayerTPSCharacter* HitCharacter, <span class="type">const</span> FVector_NetQuantize&amp; TraceStart, <span class="type">const</span> FVector_NetQuantize&amp; HitLocation, <span class="type">float</span> HitTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FFramePackage FrameToCheck = <span class="built_in">GetFrameToCheck</span>(HitCharacter, HitTime);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">ConfirmHit</span>(FrameToCheck, HitCharacter, TraceStart, HitLocation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FFramePackage <span class="title">ULagCompensationComponent::GetFrameToCheck</span><span class="params">(AMultiplayerTPSCharacter* HitCharacter, <span class="type">float</span> HitTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">bool</span> bReturn = !HitCharacter || !HitCharacter-&gt;LagCompensation || !HitCharacter-&gt;LagCompensation-&gt;FrameHistory.<span class="built_in">GetHead</span>() || !HitCharacter-&gt;LagCompensation-&gt;FrameHistory.<span class="built_in">GetTail</span>();</span><br><span class="line"><span class="keyword">if</span> (bReturn) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">FFramePackage</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FFramePackage FrameToCheck; <span class="comment">//最终用来检查是否命中的FramePackage</span></span><br><span class="line">FrameToCheck.Character = HitCharacter;</span><br><span class="line"><span class="type">const</span> TDoubleLinkedList&lt;FFramePackage&gt;&amp; History = HitCharacter-&gt;LagCompensation-&gt;FrameHistory;</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> OldestHistoryTime = History.<span class="built_in">GetTail</span>()-&gt;<span class="built_in">GetValue</span>().Time;</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> NewestHistoryTime = History.<span class="built_in">GetHead</span>()-&gt;<span class="built_in">GetValue</span>().Time;</span><br><span class="line"><span class="keyword">if</span> (OldestHistoryTime &gt; HitTime) &#123;</span><br><span class="line"><span class="comment">//命中时间超过了倒带的最远时间</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">FFramePackage</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (NewestHistoryTime &lt;= HitTime) &#123;</span><br><span class="line">FrameToCheck = History.<span class="built_in">GetHead</span>()-&gt;<span class="built_in">GetValue</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> Younger = History.<span class="built_in">GetHead</span>();</span><br><span class="line"><span class="keyword">auto</span> Older = Younger;</span><br><span class="line"><span class="keyword">while</span> (Older-&gt;<span class="built_in">GetValue</span>().Time &gt; HitTime) &#123;</span><br><span class="line"><span class="comment">//目标：OlderTime &lt; HitTime &lt; YoungerTime</span></span><br><span class="line"><span class="keyword">if</span> (!Older-&gt;<span class="built_in">GetNextNode</span>()) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">Older = Older-&gt;<span class="built_in">GetNextNode</span>();</span><br><span class="line"><span class="keyword">if</span> (Older-&gt;<span class="built_in">GetValue</span>().Time &gt; HitTime) &#123;</span><br><span class="line">Younger = Older;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">FrameToCheck = <span class="built_in">InterpBetweenFrames</span>(Older-&gt;<span class="built_in">GetValue</span>(), Younger-&gt;<span class="built_in">GetValue</span>(), HitTime);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> FrameToCheck;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FFramePackage <span class="title">ULagCompensationComponent::InterpBetweenFrames</span><span class="params">(<span class="type">const</span> FFramePackage&amp; OlderFrame, <span class="type">const</span> FFramePackage&amp; YoungerFrame, <span class="type">float</span> HitTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> Distance = YoungerFrame.Time - OlderFrame.Time;</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> InterpFraction = FMath::<span class="built_in">Clamp</span>((HitTime - OlderFrame.Time) / Distance, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">FFramePackage InterpFramePackage;</span><br><span class="line">InterpFramePackage.Character = OlderFrame.Character;</span><br><span class="line">InterpFramePackage.Time = HitTime;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; YoungerPair : YoungerFrame.HitBoxInfo) &#123;</span><br><span class="line"><span class="type">const</span> FName&amp; BoxInfoName = YoungerPair.Key;</span><br><span class="line"><span class="type">const</span> FBoxInformation&amp; OlderBox = OlderFrame.HitBoxInfo[BoxInfoName];</span><br><span class="line"><span class="comment">//const FBoxInformation&amp; YoungerBox = YoungerFrame.HitBoxInfo[BoxInfoName];</span></span><br><span class="line"><span class="type">const</span> FBoxInformation&amp; YoungerBox = YoungerPair.Value;</span><br><span class="line"></span><br><span class="line">FBoxInformation InterpBoxInfo;</span><br><span class="line">InterpBoxInfo.Location = FMath::<span class="built_in">VInterpTo</span>(OlderBox.Location, YoungerBox.Location, <span class="number">1.f</span>, InterpFraction);</span><br><span class="line">InterpBoxInfo.Rotation = FMath::<span class="built_in">RInterpTo</span>(OlderBox.Rotation, YoungerBox.Rotation, <span class="number">1.f</span>, InterpFraction);</span><br><span class="line">InterpBoxInfo.BoxExtent = YoungerBox.BoxExtent;</span><br><span class="line"></span><br><span class="line">InterpFramePackage.HitBoxInfo.<span class="built_in">Add</span>(BoxInfoName, InterpBoxInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> InterpFramePackage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FServerSideRewindResult <span class="title">ULagCompensationComponent::ConfirmHit</span><span class="params">(<span class="type">const</span> FFramePackage&amp; Package, AMultiplayerTPSCharacter* HitCharacter, <span class="type">const</span> FVector_NetQuantize&amp; TraceStart, <span class="type">const</span> FVector_NetQuantize&amp; HitLocation)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!HitCharacter) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">FServerSideRewindResult</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FFramePackage CurrentFrame;</span><br><span class="line"><span class="built_in">CacheBoxPositions</span>(HitCharacter, CurrentFrame);</span><br><span class="line"><span class="built_in">MoveBoxes</span>(HitCharacter, Package);</span><br><span class="line"><span class="built_in">EnableCharacterMeshCollision</span>(HitCharacter, ECollisionEnabled::NoCollision);</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先启用头部碰撞</span></span><br><span class="line">UBoxComponent* HeadBox = HitCharacter-&gt;HitCollisionBoxes[<span class="built_in">FName</span>(<span class="string">&quot;head&quot;</span>)];</span><br><span class="line">HeadBox-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::QueryAndPhysics);</span><br><span class="line">HeadBox-&gt;<span class="built_in">SetCollisionResponseToChannel</span>(ECC_HitBox, ECollisionResponse::ECR_Block);</span><br><span class="line"></span><br><span class="line">FHitResult ConfirmHitResult;</span><br><span class="line"><span class="type">const</span> FVector TraceEnd = TraceStart + (HitLocation - TraceStart) * <span class="number">1.25f</span>;</span><br><span class="line">UWorld* World = <span class="built_in">GetWorld</span>();</span><br><span class="line"><span class="keyword">if</span> (World) &#123;</span><br><span class="line">World-&gt;<span class="built_in">LineTraceSingleByChannel</span>(</span><br><span class="line">ConfirmHitResult,</span><br><span class="line">TraceStart,</span><br><span class="line">TraceEnd,</span><br><span class="line">ECC_HitBox</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ConfirmHitResult.bBlockingHit) &#123; <span class="comment">//如果命中，说明命中了头部，提前返回，将角色的HitBox移回原位</span></span><br><span class="line"><span class="built_in">ResetBoxes</span>(HitCharacter, CurrentFrame);</span><br><span class="line"><span class="built_in">EnableCharacterMeshCollision</span>(HitCharacter, ECollisionEnabled::QueryAndPhysics);</span><br><span class="line"><span class="keyword">return</span> FServerSideRewindResult&#123; <span class="literal">true</span>,<span class="literal">true</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">//没有命中，检查剩余HitBox</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; HitBoxPair : HitCharacter-&gt;HitCollisionBoxes) &#123;</span><br><span class="line"><span class="keyword">if</span> (HitBoxPair.Value) &#123;</span><br><span class="line">HitBoxPair.Value-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::QueryAndPhysics);</span><br><span class="line">HitBoxPair.Value-&gt;<span class="built_in">SetCollisionResponseToChannel</span>(ECC_HitBox, ECollisionResponse::ECR_Block);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">World-&gt;<span class="built_in">LineTraceSingleByChannel</span>(</span><br><span class="line">ConfirmHitResult,</span><br><span class="line">TraceStart,</span><br><span class="line">TraceEnd,</span><br><span class="line">ECC_HitBox</span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (ConfirmHitResult.bBlockingHit) &#123;</span><br><span class="line"><span class="built_in">ResetBoxes</span>(HitCharacter, CurrentFrame);</span><br><span class="line"><span class="built_in">EnableCharacterMeshCollision</span>(HitCharacter, ECollisionEnabled::QueryAndPhysics);</span><br><span class="line"><span class="keyword">return</span> FServerSideRewindResult&#123; <span class="literal">true</span>,<span class="literal">false</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ResetBoxes</span>(HitCharacter, CurrentFrame);</span><br><span class="line"><span class="built_in">EnableCharacterMeshCollision</span>(HitCharacter, ECollisionEnabled::QueryAndPhysics);</span><br><span class="line"><span class="keyword">return</span> FServerSideRewindResult&#123; <span class="literal">false</span>,<span class="literal">false</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些辅助函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ULagCompensationComponent::CacheBoxPositions</span><span class="params">(AMultiplayerTPSCharacter* HitCharacter, FFramePackage&amp; OutFramePackage)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!HitCharacter) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; HitBoxPair : Character-&gt;HitCollisionBoxes) &#123;</span><br><span class="line"><span class="keyword">if</span> (HitBoxPair.Value) &#123;</span><br><span class="line">FBoxInformation BoxInfo;</span><br><span class="line">BoxInfo.Location = HitBoxPair.Value-&gt;<span class="built_in">GetComponentLocation</span>();</span><br><span class="line">BoxInfo.Rotation = HitBoxPair.Value-&gt;<span class="built_in">GetComponentRotation</span>();</span><br><span class="line">BoxInfo.BoxExtent = HitBoxPair.Value-&gt;<span class="built_in">GetScaledBoxExtent</span>();</span><br><span class="line">OutFramePackage.HitBoxInfo.<span class="built_in">Add</span>(HitBoxPair.Key, BoxInfo);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ULagCompensationComponent::MoveBoxes</span><span class="params">(AMultiplayerTPSCharacter* HitCharacter, <span class="type">const</span> FFramePackage&amp; Package)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!HitCharacter) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; HitBoxPair : Character-&gt;HitCollisionBoxes) &#123;</span><br><span class="line"><span class="keyword">if</span> (HitBoxPair.Value) &#123;</span><br><span class="line">HitBoxPair.Value-&gt;<span class="built_in">SetWorldLocation</span>(Package.HitBoxInfo[HitBoxPair.Key].Location);</span><br><span class="line">HitBoxPair.Value-&gt;<span class="built_in">SetWorldRotation</span>(Package.HitBoxInfo[HitBoxPair.Key].Rotation);</span><br><span class="line"><span class="comment">//HitBoxPair.Value-&gt;SetBoxExtent(Package.HitBoxInfo[HitBoxPair.Key].BoxExtent);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ULagCompensationComponent::ResetBoxes</span><span class="params">(AMultiplayerTPSCharacter* HitCharacter, <span class="type">const</span> FFramePackage&amp; Package)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!HitCharacter) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; HitBoxPair : Character-&gt;HitCollisionBoxes) &#123;</span><br><span class="line"><span class="keyword">if</span> (HitBoxPair.Value) &#123;</span><br><span class="line">HitBoxPair.Value-&gt;<span class="built_in">SetWorldLocation</span>(Package.HitBoxInfo[HitBoxPair.Key].Location);</span><br><span class="line">HitBoxPair.Value-&gt;<span class="built_in">SetWorldRotation</span>(Package.HitBoxInfo[HitBoxPair.Key].Rotation);</span><br><span class="line"><span class="comment">//HitBoxPair.Value-&gt;SetBoxExtent(Package.HitBoxInfo[HitBoxPair.Key].BoxExtent);</span></span><br><span class="line">HitBoxPair.Value-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ULagCompensationComponent::EnableCharacterMeshCollision</span><span class="params">(AMultiplayerTPSCharacter* HitCharacter, ECollisionEnabled::Type CollisionEnable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (HitCharacter &amp;&amp; HitCharacter-&gt;<span class="built_in">GetMesh</span>()) &#123;</span><br><span class="line">HitCharacter-&gt;<span class="built_in">GetMesh</span>()-&gt;<span class="built_in">SetCollisionEnabled</span>(CollisionEnable);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于霰弹枪的倒带，思想和即时命中武器是差不多的，但是因为可能会命中多个角色，需要做一些调整。</p><p>声明一个新的结构体，用来保存霰弹枪的命中结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FShotgunServerSideRewindResult</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line">TMap&lt;AMultiplayerTPSCharacter*, uint32&gt; HeadShots;</span><br><span class="line">TMap&lt;AMultiplayerTPSCharacter*, uint32&gt; BodyShots;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在进行检测的时候对所有的命中目标进行倒带并检测，返回检测结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FShotgunServerSideRewindResult <span class="title">ULagCompensationComponent::ShotgunServerSideRewind</span><span class="params">(<span class="type">const</span> TArray&lt;AMultiplayerTPSCharacter*&gt;&amp; HitCharacters, <span class="type">const</span> FVector_NetQuantize&amp; TraceStart, <span class="type">const</span> TArray&lt;FVector_NetQuantize&gt;&amp; HitLocations, <span class="type">float</span> HitTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TArray&lt;FFramePackage&gt; FramesToCheck;</span><br><span class="line"><span class="keyword">for</span> (AMultiplayerTPSCharacter* HitCharacter : HitCharacters) &#123;</span><br><span class="line">FramesToCheck.<span class="built_in">Add</span>(<span class="built_in">GetFrameToCheck</span>(HitCharacter, HitTime));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">ShotgunConfirmHit</span>(FramesToCheck, TraceStart, HitLocations);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FShotgunServerSideRewindResult <span class="title">ULagCompensationComponent::ShotgunConfirmHit</span><span class="params">(<span class="type">const</span> TArray&lt;FFramePackage&gt;&amp; FramePackages, <span class="type">const</span> FVector_NetQuantize&amp; TraceStart, <span class="type">const</span> TArray&lt;FVector_NetQuantize&gt;&amp; HitLocations)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; Frame : FramePackages) &#123;</span><br><span class="line"><span class="keyword">if</span> (!Frame.Character) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">FShotgunServerSideRewindResult</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FShotgunServerSideRewindResult ShotgunResult;</span><br><span class="line">TArray&lt;FFramePackage&gt; CurrentFrames;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; Frame : FramePackages) &#123;</span><br><span class="line">FFramePackage CurrentFrame;</span><br><span class="line">CurrentFrame.Character = Frame.Character;</span><br><span class="line"><span class="built_in">CacheBoxPositions</span>(Frame.Character, CurrentFrame);</span><br><span class="line"><span class="built_in">MoveBoxes</span>(Frame.Character, Frame);</span><br><span class="line"><span class="built_in">EnableCharacterMeshCollision</span>(Frame.Character, ECollisionEnabled::NoCollision);</span><br><span class="line">CurrentFrames.<span class="built_in">Add</span>(CurrentFrame);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; Frame : FramePackages) &#123;</span><br><span class="line"><span class="comment">//首先启用头部碰撞</span></span><br><span class="line">UBoxComponent* HeadBox = Frame.Character-&gt;HitCollisionBoxes[<span class="built_in">FName</span>(<span class="string">&quot;head&quot;</span>)];</span><br><span class="line">HeadBox-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::QueryAndPhysics);</span><br><span class="line">HeadBox-&gt;<span class="built_in">SetCollisionResponseToChannel</span>(ECollisionChannel::ECC_Visibility, ECollisionResponse::ECR_Block);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UWorld* World = <span class="built_in">GetWorld</span>();</span><br><span class="line"><span class="comment">//检测爆头</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; HitLocation : HitLocations) &#123;</span><br><span class="line">FHitResult ConfirmHitResult;</span><br><span class="line"><span class="type">const</span> FVector TraceEnd = TraceStart + (HitLocation - TraceStart) * <span class="number">1.25f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (World) &#123;</span><br><span class="line">World-&gt;<span class="built_in">LineTraceSingleByChannel</span>(</span><br><span class="line">ConfirmHitResult,</span><br><span class="line">TraceStart,</span><br><span class="line">TraceEnd,</span><br><span class="line">ECollisionChannel::ECC_Visibility</span><br><span class="line">);</span><br><span class="line">AMultiplayerTPSCharacter* MultiplayerTPSCharacter = <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(ConfirmHitResult.<span class="built_in">GetActor</span>());</span><br><span class="line"><span class="keyword">if</span> (MultiplayerTPSCharacter) &#123;</span><br><span class="line"><span class="keyword">if</span> (ShotgunResult.HeadShots.<span class="built_in">Contains</span>(MultiplayerTPSCharacter)) &#123;</span><br><span class="line">++ShotgunResult.HeadShots[MultiplayerTPSCharacter];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ShotgunResult.HeadShots.<span class="built_in">Emplace</span>(MultiplayerTPSCharacter, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//启用其它盒体的碰撞，禁用头部盒体的碰撞</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; Frame : FramePackages) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; HitBoxPair : Frame.Character-&gt;HitCollisionBoxes) &#123;</span><br><span class="line"><span class="keyword">if</span> (HitBoxPair.Value) &#123;</span><br><span class="line">HitBoxPair.Value-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::QueryAndPhysics);</span><br><span class="line">HitBoxPair.Value-&gt;<span class="built_in">SetCollisionResponseToChannel</span>(ECollisionChannel::ECC_Visibility, ECollisionResponse::ECR_Block);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">UBoxComponent* HeadBox = Frame.Character-&gt;HitCollisionBoxes[<span class="built_in">FName</span>(<span class="string">&quot;head&quot;</span>)];</span><br><span class="line">HeadBox-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检测身体命中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; HitLocation : HitLocations) &#123;</span><br><span class="line">FHitResult ConfirmHitResult;</span><br><span class="line"><span class="type">const</span> FVector TraceEnd = TraceStart + (HitLocation - TraceStart) * <span class="number">1.25f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (World) &#123;</span><br><span class="line">World-&gt;<span class="built_in">LineTraceSingleByChannel</span>(</span><br><span class="line">ConfirmHitResult,</span><br><span class="line">TraceStart,</span><br><span class="line">TraceEnd,</span><br><span class="line">ECollisionChannel::ECC_Visibility</span><br><span class="line">);</span><br><span class="line">AMultiplayerTPSCharacter* MultiplayerTPSCharacter = <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(ConfirmHitResult.<span class="built_in">GetActor</span>());</span><br><span class="line"><span class="keyword">if</span> (MultiplayerTPSCharacter) &#123;</span><br><span class="line"><span class="keyword">if</span> (ShotgunResult.BodyShots.<span class="built_in">Contains</span>(MultiplayerTPSCharacter)) &#123;</span><br><span class="line">++ShotgunResult.BodyShots[MultiplayerTPSCharacter];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ShotgunResult.BodyShots.<span class="built_in">Emplace</span>(MultiplayerTPSCharacter, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; Frame : CurrentFrames) &#123;</span><br><span class="line"><span class="built_in">ResetBoxes</span>(Frame.Character, Frame);</span><br><span class="line"><span class="built_in">EnableCharacterMeshCollision</span>(Frame.Character, ECollisionEnabled::QueryAndPhysics);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ShotgunResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在射击时调用<code>Server RPC</code>请求服务器倒带。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">TMap&lt;AMultiplayerTPSCharacter*, uint32&gt; HitMap;</span><br><span class="line"><span class="keyword">for</span> (uint32 i = <span class="number">0</span>; i &lt; NumberOfPellets; ++i) &#123;</span><br><span class="line">FHitResult FireHit;</span><br><span class="line"><span class="built_in">WeaponTraceHit</span>(Start, HitTarget, FireHit);</span><br><span class="line">HitResults.<span class="built_in">Add</span>(FireHit);</span><br><span class="line">HitEnds.<span class="built_in">Add</span>(HitEnd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">AMultiplayerTPSCharacter* MultiplayerTPSCharacter = <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(FireHit.<span class="built_in">GetActor</span>());</span><br><span class="line"><span class="keyword">if</span> (MultiplayerTPSCharacter &amp;&amp; InstigatorController) &#123;</span><br><span class="line"><span class="keyword">if</span> (HitMap.<span class="built_in">Contains</span>(MultiplayerTPSCharacter)) &#123;</span><br><span class="line">++HitMap[MultiplayerTPSCharacter];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">HitMap.<span class="built_in">Emplace</span>(MultiplayerTPSCharacter, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">TArray&lt;AMultiplayerTPSCharacter*&gt; HitCharacters;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; HitPair : HitMap) &#123;</span><br><span class="line"><span class="keyword">if</span> (HitPair.Key &amp;&amp; InstigatorController) &#123;</span><br><span class="line">HitCharacters.<span class="built_in">Add</span>(HitPair.Key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MultiplayerTPSOwnerCharacter = MultiplayerTPSOwnerCharacter ? MultiplayerTPSOwnerCharacter : <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(OwnerPawn);</span><br><span class="line">MultiplayerTPSOwnerController = MultiplayerTPSOwnerController ? MultiplayerTPSOwnerController : <span class="built_in">Cast</span>&lt;AMPTPSPlayerController&gt;(InstigatorController);</span><br><span class="line"><span class="keyword">if</span> (MultiplayerTPSOwnerCharacter &amp;&amp; MultiplayerTPSOwnerController &amp;&amp; MultiplayerTPSOwnerCharacter-&gt;<span class="built_in">GetLagCompensation</span>() &amp;&amp; MultiplayerTPSOwnerCharacter-&gt;<span class="built_in">IsLocallyControlled</span>()) &#123;</span><br><span class="line">MultiplayerTPSOwnerCharacter-&gt;<span class="built_in">GetLagCompensation</span>()-&gt;<span class="built_in">ServerShotgunServerScoreRequest</span>(</span><br><span class="line">HitCharacters,</span><br><span class="line">Start,</span><br><span class="line">HitEnds,</span><br><span class="line">MultiplayerTPSOwnerController-&gt;<span class="built_in">GetServerTime</span>() - MultiplayerTPSOwnerController-&gt;SingleTripTime</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ULagCompensationComponent::ServerShotgunServerScoreRequest_Implementation</span><span class="params">(<span class="type">const</span> TArray&lt;AMultiplayerTPSCharacter*&gt;&amp; HitCharacters, <span class="type">const</span> FVector_NetQuantize&amp; TraceStart, <span class="type">const</span> TArray&lt;FVector_NetQuantize&gt;&amp; HitLocations, <span class="type">float</span> HitTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FShotgunServerSideRewindResult Confirm = <span class="built_in">ShotgunServerSideRewind</span>(HitCharacters, TraceStart, HitLocations, HitTime);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; HitCharacter : HitCharacters) &#123;</span><br><span class="line"><span class="keyword">if</span> (!HitCharacter || !Character || !Character-&gt;<span class="built_in">GetEquippedWeapon</span>()) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">float</span> TotalDamage = <span class="number">0.f</span>;</span><br><span class="line"><span class="keyword">if</span> (Confirm.HeadShots.<span class="built_in">Contains</span>(HitCharacter)) &#123;</span><br><span class="line"><span class="type">float</span> HeadShotDamage = Confirm.HeadShots[HitCharacter] * Character-&gt;<span class="built_in">GetEquippedWeapon</span>()-&gt;<span class="built_in">GetDamage</span>();</span><br><span class="line">TotalDamage += HeadShotDamage;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Confirm.BodyShots.<span class="built_in">Contains</span>(HitCharacter)) &#123;</span><br><span class="line"><span class="type">float</span> BodyDamage = Confirm.BodyShots[HitCharacter] * Character-&gt;<span class="built_in">GetEquippedWeapon</span>()-&gt;<span class="built_in">GetDamage</span>();</span><br><span class="line">TotalDamage += BodyDamage;</span><br><span class="line">&#125;</span><br><span class="line">UGameplayStatics::<span class="built_in">ApplyDamage</span>(</span><br><span class="line">HitCharacter,</span><br><span class="line">TotalDamage,</span><br><span class="line">Character-&gt;Controller,</span><br><span class="line">Character-&gt;<span class="built_in">GetEquippedWeapon</span>(),</span><br><span class="line">UDamageType::<span class="built_in">StaticClass</span>()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是弹道武器的服务器倒带。<code>UE</code>引擎自带了投射物路径预测的功能，这使得弹道武器的服务器倒带实现起来容易了很多。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FPredictProjectilePathParams PathParams;</span><br><span class="line">PathParams.bTraceWithChannel = <span class="literal">true</span>;</span><br><span class="line">PathParams.bTraceWithCollision = <span class="literal">true</span>;</span><br><span class="line">PathParams.DrawDebugTime = <span class="number">5.f</span>;</span><br><span class="line">PathParams.DrawDebugType = EDrawDebugTrace::ForDuration;</span><br><span class="line">PathParams.LaunchVelocity = <span class="built_in">GetActorForwardVector</span>() * InitialSpeed;</span><br><span class="line">PathParams.MaxSimTime = <span class="number">4.f</span>;</span><br><span class="line">PathParams.ProjectileRadius = <span class="number">5.f</span>;</span><br><span class="line">PathParams.SimFrequency = <span class="number">30.f</span>;PathParams.StartLocation = <span class="built_in">GetActorLocation</span>();</span><br><span class="line">PathParams.TraceChannel = ECollisionChannel::ECC_Visibility;</span><br><span class="line">PathParams.ActorsToIgnore.<span class="built_in">Add</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">FPredictProjectilePathResult PathResult;</span><br><span class="line">UGameplayStatics::<span class="built_in">PredictProjectilePath</span>(<span class="keyword">this</span>, PathParams, PathResult);</span><br></pre></td></tr></table></figure><p><img src="/undefined/af2b6aaf/image-20250809151616224.png" alt="image-20250809151616224"></p><p>在投射物基类中声明用于服务器倒带的变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> bUseServerSideRewind = <span class="literal">false</span>;</span><br><span class="line">FVector_NetQuantize TraceStart;</span><br><span class="line">FVector_NetQuantize100 InitialVelocity;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line"><span class="type">float</span> InitialSpeed = <span class="number">15000.f</span>;</span><br></pre></td></tr></table></figure><p>在构造函数中将投射物运动组件的初速度设为我们自己的变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ProjectileMovementComponent-&gt;InitialSpeed = InitialSpeed;</span><br><span class="line">ProjectileMovementComponent-&gt;MaxSpeed = InitialSpeed;</span><br></pre></td></tr></table></figure><p>这里有一个问题。我需要初速度和最大速度这两个变量来进行服务器倒带，但是投射物运动组件中使用的并不是这两个变量，而是直接在蓝图中由我们设置的。如果我们手动更改<code>InitialSpeed</code>，蓝图中的初速度和最大速度也是不会自动变化的。为了使其自动跟随<code>InitialSpeed</code>自动变化，这里使用了一个黑科技。</p><p>重写下面这个函数，并使用<code>#if</code>进行标记。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> WITH_EDITOR</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PostEditChangeProperty</span><span class="params">(<span class="keyword">struct</span> FPropertyChangedEvent&amp; Event)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在函数定义中同样使用<code>#if</code>进行定义，这样在蓝图中更改<code>InitialSpeed</code>的值，初速度和最大速度就会跟着改变了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> WITH_EDITOR</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AProjectileBullet::PostEditChangeProperty</span><span class="params">(FPropertyChangedEvent&amp; Event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">PostEditChangeProperty</span>(Event);</span><br><span class="line"></span><br><span class="line">FName PropertyName = Event.Property ? Event.Property-&gt;<span class="built_in">GetFName</span>() : NAME_None;</span><br><span class="line"><span class="keyword">if</span> (PropertyName == <span class="built_in">GET_MEMBER_NAME_CHECKED</span>(AProjectileBullet, InitialSpeed)) &#123;</span><br><span class="line"><span class="keyword">if</span> (ProjectileMovementComponent) &#123;</span><br><span class="line">ProjectileMovementComponent-&gt;InitialSpeed = InitialSpeed;</span><br><span class="line">ProjectileMovementComponent-&gt;MaxSpeed = InitialSpeed;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>来到投射物的生成部分。在弹道武器中再加一个用于服务器倒带的投射物类，它的唯一区别是不启用复制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">TSubclassOf&lt;<span class="keyword">class</span> <span class="title class_">AProjectile</span>&gt; ProjectileClass;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">TSubclassOf&lt;AProjectile&gt; ServerSideRewindProjectileClass;</span><br></pre></td></tr></table></figure><p>重写弹道武器的开火逻辑，根据是否是服务器，是否启用服务器倒带以及是否是本地控制来决定生成投射物的逻辑。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AProjectileWeapon::Fire</span><span class="params">(<span class="type">const</span> FVector&amp; HitTarget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">Fire</span>(HitTarget);</span><br><span class="line"></span><br><span class="line">APawn* InstigatorPawn = <span class="built_in">Cast</span>&lt;APawn&gt;(<span class="built_in">GetOwner</span>());</span><br><span class="line"><span class="type">const</span> USkeletalMeshSocket* MuzzleFlashSocket = <span class="built_in">GetWeaponMesh</span>()-&gt;<span class="built_in">GetSocketByName</span>(<span class="built_in">FName</span>(<span class="string">&quot;MuzzleFlash&quot;</span>));</span><br><span class="line">UWorld* World = <span class="built_in">GetWorld</span>();</span><br><span class="line"><span class="keyword">if</span> (MuzzleFlashSocket &amp;&amp; InstigatorPawn &amp;&amp; World) &#123;</span><br><span class="line">FTransform SocketTransform = MuzzleFlashSocket-&gt;<span class="built_in">GetSocketTransform</span>(<span class="built_in">GetWeaponMesh</span>());</span><br><span class="line"><span class="comment">//从MuzzleSocket到命中点</span></span><br><span class="line">FVector ToTarget = HitTarget - SocketTransform.<span class="built_in">GetLocation</span>();</span><br><span class="line">FRotator TargetRotatrion = ToTarget.<span class="built_in">Rotation</span>();</span><br><span class="line"></span><br><span class="line">FActorSpawnParameters SpawnParams;</span><br><span class="line">SpawnParams.Owner = <span class="built_in">GetOwner</span>();</span><br><span class="line">SpawnParams.Instigator = InstigatorPawn;</span><br><span class="line"></span><br><span class="line">AProjectile* SpawnedProjectile = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> (bUseServerSideRewind) &#123;</span><br><span class="line"><span class="keyword">if</span> (InstigatorPawn-&gt;<span class="built_in">HasAuthority</span>()) &#123; <span class="comment">//服务器</span></span><br><span class="line"><span class="keyword">if</span> (InstigatorPawn-&gt;<span class="built_in">IsLocallyControlled</span>()) &#123; <span class="comment">//监听服务器，不需要进行服务器倒带，直接生成复制的投射物</span></span><br><span class="line">SpawnedProjectile = World-&gt;<span class="built_in">SpawnActor</span>&lt;AProjectile&gt;(ProjectileClass,SocketTransform.<span class="built_in">GetLocation</span>(),TargetRotatrion,SpawnParams);</span><br><span class="line">SpawnedProjectile-&gt;bUseServerSideRewind = <span class="literal">false</span>;</span><br><span class="line">SpawnedProjectile-&gt;Damage = Damage;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">//服务器，客户端请求的的开火，生成不复制的投射物，并且不使用服务器倒带，因为客户端自己会生成投射物并请求服务器倒带</span></span><br><span class="line">SpawnedProjectile = World-&gt;<span class="built_in">SpawnActor</span>&lt;AProjectile&gt;(ServerSideRewindProjectileClass, SocketTransform.<span class="built_in">GetLocation</span>(), TargetRotatrion, SpawnParams);</span><br><span class="line">SpawnedProjectile-&gt;bUseServerSideRewind = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">if</span> (InstigatorPawn-&gt;<span class="built_in">IsLocallyControlled</span>()) &#123; <span class="comment">//客户端，本地控制，生成不复制的投射物，并且启用服务器倒带</span></span><br><span class="line">SpawnedProjectile = World-&gt;<span class="built_in">SpawnActor</span>&lt;AProjectile&gt;(ProjectileClass, SocketTransform.<span class="built_in">GetLocation</span>(), TargetRotatrion, SpawnParams);</span><br><span class="line">SpawnedProjectile-&gt;bUseServerSideRewind = <span class="literal">true</span>;</span><br><span class="line">SpawnedProjectile-&gt;TraceStart = SocketTransform.<span class="built_in">GetLocation</span>();</span><br><span class="line">SpawnedProjectile-&gt;InitialVelocity = SpawnedProjectile-&gt;<span class="built_in">GetActorForwardVector</span>() * SpawnedProjectile-&gt;InitialSpeed;</span><br><span class="line">SpawnedProjectile-&gt;Damage = Damage;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">//客户端，非本地控制，生成不复制且不启用服务器倒带的投射物</span></span><br><span class="line">SpawnedProjectile = World-&gt;<span class="built_in">SpawnActor</span>&lt;AProjectile&gt;(ServerSideRewindProjectileClass, SocketTransform.<span class="built_in">GetLocation</span>(), TargetRotatrion, SpawnParams);</span><br><span class="line">SpawnedProjectile-&gt;bUseServerSideRewind = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">//不使用服务器倒带</span></span><br><span class="line"><span class="keyword">if</span> (InstigatorPawn-&gt;<span class="built_in">HasAuthority</span>()) &#123;</span><br><span class="line">SpawnedProjectile = World-&gt;<span class="built_in">SpawnActor</span>&lt;AProjectile&gt;(ProjectileClass, SocketTransform.<span class="built_in">GetLocation</span>(), TargetRotatrion, SpawnParams);</span><br><span class="line">SpawnedProjectile-&gt;bUseServerSideRewind = <span class="literal">false</span>;</span><br><span class="line">SpawnedProjectile-&gt;Damage = Damage;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是倒带的具体实现了。当子弹命中时，如果是在服务器并且没有使用服务器倒带或者是服务器自己发射的子弹，直接造成伤害，否则如果是本地发射的子弹并且启用的服务器倒带，就调用Server RPC来进行服务器倒带进行命中判定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AProjectileBullet::OnHit</span><span class="params">(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, <span class="type">const</span> FHitResult&amp; Hit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">AMultiplayerTPSCharacter* OwnerCharacter = <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(<span class="built_in">GetOwner</span>());</span><br><span class="line"><span class="keyword">if</span> (OwnerCharacter) &#123;</span><br><span class="line">AMPTPSPlayerController* OwnerController = <span class="built_in">Cast</span>&lt;AMPTPSPlayerController&gt;(OwnerCharacter-&gt;Controller);</span><br><span class="line"><span class="keyword">if</span> (OwnerController) &#123;</span><br><span class="line"><span class="keyword">if</span> (OwnerCharacter-&gt;<span class="built_in">HasAuthority</span>() &amp;&amp; (!bUseServerSideRewind || OwnerCharacter-&gt;<span class="built_in">IsLocallyControlled</span>())) &#123;</span><br><span class="line">UGameplayStatics::<span class="built_in">ApplyDamage</span>(OtherActor, Damage, OwnerController, <span class="keyword">this</span>, UDamageType::<span class="built_in">StaticClass</span>());</span><br><span class="line">Super::<span class="built_in">OnHit</span>(HitComp, OtherActor, OtherComp, NormalImpulse, Hit);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">AMultiplayerTPSCharacter* HitCharacter = <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(OtherActor);</span><br><span class="line"><span class="keyword">if</span> (bUseServerSideRewind &amp;&amp; OwnerCharacter-&gt;<span class="built_in">GetLagCompensation</span>() &amp;&amp; OwnerCharacter-&gt;<span class="built_in">IsLocallyControlled</span>() &amp;&amp; HitCharacter) &#123;</span><br><span class="line"><span class="built_in">ServerProjectileScoreRequest</span>(</span><br><span class="line">HitCharacter,</span><br><span class="line">TraceStart,</span><br><span class="line">InitialVelocity,</span><br><span class="line">OwnerController-&gt;<span class="built_in">GetServerTime</span>() - OwnerController-&gt;SingleTripTime</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Super::<span class="built_in">OnHit</span>(HitComp, OtherActor, OtherComp, NormalImpulse, Hit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ULagCompensationComponent::ServerProjectileScoreRequest_Implementation</span><span class="params">(AMultiplayerTPSCharacter* HitCharacter, <span class="type">const</span> FVector_NetQuantize&amp; TraceStart, <span class="type">const</span> FVector_NetQuantize100&amp; InitialVelocity, <span class="type">float</span> HitTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FServerSideRewindResult Confirm = <span class="built_in">ProjectileServerSideRewind</span>(HitCharacter, TraceStart, InitialVelocity, HitTime);</span><br><span class="line"><span class="keyword">if</span> (Character &amp;&amp; HitCharacter &amp;&amp; Confirm.bHitConfirmed) &#123;</span><br><span class="line">UGameplayStatics::<span class="built_in">ApplyDamage</span>(</span><br><span class="line">HitCharacter,</span><br><span class="line">Character-&gt;<span class="built_in">GetEquippedWeapon</span>()-&gt;<span class="built_in">GetDamage</span>(),</span><br><span class="line">Character-&gt;Controller,</span><br><span class="line">Character-&gt;<span class="built_in">GetEquippedWeapon</span>(),</span><br><span class="line">UDamageType::<span class="built_in">StaticClass</span>()</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FServerSideRewindResult <span class="title">ULagCompensationComponent::ProjectileServerSideRewind</span><span class="params">(AMultiplayerTPSCharacter* HitCharacter, <span class="type">const</span> FVector_NetQuantize&amp; TraceStart, <span class="type">const</span> FVector_NetQuantize&amp; InitialVelocity, <span class="type">float</span> HitTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FFramePackage FrameToCheck = <span class="built_in">GetFrameToCheck</span>(HitCharacter, HitTime);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">ProjectileConfirmHit</span>(FrameToCheck, HitCharacter, TraceStart, InitialVelocity, HitTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FServerSideRewindResult <span class="title">ULagCompensationComponent::ProjectileConfirmHit</span><span class="params">(<span class="type">const</span> FFramePackage&amp; Package, AMultiplayerTPSCharacter* HitCharacter, <span class="type">const</span> FVector_NetQuantize&amp; TraceStart, <span class="type">const</span> FVector_NetQuantize&amp; InitialVelocity, <span class="type">float</span> HitTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!HitCharacter) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">FServerSideRewindResult</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FFramePackage CurrentFrame;</span><br><span class="line"><span class="built_in">CacheBoxPositions</span>(HitCharacter, CurrentFrame);</span><br><span class="line"><span class="built_in">MoveBoxes</span>(HitCharacter, Package);</span><br><span class="line"><span class="built_in">EnableCharacterMeshCollision</span>(HitCharacter, ECollisionEnabled::NoCollision);</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先启用头部碰撞</span></span><br><span class="line">UBoxComponent* HeadBox = HitCharacter-&gt;HitCollisionBoxes[<span class="built_in">FName</span>(<span class="string">&quot;head&quot;</span>)];</span><br><span class="line">HeadBox-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::QueryAndPhysics);</span><br><span class="line">HeadBox-&gt;<span class="built_in">SetCollisionResponseToChannel</span>(ECC_HitBox, ECollisionResponse::ECR_Block);</span><br><span class="line"></span><br><span class="line">FPredictProjectilePathParams PathParams;</span><br><span class="line">PathParams.bTraceWithCollision = <span class="literal">true</span>;</span><br><span class="line">PathParams.DrawDebugTime = MaxRecordTime;</span><br><span class="line">PathParams.LaunchVelocity = InitialVelocity;</span><br><span class="line">PathParams.StartLocation = TraceStart;</span><br><span class="line">PathParams.ProjectileRadius = <span class="number">5.f</span>;</span><br><span class="line">PathParams.SimFrequency = <span class="number">15.f</span>;</span><br><span class="line">PathParams.TraceChannel = ECC_HitBox;</span><br><span class="line">PathParams.ActorsToIgnore.<span class="built_in">Add</span>(<span class="built_in">GetOwner</span>());</span><br><span class="line">PathParams.DrawDebugTime = <span class="number">5.f</span>;</span><br><span class="line">PathParams.DrawDebugType = EDrawDebugTrace::ForDuration;</span><br><span class="line"></span><br><span class="line">FPredictProjectilePathResult PathResult;</span><br><span class="line">UGameplayStatics::<span class="built_in">PredictProjectilePath</span>(<span class="keyword">this</span>, PathParams, PathResult);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (PathResult.HitResult.bBlockingHit) &#123;</span><br><span class="line"><span class="built_in">ResetBoxes</span>(HitCharacter, CurrentFrame);</span><br><span class="line"><span class="built_in">EnableCharacterMeshCollision</span>(HitCharacter, ECollisionEnabled::QueryAndPhysics);</span><br><span class="line"><span class="keyword">return</span> FServerSideRewindResult&#123; <span class="literal">true</span>,<span class="literal">true</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; HitBoxPair : HitCharacter-&gt;HitCollisionBoxes) &#123;</span><br><span class="line"><span class="keyword">if</span> (HitBoxPair.Value) &#123;</span><br><span class="line">HitBoxPair.Value-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::QueryAndPhysics);</span><br><span class="line">HitBoxPair.Value-&gt;<span class="built_in">SetCollisionResponseToChannel</span>(ECC_HitBox, ECollisionResponse::ECR_Block);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UGameplayStatics::<span class="built_in">PredictProjectilePath</span>(<span class="keyword">this</span>, PathParams, PathResult);</span><br><span class="line"><span class="keyword">if</span> (PathResult.HitResult.bBlockingHit) &#123;</span><br><span class="line"><span class="built_in">ResetBoxes</span>(HitCharacter, CurrentFrame);</span><br><span class="line"><span class="built_in">EnableCharacterMeshCollision</span>(HitCharacter, ECollisionEnabled::QueryAndPhysics);</span><br><span class="line"><span class="keyword">return</span> FServerSideRewindResult&#123; <span class="literal">true</span>,<span class="literal">false</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ResetBoxes</span>(HitCharacter, CurrentFrame);</span><br><span class="line"><span class="built_in">EnableCharacterMeshCollision</span>(HitCharacter, ECollisionEnabled::QueryAndPhysics);</span><br><span class="line"><span class="keyword">return</span> FServerSideRewindResult&#123; <span class="literal">false</span>,<span class="literal">false</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-禁用服务器倒带"><a href="#4-4-禁用服务器倒带" class="headerlink" title="4.4 禁用服务器倒带"></a>4.4 禁用服务器倒带</h3><p>之前说过，当玩家的延迟高到一定程度时，使用服务器倒带会为其它低延迟玩家带来较差的游戏体验，因此当玩家延迟高到一定程度的时候应该禁用服务器倒带。</p><p>首先这个变量应该是有条件复制的，因为只要控制角色的客户端才需要这个变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DOREPLIFETIME_CONDITION</span>(AWeapon, bUseServerSideRewind, COND_OwnerOnly);</span><br></pre></td></tr></table></figure><p>之前在控制器中实现了定期检查Ping，现在检查Ping后调用<code>Server RPC</code>，根据ping的高低决定是否启用服务器倒带。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::CheckPing</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HighPingRunningTime += DeltaTime;</span><br><span class="line"><span class="keyword">if</span> (HighPingRunningTime &gt; CheckPingFrequency) &#123;</span><br><span class="line">PlayerState = PlayerState == <span class="literal">nullptr</span> ? <span class="built_in">GetPlayerState</span>&lt;AMultiplayerTPSPlayerState&gt;() : PlayerState;</span><br><span class="line"><span class="keyword">if</span> (PlayerState) &#123;</span><br><span class="line"><span class="keyword">if</span> (PlayerState-&gt;<span class="built_in">GetCompressedPing</span>() * <span class="number">4</span> &gt; HighPingThreshold) &#123;</span><br><span class="line"><span class="built_in">HighPingWarning</span>();</span><br><span class="line">PingAnimationRunningTime = <span class="number">0.f</span>;</span><br><span class="line"><span class="built_in">ServerReportPingStatus</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">ServerReportPingStatus</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">HighPingRunningTime = <span class="number">0.f</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (MultiplayerTPSHUD &amp;&amp;</span><br><span class="line">MultiplayerTPSHUD-&gt;CharacterOverlay &amp;&amp;</span><br><span class="line">MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HighPingAnimation &amp;&amp;</span><br><span class="line">MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;<span class="built_in">IsAnimationPlaying</span>(MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HighPingAnimation))</span><br><span class="line">&#123;</span><br><span class="line">PingAnimationRunningTime += DeltaTime;</span><br><span class="line"><span class="keyword">if</span> (PingAnimationRunningTime &gt; HighPingDuration) &#123;</span><br><span class="line"><span class="built_in">StopHighPingWarning</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::ServerReportPingStatus</span><span class="params">(<span class="type">bool</span> bHighPing)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">AMultiplayerTPSCharacter* Character = <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(Owner);</span><br><span class="line"><span class="keyword">if</span> (Character &amp;&amp; Character-&gt;<span class="built_in">GetEquippedWeapon</span>()) &#123;</span><br><span class="line">Character-&gt;<span class="built_in">GetEquippedWeapon</span>()-&gt;bUseServerSideRewind = !bHighPing;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-讨论和总结"><a href="#5-讨论和总结" class="headerlink" title="5.讨论和总结"></a>5.讨论和总结</h2><p>完成了上面的部分后，出于好奇，我找到了两篇<code>Valve</code>的文章，介绍了起源引擎中使用的多人游戏网络技术。</p><p><a href="https://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking">Source Multiplayer Networking - Valve Developer Community</a></p><p><a href="https://developer.valvesoftware.com/wiki/Latency_Compensating_Methods_in_Client/Server_In-game_Protocol_Design_and_Optimization">服务器游戏内协议设计与优化 - Valve 开发者社区</a></p><p>事实上，我发现文章中的重点正是本文中介绍的两种技术，除此之外，还有在两个快照之间进行插值等使游戏体验更加丝滑的手段。（另外，我看到文中介绍的服务器倒带在实现中确实是将所有玩家进行回溯再进行检测的，所以我的想法算是歪打正着了？）然而，这已经是二十多年前的文章了，也就是说，我目前所了解了知识仍然只是一个基础而已，而在这二十多年里肯定也有相当多的相关技术手段诞生。前路漫长啊。</p><p>在完成延迟补偿部分后，可以说本项目的重点部分已经结束了。目前项目中的玩法部分还没有实现，但是秋招已经开始一段时间了，我不能等到所有工作都完全准备好再开始行动，毕竟哪里会有真正的准备好呢？总之，玩法部分的开发会缓慢进行，至于现在，先祝我自己好运吧。</p><blockquote><p>朝焼けた色 空を舞って<br>朝晖之下 在空中起舞</p><p>何を願うかなんて愚問だ<br>竟然可笑到问我愿望为何</p><p>大人になって忘れていた<br>成为大人后就已经忘了</p><p>君を映す目が邪魔だ<br>映照出你的这双眼睛 竟是累赘</p><p>ずっと下で花が鳴った<br>千里之下鲜花低唱</p><p>大きな火の花が鳴った<br>巨大的火焰响彻夜空</p><p>音だけでも泣いてしまう、だなんて憶う<br>「只听声音就已泫然欲泣」 记得曾有这番情景</p><p>そんな夏を聞いた<br>听到了如此声响的夏天</p><p>——ヨルシカ《靴の花火》</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【UE5】多人联机TPS游戏开发（三） —— 射击游戏核心</title>
      <link href="/undefined/f9d4ce84.html"/>
      <url>/undefined/f9d4ce84.html</url>
      
        <content type="html"><![CDATA[<h1 id="【UE5】多人联机TPS游戏开发（三）-——-射击游戏核心"><a href="#【UE5】多人联机TPS游戏开发（三）-——-射击游戏核心" class="headerlink" title="【UE5】多人联机TPS游戏开发（三） —— 射击游戏核心"></a>【UE5】多人联机TPS游戏开发（三） —— 射击游戏核心</h1><blockquote><p>这一部分开始接近一个射击游戏的核心功能，包括HUD、开火、弹药，以及各种武器的实现等。</p><p>同时，在这一部分中也会开始通过Gameplay框架来实现游戏玩法的管理，以及使愈发复杂的游戏功能变得更加有条理。之前只是通过官方文档死记硬背，完全无法理解Gameplay框架到底是干什么的，而在实际上手之后才发现，Gameplay框架只是一些引擎提供的类，只要先了解这些类大概的作用，在有实际需求的时候自然就知道要用哪些类了。这个时候再去学习就比较轻松了。</p></blockquote><h2 id="1-HUD"><a href="#1-HUD" class="headerlink" title="1.HUD"></a>1.HUD</h2><p>在本项目中，主要通过<strong><code>HUD</code>类</strong>来管理各种UI，而HUD类又由<strong>玩家控制器</strong>来进行控制。</p><p>创建一个控件类<code>CharacterOverlay</code>用来显示玩家的主UI。从最基础的血量显示开始。</p><p>包含两个和控件蓝图绑定的元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(meta = (BindWidget))</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UProgressBar</span>* HealthBar;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(meta = (BindWidget))</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UTextBlock</span>* HealthText;</span><br></pre></td></tr></table></figure><p>在HUD类中将其添加到视口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSHUD.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, Category = <span class="string">&quot;Player Stats&quot;</span>)</span><br><span class="line">TSubclassOf&lt;<span class="keyword">class</span> <span class="title class_">UUserWidget</span>&gt; CharacterOverlayClass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UCharacterOverlay</span>* CharacterOverlay;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSHUD.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSHUD::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"><span class="built_in">AddCharacterOverlay</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSHUD::AddCharacterOverlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">APlayerController* PlayerController = <span class="built_in">GetOwningPlayerController</span>();</span><br><span class="line"><span class="keyword">if</span> (PlayerController &amp;&amp; CharacterOverlayClass) &#123;</span><br><span class="line">CharacterOverlay = <span class="built_in">CreateWidget</span>&lt;UCharacterOverlay&gt;(PlayerController, CharacterOverlayClass);</span><br><span class="line">CharacterOverlay-&gt;<span class="built_in">AddToViewport</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建自己的控制器类<code>MPTPSPlayerController</code>（我发誓以后再也不取这么长的项目名字了，类名还能超过字数显示的），在其中初始化HUD，并定义更新血量UI的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MPTPSPlayerController.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AMultiplayerTPSHUD</span>* MultiplayerTPSHUD;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MPTPSPlayerController.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line">MultiplayerTPSHUD = <span class="built_in">Cast</span>&lt;AMultiplayerTPSHUD&gt;(<span class="built_in">GetHUD</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::SetHUDHealth</span><span class="params">(<span class="type">float</span> Health, <span class="type">float</span> MaxHealth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MultiplayerTPSHUD = MultiplayerTPSHUD == <span class="literal">nullptr</span> ? <span class="built_in">Cast</span>&lt;AMultiplayerTPSHUD&gt;(<span class="built_in">GetHUD</span>()) : MultiplayerTPSHUD;</span><br><span class="line"><span class="keyword">if</span> (MultiplayerTPSHUD &amp;&amp; MultiplayerTPSHUD-&gt;CharacterOverlay &amp;&amp; MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HealthBar &amp;&amp; MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HealthText) &#123;</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> HealthPercent = Health / MaxHealth;</span><br><span class="line">MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HealthBar-&gt;<span class="built_in">SetPercent</span>(HealthPercent);</span><br><span class="line">FString HealthText = FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;%d/%d&quot;</span>), FMath::<span class="built_in">CeilToInt</span>(Health), FMath::<span class="built_in">CeilToInt</span>(MaxHealth));</span><br><span class="line">MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HealthText-&gt;<span class="built_in">SetText</span>(FText::<span class="built_in">FromString</span>(HealthText));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::OnPossess</span><span class="params">(APawn* InPawn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">OnPossess</span>(InPawn);</span><br><span class="line"></span><br><span class="line">AMultiplayerTPSCharacter* MultiplayerTPSCharacter = <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(InPawn);</span><br><span class="line"><span class="keyword">if</span> (MultiplayerTPSCharacter) &#123;</span><br><span class="line"><span class="built_in">SetHUDHealth</span>(MultiplayerTPSCharacter-&gt;<span class="built_in">GetHealth</span>(), MultiplayerTPSCharacter-&gt;<span class="built_in">GetMaxHealth</span>());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在角色类中定义血量相关的变量和处理函数。我之前想过血量作为角色的属性，为什么不放在“玩家状态”中？答案似乎是血量作为角色的核心属性，需要进行快速的同步，游戏状态的同步速度较慢无法达到要求，而角色的属性复制则可以满足同步需求。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSCharacter.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line"><span class="type">float</span> MaxHealth = <span class="number">100.f</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(ReplicatedUsing = OnRep_Health, VisibleAnywhere, Category = <span class="string">&quot;Player Stats&quot;</span>)</span><br><span class="line"><span class="type">float</span> Health = <span class="number">100.f</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnRep_Health</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AMPTPSPlayerController</span>* PlayerController;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSCharacter.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">PlayerController = <span class="built_in">Cast</span>&lt;AMPTPSPlayerController&gt;(Controller);</span><br><span class="line"><span class="keyword">if</span> (PlayerController) &#123;</span><br><span class="line">PlayerController-&gt;<span class="built_in">SetHUDHealth</span>(Health, MaxHealth);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::UpdateHUDHealth</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PlayerController = PlayerController == <span class="literal">nullptr</span> ? <span class="built_in">Cast</span>&lt;AMPTPSPlayerController&gt;(Controller) : PlayerController;</span><br><span class="line"><span class="keyword">if</span> (PlayerController) &#123;</span><br><span class="line">PlayerController-&gt;<span class="built_in">SetHUDHealth</span>(Health, MaxHealth);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以直接在角色类中通过角色=》玩家控制器=》HUD=》<code>CharacterOverlay</code>的链条来控制血条的更新。</p><p>HUD的更新逻辑都差不多，主要还是要细心，在值可能更新的地方都要更新HUD，之后的HUD部分就不一一列举了。</p><h2 id="2-命中伤害"><a href="#2-命中伤害" class="headerlink" title="2.命中伤害"></a>2.命中伤害</h2><p>从<code>Projectile</code>类派生一个<code>ProjectileBullet</code>类，重写命中函数，对命中的角色应用伤害并更新UI。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AProjectileBullet::OnHit</span><span class="params">(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, <span class="type">const</span> FHitResult&amp; Hit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ACharacter* OwnerCharacter = <span class="built_in">Cast</span>&lt;ACharacter&gt;(<span class="built_in">GetOwner</span>());</span><br><span class="line"><span class="keyword">if</span> (OwnerCharacter) &#123;</span><br><span class="line">AController* OwnerController = OwnerCharacter-&gt;Controller;</span><br><span class="line"><span class="keyword">if</span> (OwnerController) &#123;</span><br><span class="line">UGameplayStatics::<span class="built_in">ApplyDamage</span>(OtherActor, Damage, OwnerController, <span class="keyword">this</span>, UDamageType::<span class="built_in">StaticClass</span>());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Super::<span class="built_in">OnHit</span>(HitComp, OtherActor, OtherComp, NormalImpulse, Hit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在角色类中注册伤害，绑定回调函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSCharacter.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">UpdateHUDHealth</span>();</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">HasAuthority</span>()) &#123;</span><br><span class="line">OnTakeAnyDamage.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;AMultiplayerTPSCharacter::ReceiveDamage);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (AttachedGrenade) &#123;</span><br><span class="line">AttachedGrenade-&gt;<span class="built_in">SetVisibility</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::ReceiveDamage</span><span class="params">(AActor* DamagedActor, <span class="type">float</span> Damage, <span class="type">const</span> UDamageType* DamageType, AController* InstigatorController, AActor* DamageCauser)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//UE_LOG(LogTemp, Warning, TEXT(&quot;Receive damage.&quot;));</span></span><br><span class="line">Health = FMath::<span class="built_in">Clamp</span>(Health - Damage, <span class="number">0.f</span>, MaxHealth);</span><br><span class="line"><span class="built_in">UpdateHUDHealth</span>();</span><br><span class="line"><span class="built_in">PlayHitReactMontage</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前通过<code>Multicast RPC</code>实现了受击时的动画，但是RPC的和开销网络速度不如变量复制，所以现在可以通过血量的复制来实现受击动画。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::OnRep_Health</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">UpdateHUDHealth</span>();</span><br><span class="line"><span class="built_in">PlayHitReactMontage</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-淘汰"><a href="#3-淘汰" class="headerlink" title="3.淘汰"></a>3.淘汰</h2><p>淘汰是对游戏中任意玩家进行的操作，很适合放在<strong>游戏模式</strong>中。</p><p>创建自己的游戏模式类，在其中定义淘汰玩家函数和重生玩家函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSGameMode.h</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSGameMode::PlayerEliminated</span><span class="params">(AMultiplayerTPSCharacter* ElimmedCharacter, AMPTPSPlayerController* VictimController, AMPTPSPlayerController* AttackerController)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ElimmedCharacter)</span><br><span class="line">&#123;</span><br><span class="line">ElimmedCharacter-&gt;<span class="built_in">Elim</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSGameMode::RequestRespawn</span><span class="params">(ACharacter* ElimmedCharacter, AController* ElimmedController)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ElimmedCharacter) &#123;</span><br><span class="line">ElimmedCharacter-&gt;<span class="built_in">Reset</span>();</span><br><span class="line">ElimmedCharacter-&gt;<span class="built_in">Destroy</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ElimmedController) &#123;</span><br><span class="line">TArray&lt;AActor*&gt; PlayerStarts;</span><br><span class="line">UGameplayStatics::<span class="built_in">GetAllActorsOfClass</span>(<span class="keyword">this</span>, APlayerStart::<span class="built_in">StaticClass</span>(), PlayerStarts);</span><br><span class="line">int32 Selection = FMath::<span class="built_in">RandRange</span>(<span class="number">0</span>, PlayerStarts.<span class="built_in">Num</span>() - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">RestartPlayerAtPlayerStart</span>(ElimmedController, PlayerStarts[Selection]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在角色类中，当受到伤害时，如果生命值变为0就通过游戏模式将其淘汰，并通过多播RPC播放淘汰动画。当淘汰时启用一个计时器，其回调函数会调用游戏模式的重生玩家函数来复活玩家。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSCharacter.h</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Elim</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>(NetMulticast, Reliable)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MulticastElim</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> bElimmed = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSCharacter.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::ReceiveDamage</span><span class="params">(AActor* DamagedActor, <span class="type">float</span> Damage, <span class="type">const</span> UDamageType* DamageType, AController* InstigatorController, AActor* DamageCauser)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Health = FMath::<span class="built_in">Clamp</span>(Health - Damage, <span class="number">0.f</span>, MaxHealth);</span><br><span class="line"><span class="built_in">OnRep_Health</span>();</span><br><span class="line"><span class="comment">//UpdateHUDHealth();</span></span><br><span class="line"><span class="comment">//PlayHitReactMontage();</span></span><br><span class="line"><span class="keyword">if</span> (Health == <span class="number">0.f</span>) &#123;</span><br><span class="line">AMultiplayerTPSGameMode* MultiplayerTPSGameMode = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetAuthGameMode</span>&lt;AMultiplayerTPSGameMode&gt;();</span><br><span class="line"><span class="keyword">if</span> (MultiplayerTPSGameMode) &#123;</span><br><span class="line">PlayerController = PlayerController ? PlayerController : <span class="built_in">Cast</span>&lt;AMPTPSPlayerController&gt;(Controller);</span><br><span class="line">AMPTPSPlayerController* AttackerController = <span class="built_in">Cast</span>&lt;AMPTPSPlayerController&gt;(InstigatorController);</span><br><span class="line">MultiplayerTPSGameMode-&gt;<span class="built_in">PlayerEliminated</span>(<span class="keyword">this</span>, PlayerController, AttackerController);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::MulticastElim_Implementation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">bElimmed = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">PlayElimMontage</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSGameMode::PlayerEliminated</span><span class="params">(AMultiplayerTPSCharacter* ElimmedCharacter, AMPTPSPlayerController* VictimController, AMPTPSPlayerController* AttackerController)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ElimmedCharacter)</span><br><span class="line">&#123;</span><br><span class="line">ElimmedCharacter-&gt;<span class="built_in">Elim</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::Elim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">MulticastElim</span>();</span><br><span class="line"><span class="built_in">GetWorldTimerManager</span>().<span class="built_in">SetTimer</span>(</span><br><span class="line">ElimTimer,</span><br><span class="line"><span class="keyword">this</span>,</span><br><span class="line">&amp;AMultiplayerTPSCharacter::ElimTimerFinished,</span><br><span class="line">ElimDelay</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::ElimTimerFinished</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">AMultiplayerTPSGameMode* MultiplayerTPSGameMode = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetAuthGameMode</span>&lt;AMultiplayerTPSGameMode&gt;();</span><br><span class="line"><span class="keyword">if</span> (MultiplayerTPSGameMode) &#123;</span><br><span class="line">MultiplayerTPSGameMode-&gt;<span class="built_in">RequestRespawn</span>(<span class="keyword">this</span>, Controller);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在角色淘汰时为角色添加一个无人机将角色溶解的效果，可以增加游戏性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Elim Bot</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UParticleSystem* ElimBotEffect;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere)</span><br><span class="line">UParticleSystemComponent* ElimBotComponent;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">USoundCue</span>* ElimBotSound;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Spawn elim bot</span></span><br><span class="line"><span class="keyword">if</span> (ElimBotEffect) &#123;</span><br><span class="line"><span class="function">FVector <span class="title">ElimBotSpawnPoint</span><span class="params">(GetActorLocation().X, GetActorLocation().Y, GetActorLocation().Z + <span class="number">200.f</span>)</span></span>;</span><br><span class="line">ElimBotComponent = UGameplayStatics::<span class="built_in">SpawnEmitterAtLocation</span>(</span><br><span class="line"><span class="built_in">GetWorld</span>(),</span><br><span class="line">ElimBotEffect,</span><br><span class="line">ElimBotSpawnPoint,</span><br><span class="line"><span class="built_in">GetActorRotation</span>()</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ElimBotSound) &#123;</span><br><span class="line">UGameplayStatics::<span class="built_in">SpawnSoundAtLocation</span>(</span><br><span class="line"><span class="keyword">this</span>,</span><br><span class="line">ElimBotSound,</span><br><span class="line"><span class="built_in">GetActorLocation</span>()</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::Destroyed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">Destroy</span>();</span><br><span class="line"><span class="keyword">if</span> (ElimBotComponent) &#123;</span><br><span class="line">ElimBotComponent-&gt;<span class="built_in">DestroyComponent</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//溶解效果</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere)</span><br><span class="line">UTimelineComponent* DissolveTimeline;</span><br><span class="line">FOnTimelineFloat DissolveTrack;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UCurveFloat* DissolveCurve;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UpdateDissolveMaterial</span><span class="params">(<span class="type">float</span> DissolveValue)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StartDissolve</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实时改变的动态材质实例</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere, Category = <span class="string">&quot;Elim&quot;</span>)</span><br><span class="line">UMaterialInstanceDynamic* DynamicDissolveMaterialInstance;</span><br><span class="line"></span><br><span class="line"><span class="comment">//蓝图中设置的动态材质实例</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, Category = <span class="string">&quot;Elim&quot;</span>)</span><br><span class="line">UMaterialInstance* DissolveMaterialInstance;</span><br><span class="line"></span><br><span class="line">两个时间轴相关的函数：</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::UpdateDissolveMaterial</span><span class="params">(<span class="type">float</span> DissolveValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (DynamicDissolveMaterialInstance) &#123;</span><br><span class="line">DynamicDissolveMaterialInstance-&gt;<span class="built_in">SetScalarParameterValue</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Dissolve&quot;</span>), DissolveValue);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::StartDissolve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DissolveTrack.<span class="built_in">BindDynamic</span>(<span class="keyword">this</span>, &amp;AMultiplayerTPSCharacter::UpdateDissolveMaterial);</span><br><span class="line"><span class="keyword">if</span> (DissolveCurve &amp;&amp; DissolveTimeline) &#123;</span><br><span class="line">DissolveTimeline-&gt;<span class="built_in">AddInterpFloat</span>(DissolveCurve, DissolveTrack);</span><br><span class="line">DissolveTimeline-&gt;<span class="built_in">Play</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::MulticastElim_Implementation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">bElimmed = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">PlayElimMontage</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (DissolveMaterialInstance) &#123;</span><br><span class="line">DynamicDissolveMaterialInstance = UMaterialInstanceDynamic::<span class="built_in">Create</span>(DissolveMaterialInstance, <span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">GetMesh</span>()-&gt;<span class="built_in">SetMaterial</span>(<span class="number">0</span>, DynamicDissolveMaterialInstance);</span><br><span class="line">DynamicDissolveMaterialInstance-&gt;<span class="built_in">SetScalarParameterValue</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Dissolve&quot;</span>), <span class="number">0.55f</span>);</span><br><span class="line">DynamicDissolveMaterialInstance-&gt;<span class="built_in">SetScalarParameterValue</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Glow&quot;</span>), <span class="number">200.f</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">StartDissolve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当角色淘汰后要丢弃武器，为武器定义丢弃函数。丢弃武器时武器状态会改变，这时要对武器进行一些属性调整。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Weapon.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AWeapon::Dropped</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">SetWeaponState</span>(EWeaponState::EWS_Dropped);</span><br><span class="line"><span class="function">FDetachmentTransformRules <span class="title">DetachRules</span><span class="params">(EDetachmentRule::KeepWorld, <span class="literal">true</span>)</span></span>;</span><br><span class="line">WeaponMesh-&gt;<span class="built_in">DetachFromComponent</span>(DetachRules);</span><br><span class="line"><span class="built_in">SetOwner</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AWeapon::OnRep_WeaponState</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (WeaponState) &#123;</span><br><span class="line"><span class="keyword">case</span> EWeaponState::EWS_Equipped:</span><br><span class="line"><span class="built_in">ShowPickWidget</span>(<span class="literal">false</span>);</span><br><span class="line">AreaSphere-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);</span><br><span class="line">WeaponMesh-&gt;<span class="built_in">SetSimulatePhysics</span>(<span class="literal">false</span>);</span><br><span class="line">WeaponMesh-&gt;<span class="built_in">SetEnableGravity</span>(<span class="literal">false</span>);</span><br><span class="line">WeaponMesh-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EWeaponState::EWS_Dropped:</span><br><span class="line">WeaponMesh-&gt;<span class="built_in">SetSimulatePhysics</span>(<span class="literal">true</span>);</span><br><span class="line">WeaponMesh-&gt;<span class="built_in">SetEnableGravity</span>(<span class="literal">true</span>);</span><br><span class="line">WeaponMesh-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::QueryAndPhysics);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AWeapon::SetWeaponState</span><span class="params">(EWeaponState State)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">WeaponState = State;</span><br><span class="line"><span class="keyword">switch</span> (WeaponState) &#123;</span><br><span class="line"><span class="keyword">case</span> EWeaponState::EWS_Equipped:</span><br><span class="line"><span class="built_in">ShowPickWidget</span>(<span class="literal">false</span>);</span><br><span class="line">AreaSphere-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);</span><br><span class="line">WeaponMesh-&gt;<span class="built_in">SetSimulatePhysics</span>(<span class="literal">false</span>);</span><br><span class="line">WeaponMesh-&gt;<span class="built_in">SetEnableGravity</span>(<span class="literal">false</span>);</span><br><span class="line">WeaponMesh-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EWeaponState::EWS_Dropped:</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">HasAuthority</span>()) &#123;</span><br><span class="line">AreaSphere-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::QueryOnly);</span><br><span class="line">&#125;</span><br><span class="line">WeaponMesh-&gt;<span class="built_in">SetSimulatePhysics</span>(<span class="literal">true</span>);</span><br><span class="line">WeaponMesh-&gt;<span class="built_in">SetEnableGravity</span>(<span class="literal">true</span>);</span><br><span class="line">WeaponMesh-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::QueryAndPhysics);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得拾取武器时也要设一下状态。</p><h2 id="4-玩家状态"><a href="#4-玩家状态" class="headerlink" title="4.玩家状态"></a>4.玩家状态</h2><p><strong>玩家状态</strong>是跟踪和记录玩家信息的一个类，存在于每一个客户端中。它不适合用来保存血量、弹药等需要及时同步的变量，而是通常用来保存得分、死亡数等信息。</p><p>创建自己的玩家状态类，通过复制来更新和同步分数及分数的HUD。其中Score是玩家状态自带的变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSPlayerState::AddToScore</span><span class="params">(<span class="type">float</span> ScoreAmount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">SetScore</span>(Score + ScoreAmount);</span><br><span class="line">Character = Character ? Character : <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(<span class="built_in">GetPawn</span>());</span><br><span class="line"><span class="keyword">if</span> (Character) &#123;</span><br><span class="line">Controller = Controller ? Controller : <span class="built_in">Cast</span>&lt;AMPTPSPlayerController&gt;(Character-&gt;Controller);</span><br><span class="line"><span class="keyword">if</span> (Controller) &#123;</span><br><span class="line">Controller-&gt;<span class="built_in">SetHUDScore</span>(<span class="built_in">GetScore</span>());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSPlayerState::OnRep_Score</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">OnRep_Score</span>();</span><br><span class="line">Character = Character ? Character : <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(<span class="built_in">GetPawn</span>());</span><br><span class="line"><span class="keyword">if</span> (Character) &#123;</span><br><span class="line">Controller = Controller ? Controller : <span class="built_in">Cast</span>&lt;AMPTPSPlayerController&gt;(Character-&gt;Controller);</span><br><span class="line"><span class="keyword">if</span> (Controller) &#123;</span><br><span class="line">Controller-&gt;<span class="built_in">SetHUDScore</span>(<span class="built_in">GetScore</span>());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MPTPSPlayerController.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::SetHUDScore</span><span class="params">(<span class="type">float</span> Score)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MultiplayerTPSHUD = MultiplayerTPSHUD == <span class="literal">nullptr</span> ? <span class="built_in">Cast</span>&lt;AMultiplayerTPSHUD&gt;(<span class="built_in">GetHUD</span>()) : MultiplayerTPSHUD;</span><br><span class="line"><span class="keyword">if</span> (MultiplayerTPSHUD &amp;&amp; MultiplayerTPSHUD-&gt;CharacterOverlay &amp;&amp; MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;ScoreAmount) &#123;</span><br><span class="line">FString ScoreText = FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;%d&quot;</span>), FMath::<span class="built_in">FloorToInt</span>(Score));</span><br><span class="line">MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;ScoreAmount-&gt;<span class="built_in">SetText</span>(FText::<span class="built_in">FromString</span>(ScoreText));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>游戏开始时我们要将Score设为0，但是在角色的<code>BeginPlay</code>运行时，游戏状态可能还未初始化导致我们无法访问并对其进行操作，所以定义了一个轮询函数在Tick中调用来初始化游戏状态：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::PollInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!MultiplayerTPSPlayerState) &#123;</span><br><span class="line">MultiplayerTPSPlayerState = <span class="built_in">GetPlayerState</span>&lt;AMultiplayerTPSPlayerState&gt;();</span><br><span class="line"><span class="keyword">if</span> (MultiplayerTPSPlayerState) &#123;</span><br><span class="line">MultiplayerTPSPlayerState-&gt;<span class="built_in">AddToScore</span>(<span class="number">0.f</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是淘汰数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSPlayerState.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(ReplicatedUsing = OnRep_Defeats)</span><br><span class="line">int32 Defeats;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnRep_Defeats</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSPlayerState::GetLifetimeReplicatedProps</span><span class="params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">GetLifetimeReplicatedProps</span>(OutLifetimeProps);</span><br><span class="line"></span><br><span class="line"><span class="built_in">DOREPLIFETIME</span>(AMultiplayerTPSPlayerState, Defeats);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSPlayerState::AddToDefeats</span><span class="params">(int32 DefeatsAmount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Defeats += DefeatsAmount;</span><br><span class="line">Character = Character ? Character : <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(<span class="built_in">GetPawn</span>());</span><br><span class="line"><span class="keyword">if</span> (Character) &#123;</span><br><span class="line">Controller = Controller ? Controller : <span class="built_in">Cast</span>&lt;AMPTPSPlayerController&gt;(Character-&gt;Controller);</span><br><span class="line"><span class="keyword">if</span> (Controller) &#123;</span><br><span class="line">Controller-&gt;<span class="built_in">SetHUDDefeats</span>(Defeats);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSPlayerState::OnRep_Defeats</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Character = Character ? Character : <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(<span class="built_in">GetPawn</span>());</span><br><span class="line"><span class="keyword">if</span> (Character) &#123;</span><br><span class="line">Controller = Controller ? Controller : <span class="built_in">Cast</span>&lt;AMPTPSPlayerController&gt;(Character-&gt;Controller);</span><br><span class="line"><span class="keyword">if</span> (Controller) &#123;</span><br><span class="line">Controller-&gt;<span class="built_in">SetHUDDefeats</span>(Defeats);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制器中的HUD更新函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::SetHUDDefeats</span><span class="params">(int32 Defeats)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MultiplayerTPSHUD = MultiplayerTPSHUD == <span class="literal">nullptr</span> ? <span class="built_in">Cast</span>&lt;AMultiplayerTPSHUD&gt;(<span class="built_in">GetHUD</span>()) : MultiplayerTPSHUD;</span><br><span class="line"><span class="keyword">if</span> (MultiplayerTPSHUD &amp;&amp; MultiplayerTPSHUD-&gt;CharacterOverlay &amp;&amp; MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;DefeatsAmount) &#123;</span><br><span class="line">FString DefeatsText = FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;%d&quot;</span>), Defeats);</span><br><span class="line">MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;DefeatsAmount-&gt;<span class="built_in">SetText</span>(FText::<span class="built_in">FromString</span>(DefeatsText));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在游戏模式中，当玩家被淘汰时，攻击者的得分+1，受害者的失败数+1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSGameMode::PlayerEliminated</span><span class="params">(AMultiplayerTPSCharacter* ElimmedCharacter, AMPTPSPlayerController* VictimController, AMPTPSPlayerController* AttackerController)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">AMultiplayerTPSPlayerState* AttackerPlayerState = AttackerController ? <span class="built_in">Cast</span>&lt;AMultiplayerTPSPlayerState&gt;(AttackerController-&gt;PlayerState) : <span class="literal">nullptr</span>;</span><br><span class="line">AMultiplayerTPSPlayerState* VictimPlayerState = VictimController ? <span class="built_in">Cast</span>&lt;AMultiplayerTPSPlayerState&gt;(VictimController-&gt;PlayerState) : <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (AttackerPlayerState &amp;&amp; AttackerPlayerState != VictimPlayerState) &#123;</span><br><span class="line">AttackerPlayerState-&gt;<span class="built_in">AddToScore</span>(<span class="number">1.f</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (VictimController) &#123;</span><br><span class="line">VictimPlayerState-&gt;<span class="built_in">AddToDefeats</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ElimmedCharacter)</span><br><span class="line">&#123;</span><br><span class="line">ElimmedCharacter-&gt;<span class="built_in">Elim</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-玩家携带弹药"><a href="#5-玩家携带弹药" class="headerlink" title="5.玩家携带弹药"></a>5.玩家携带弹药</h2><p>声明一个表示武器类型的枚举（之后会有更多类型）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UENUM</span>(BlueprintType)</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">EWeaponType</span> :uint8 &#123;</span><br><span class="line"><span class="function">EWT_AssaultRifle <span class="title">UMETA</span><span class="params">(Displayname=<span class="string">&quot;Assult Rifle&quot;</span>)</span>,</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">EWT_MAX <span class="title">UMETA</span><span class="params">(Displayname = <span class="string">&quot;DefaultMAX&quot;</span>)</span></span></span><br><span class="line"><span class="function">&#125;</span>;</span><br></pre></td></tr></table></figure><p>之前我们用一个整型来表示玩家的携带弹药，而现在有多种武器类型，也就需要多种携带弹药。</p><p>然而并不需要为每一种武器类型都创建一个变量。我们可以使用一个<code>TMap</code>来保存所有武器类型对应的携带弹药。<code>TMap</code>的底层实现是哈希表，由于在每台机器上的哈希结果不一定相同，因此<code>TMap</code>是不能复制的。不过我们也不需要对其进行复制，因为备弹的相关处理逻辑都是在服务器上进行的，只需要同步好<code>CarriedAmmo</code>就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(ReplicatedUsing = OnRep_CarriedAmmo)</span><br><span class="line">int32 CarriedAmmo;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnRep_CarriedAmmo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">TMap&lt;EWeaponType, int32&gt; CarriedAmmoMap;</span><br></pre></td></tr></table></figure><p>在战斗组件中为每一种武器初始化备弹，装备武器时将备弹显示设为装备的武器类型的备弹。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Weapon.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">EWeaponType WeaponType;</span><br><span class="line"></span><br><span class="line"><span class="function">FORCEINLINE EWeaponType <span class="title">GetWeaponType</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> WeaponType; &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CombatComponent.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::InitializeCarriedAmmo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CarriedAmmoMap.<span class="built_in">Emplace</span>(EWeaponType::EWT_AssaultRifle, StartingARAmmo);</span><br><span class="line">    <span class="comment">//...更多武器类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::EquipWeapon</span><span class="params">(AWeapon* WeaponToEquip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (CarriedAmmoMap.<span class="built_in">Contains</span>(EquippedWeapon-&gt;<span class="built_in">GetWeaponType</span>())) &#123;</span><br><span class="line">CarriedAmmo = CarriedAmmoMap[EquippedWeapon-&gt;<span class="built_in">GetWeaponType</span>()];</span><br><span class="line">&#125;</span><br><span class="line">Controller = Controller ? Controller : <span class="built_in">Cast</span>&lt;AMPTPSPlayerController&gt;(Character-&gt;Controller);</span><br><span class="line"><span class="keyword">if</span> (Controller) &#123;</span><br><span class="line">Controller-&gt;<span class="built_in">SetHUDCarriedAmmo</span>(CarriedAmmo);</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-换弹"><a href="#6-换弹" class="headerlink" title="6.换弹"></a>6.换弹</h2><p>声明一个枚举来表示玩家当前的角色状态：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UENUM</span>(BlueprintType)</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">ECombatState</span> :uint8 &#123;</span><br><span class="line"><span class="function">ECS_Unoccupied <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Unoccupied&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">ECS_Reloading <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Reloading&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">ECS_MAX <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;DefaultMAX&quot;</span>)</span></span></span><br><span class="line"><span class="function">&#125;</span>;</span><br></pre></td></tr></table></figure><p>按下Reload键后触发回调函数，调用战斗组件中的换弹函数，只有战斗状态为<code>Unoccupied</code>时才能换弹。换弹只能在服务器上进行，所以调用换弹后要调用<code>Server RPC</code>。服务器上实现真正的换弹逻辑。这样就完成了服务器上的换弹逻辑，之后需要进行同步。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CombatComponent.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::Reload</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (CarriedAmmo &gt; <span class="number">0</span> &amp;&amp; CombatState == ECombatState::ECS_Unoccupied) &#123;</span><br><span class="line"><span class="built_in">ServerReload</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::ServerReload_Implementation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!Character) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">CombatState = ECombatState::ECS_Reloading;</span><br><span class="line"><span class="built_in">HandleReload</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>角色根据武器类型跳转到动画蒙太奇的对应片段。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSCharacter.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::PlayReloadMontage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!Combat || !Combat-&gt;EquippedWeapon) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UAnimInstance* AnimInstance = <span class="built_in">GetMesh</span>()-&gt;<span class="built_in">GetAnimInstance</span>();</span><br><span class="line"><span class="keyword">if</span> (AnimInstance &amp;&amp; ReloadMontage) &#123;</span><br><span class="line">AnimInstance-&gt;<span class="built_in">Montage_Play</span>(ReloadMontage);</span><br><span class="line">FName SectionName;</span><br><span class="line"><span class="keyword">switch</span> (Combat-&gt;EquippedWeapon-&gt;<span class="built_in">GetWeaponType</span>()) &#123;</span><br><span class="line"><span class="keyword">case</span> EWeaponType::EWT_AssaultRifle:</span><br><span class="line">SectionName = <span class="built_in">FName</span>(<span class="string">&quot;Rifle&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">AnimInstance-&gt;<span class="built_in">Montage_JumpToSection</span>(SectionName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>战斗组件中持有当前状态，设为复制，回调函数中根据战斗状态进行同步操作，如当战斗状态变为<code>Reloading</code>时播放换弹动画：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CombatComponent.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(ReplicatedUsing = OnRep_CombatState)</span><br><span class="line">ECombatState CombatState = ECombatState::ECS_Unoccupied;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnRep_CombatState</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CombatComponent.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::OnRep_CombatState</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (CombatState)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> ECombatState::ECS_Unoccupied:</span><br><span class="line"><span class="keyword">if</span> (bFireButtonPressed) &#123;</span><br><span class="line"><span class="built_in">Fire</span>();</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ECombatState::ECS_Reloading:</span><br><span class="line"><span class="built_in">HandleReload</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ECombatState::ECS_MAX:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在换弹的动画蒙太奇结尾加一个通知，调用结束换弹的函数；当可以开火时如果按着开火键，我们希望玩家能立刻开火，所以在换弹结束和战斗状态变为空闲时，如果开火键被按下就开火：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::FinishReloading</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CombatState = ECombatState::ECS_Unoccupied;</span><br><span class="line"><span class="keyword">if</span> (bFireButtonPressed) &#123;</span><br><span class="line"><span class="built_in">Fire</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当换弹的时候不能开火，在判断开火条件时加上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UCombatComponent::CanFire</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!EquippedWeapon) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> !EquippedWeapon-&gt;<span class="built_in">IsEmpty</span>() &amp;&amp; bCanFire &amp;&amp; CombatState == ECombatState::ECS_Unoccupied;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是真正的换弹逻辑了。在战斗组件中定义计算要上多少子弹的函数，当触发结束换弹动画通知的时候执行弹药的更新逻辑。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CombatComponent.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::FinishReloading</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!Character) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (Character-&gt;<span class="built_in">HasAuthority</span>()) &#123;</span><br><span class="line">CombatState = ECombatState::ECS_Unoccupied;</span><br><span class="line"><span class="built_in">UpdateAmmoValues</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bFireButtonPressed) &#123;</span><br><span class="line"><span class="built_in">Fire</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">int32 <span class="title">UCombatComponent::AmountToReload</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!EquippedWeapon) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">int32 RoomInMag = EquippedWeapon-&gt;<span class="built_in">GetMagCapacity</span>() - EquippedWeapon-&gt;<span class="built_in">GetAmmo</span>();</span><br><span class="line"><span class="keyword">if</span> (CarriedAmmoMap.<span class="built_in">Contains</span>(EquippedWeapon-&gt;<span class="built_in">GetWeaponType</span>())) &#123;</span><br><span class="line">int32 AmountCarried = CarriedAmmoMap[EquippedWeapon-&gt;<span class="built_in">GetWeaponType</span>()];</span><br><span class="line">int32 Least = FMath::<span class="built_in">Min</span>(RoomInMag, AmountCarried);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> FMath::<span class="built_in">Clamp</span>(RoomInMag, <span class="number">0</span>, Least);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::UpdateAmmoValues</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!EquippedWeapon) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">int32 ReloadAmount = <span class="built_in">AmountToReload</span>();</span><br><span class="line"><span class="keyword">if</span> (CarriedAmmoMap.<span class="built_in">Contains</span>(EquippedWeapon-&gt;<span class="built_in">GetWeaponType</span>())) &#123;</span><br><span class="line">CarriedAmmoMap[EquippedWeapon-&gt;<span class="built_in">GetWeaponType</span>()] -= ReloadAmount;</span><br><span class="line">CarriedAmmo = CarriedAmmoMap[EquippedWeapon-&gt;<span class="built_in">GetWeaponType</span>()];</span><br><span class="line">&#125;</span><br><span class="line">Controller = Controller ? Controller : <span class="built_in">Cast</span>&lt;AMPTPSPlayerController&gt;(Character-&gt;Controller);</span><br><span class="line"><span class="keyword">if</span> (Controller) &#123;</span><br><span class="line">Controller-&gt;<span class="built_in">SetHUDCarriedAmmo</span>(CarriedAmmo);</span><br><span class="line">&#125;</span><br><span class="line">EquippedWeapon-&gt;<span class="built_in">AddAmmo</span>(ReloadAmount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Weapon.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AWeapon::AddAmmo</span><span class="params">(int32 AmmoToAdd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Ammo = FMath::<span class="built_in">Clamp</span>(Ammo + AmmoToAdd, <span class="number">0</span>, MagCapacity);</span><br><span class="line"><span class="built_in">SetHUDAmmo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-游戏时间与服务器计时"><a href="#7-游戏时间与服务器计时" class="headerlink" title="7.游戏时间与服务器计时"></a>7.游戏时间与服务器计时</h2><p>一局游戏是有一个时间的。对于服务器，只要获取游戏时间就行了，但是对于客户端，有可能存在中途加入游戏、加载时间过长等情况，因此不能直接使用本地的游戏时间，而是要获取服务器的游戏时间。然而，和服务器进行通信也需要时间，如果直接从服务器获取游戏时间仍然存在滞后。所有这里要进行一些小计算。</p><p>先放一下设置游戏倒计时的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::SetHUDMatchCountdown</span><span class="params">(<span class="type">float</span> CountdownTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MultiplayerTPSHUD = MultiplayerTPSHUD == <span class="literal">nullptr</span> ? <span class="built_in">Cast</span>&lt;AMultiplayerTPSHUD&gt;(<span class="built_in">GetHUD</span>()) : MultiplayerTPSHUD;</span><br><span class="line"><span class="keyword">if</span> (MultiplayerTPSHUD &amp;&amp; MultiplayerTPSHUD-&gt;CharacterOverlay &amp;&amp; MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;MatchCountdownText) &#123;</span><br><span class="line">int32 Minutes = FMath::<span class="built_in">FloorToInt</span>(CountdownTime / <span class="number">60.f</span>);</span><br><span class="line">int32 Seconds = CountdownTime - Minutes * <span class="number">60</span>;</span><br><span class="line">FString CountdowmText = FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;%02d:%02d&quot;</span>), Minutes, Seconds);</span><br><span class="line">MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;MatchCountdownText-&gt;<span class="built_in">SetText</span>(FText::<span class="built_in">FromString</span>(CountdowmText));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>RTT(Round-Trip Time)</code></strong>是我们耳熟能详的概念，表示两台计算机进行网络通信时信息传输所花费的时间。当客户端获取到了服务器的游戏时间，只要再加上RTT，不就是客户端当前的游戏时间吗。</p><p>这里使用了一个<code>Server RPC</code>和一个<code>Client RPC</code>。当客户端请求服务器的游戏时间时，调用<code>Server RPC</code>，发送自己发送请求的时间；服务器在执行<code>Server RPC</code>时调用<code>Client RPC</code>，将客户端的请求时间和服务器的游戏时间一起发送给客户端。这样，客户端通过将本地时间减去自己发送请求的时间，就得到了<code>RTT</code>。需要注意，<code>RTT</code>是从自己发送请求到服务器，到服务器的回复送达客户端的时间，而这里得到了服务器的游戏时间，只要加上服务器的回复发送到客户端时间就行了。双向通信的时间不一定是对称的，但是这里近似为对称的。将服务器的游戏时间加上一半的<code>RTT</code>，就得到了比较准确的客户端本地游戏时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::ServerRequestServerTime_Implementation</span><span class="params">(<span class="type">float</span> TimeOfClientRequest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">float</span> ServerTimeOfReceipt = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetTimeSeconds</span>();</span><br><span class="line"><span class="built_in">ClientReportServerTime</span>(TimeOfClientRequest, ServerTimeOfReceipt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::ClientReportServerTime_Implementation</span><span class="params">(<span class="type">float</span> TimeOfClientRequest, <span class="type">float</span> TimeServerReveivedClientRequest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">float</span> RoundTripTime = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetTimeSeconds</span>() - TimeOfClientRequest;</span><br><span class="line"><span class="type">float</span> CurrentServerTime = TimeServerReveivedClientRequest + (<span class="number">0.5f</span> * RoundTripTime);</span><br><span class="line">ClientServerDelta = CurrentServerTime - <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetTimeSeconds</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">AMPTPSPlayerController::GetServerTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">HasAuthority</span>()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetTimeSeconds</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetTimeSeconds</span>() + ClientServerDelta;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每隔一段时间就同步一次游戏时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求当前服务器时间，发送客户端发送请求的时间</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(Server, Reliable)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ServerRequestServerTime</span><span class="params">(<span class="type">float</span> TimeOfClientRequest)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回应客户端请求，向客户端报告当前服务器时间</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(Client, Reliable)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClientReportServerTime</span><span class="params">(<span class="type">float</span> TimeOfClientRequest, <span class="type">float</span> TimeServerReveivedClientRequest)</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> ClientServerDelta = <span class="number">0.f</span>; <span class="comment">//客户端和服务器之间的时间差</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, Category = <span class="string">&quot;Time&quot;</span>)</span><br><span class="line"><span class="type">float</span> TimeSyncFrequency = <span class="number">5.f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> TimeSyncRunningTime = <span class="number">0.f</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CheckTimeSync</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">Tick</span>(DeltaTime);</span><br><span class="line"><span class="built_in">SetHUDTime</span>();</span><br><span class="line"><span class="built_in">CheckTimeSync</span>(DeltaTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::CheckTimeSync</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TimeSyncRunningTime += DeltaTime;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IsLocalController</span>() &amp;&amp; TimeSyncRunningTime &gt; TimeSyncFrequency) &#123;</span><br><span class="line"><span class="built_in">ServerRequestServerTime</span>(<span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetTimeSeconds</span>());</span><br><span class="line">TimeSyncRunningTime = <span class="number">0.f</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::SetHUDTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">uint32 SecondLeft = FMath::<span class="built_in">CeilToInt</span>(MatchTime - <span class="built_in">GetServerTime</span>());</span><br><span class="line"><span class="keyword">if</span> (CountdownInt != SecondLeft) &#123;</span><br><span class="line"><span class="built_in">SetHUDMatchCountdown</span>(MatchTime - <span class="built_in">GetServerTime</span>());</span><br><span class="line">&#125;</span><br><span class="line">CountdownInt = SecondLeft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-比赛状态"><a href="#8-比赛状态" class="headerlink" title="8.比赛状态"></a>8.比赛状态</h2><p>在<code>GameMode</code>类中除了继承了<code>GameModeBase</code>类中的基础功能，还实现了<code>MatchState</code>的相关功能实现。简单来说，我们可以使用<code>GameMode</code>类提供的游戏状态和我们自己定义的比赛状态来控制和管理游戏的不同阶段，以及转换阶段时的操作。</p><p>从最简单的开始。当进入游戏后，我不希望直接开始游戏，而是有一个热身阶段，热身结束后正式开始比赛，并进入<code>InProgress</code>的比赛状态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">AMultiplayerTPSGameMode::<span class="built_in">AMultiplayerTPSGameMode</span>()</span><br><span class="line">&#123;</span><br><span class="line">bDelayedStart = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSGameMode::Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">Tick</span>(DeltaTime);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (MatchState == MatchState::WaitingToStart) &#123;</span><br><span class="line">CountdownTime = WarmupTime - <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetTimeSeconds</span>() + LevelStartingTime;</span><br><span class="line"><span class="keyword">if</span> (CountdownTime &lt;= <span class="number">0.f</span>) &#123;</span><br><span class="line"><span class="built_in">StartMatch</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSGameMode::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">LevelStartingTime = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetTimeSeconds</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当比赛状态改变时会调用<code>OnMatchStateSet</code>函数，可以在里面设置控制器的比赛状态变量，并由此进行相关的操作。例如，当比赛状态变成<code>InProgress</code>时，就开始显示<code>HUD</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSGameMode::OnMatchStateSet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">OnMatchStateSet</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (FConstPlayerControllerIterator It = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetPlayerControllerIterator</span>();It;++It) &#123;</span><br><span class="line">AMPTPSPlayerController* MultiplayerTPSPlayer = <span class="built_in">Cast</span>&lt;AMPTPSPlayerController&gt;(*It);</span><br><span class="line"><span class="keyword">if</span> (MultiplayerTPSPlayer) &#123;</span><br><span class="line">MultiplayerTPSPlayer-&gt;<span class="built_in">OnMatchStateSet</span>(MatchState);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::OnRep_MatchState</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (MatchState == MatchState::InProgress) &#123;</span><br><span class="line">MultiplayerTPSHUD = MultiplayerTPSHUD == <span class="literal">nullptr</span> ? <span class="built_in">Cast</span>&lt;AMultiplayerTPSHUD&gt;(<span class="built_in">GetHUD</span>()) : MultiplayerTPSHUD;</span><br><span class="line"><span class="keyword">if</span> (MultiplayerTPSHUD) &#123;</span><br><span class="line">MultiplayerTPSHUD-&gt;<span class="built_in">AddCharacterOverlay</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在一个问题。之前当HUD创建后在<code>BeginPlay</code>中就创建Overlay，此时控制器可以直接在游戏刚开始时设置相关的属性。但是现在有了一个等待时间，Overlay还没有创建出来，导致控制器无法准确初始化数值。解决方法是如果设置Overlay时Overlay还没有创建，就用变量将这些值保存下来，在Tick中轮询Overlay，如果发现Overlay创建好了，就用之前保存的值来初始化Overlay。之后如果有新的变量需要设置，就不再重复了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MPTPSPlayerCharacter.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::SetHUDHealth</span><span class="params">(<span class="type">float</span> Health, <span class="type">float</span> MaxHealth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MultiplayerTPSHUD = MultiplayerTPSHUD == <span class="literal">nullptr</span> ? <span class="built_in">Cast</span>&lt;AMultiplayerTPSHUD&gt;(<span class="built_in">GetHUD</span>()) : MultiplayerTPSHUD;</span><br><span class="line"><span class="keyword">if</span> (MultiplayerTPSHUD &amp;&amp; MultiplayerTPSHUD-&gt;CharacterOverlay &amp;&amp; MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HealthBar &amp;&amp; MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HealthText) &#123;</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> HealthPercent = Health / MaxHealth;</span><br><span class="line">MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HealthBar-&gt;<span class="built_in">SetPercent</span>(HealthPercent);</span><br><span class="line">FString HealthText = FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;%d/%d&quot;</span>), FMath::<span class="built_in">CeilToInt</span>(Health), FMath::<span class="built_in">CeilToInt</span>(MaxHealth));</span><br><span class="line">MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;HealthText-&gt;<span class="built_in">SetText</span>(FText::<span class="built_in">FromString</span>(HealthText));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">bInitializerCharacterOverlay = <span class="literal">true</span>;</span><br><span class="line">HUDHealth = Health;</span><br><span class="line">HUDMaxHealth = MaxHealth;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">Tick</span>(DeltaTime);</span><br><span class="line"><span class="built_in">SetHUDTime</span>();</span><br><span class="line"><span class="built_in">CheckTimeSync</span>(DeltaTime);</span><br><span class="line"><span class="built_in">PollInit</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::PollInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!CharacterOverlay) &#123;</span><br><span class="line"><span class="keyword">if</span> (MultiplayerTPSHUD &amp;&amp; MultiplayerTPSHUD-&gt;CharacterOverlay) &#123;</span><br><span class="line">CharacterOverlay = MultiplayerTPSHUD-&gt;CharacterOverlay;</span><br><span class="line"><span class="keyword">if</span> (CharacterOverlay) &#123;</span><br><span class="line"><span class="built_in">SetHUDHealth</span>(HUDHealth, HUDMaxHealth);</span><br><span class="line"><span class="built_in">SetHUDScore</span>(HUDScore);</span><br><span class="line"><span class="built_in">SetHUDDefeats</span>(HUDDefeats);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是自定义的比赛状态。比赛状态是定义在一个命名空间中的，可以直接在这个命名空间中定义自己的比赛状态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> MatchState</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">extern</span> MULTIPLAYERTPS_API <span class="type">const</span> FName Cooldown; <span class="comment">//比赛持续时间结束，显示胜者并开始冷却计时</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MatchState &#123;</span><br><span class="line"><span class="type">const</span> FName Cooldown = <span class="built_in">FName</span>(<span class="string">&quot;Cooldown&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制器中新增了对加入Cooldown状态的处理： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::OnRep_MatchState</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (MatchState == MatchState::InProgress) &#123;</span><br><span class="line"><span class="built_in">HandleMatchHasStarted</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (MatchState == MatchState::Cooldown) &#123;</span><br><span class="line"><span class="built_in">HandleCooldown</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTPSPlayerController::HandleCooldown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MultiplayerTPSHUD = MultiplayerTPSHUD == <span class="literal">nullptr</span> ? <span class="built_in">Cast</span>&lt;AMultiplayerTPSHUD&gt;(<span class="built_in">GetHUD</span>()) : MultiplayerTPSHUD;</span><br><span class="line"><span class="keyword">if</span> (MultiplayerTPSHUD) &#123;</span><br><span class="line">MultiplayerTPSHUD-&gt;CharacterOverlay-&gt;<span class="built_in">RemoveFromParent</span>();</span><br><span class="line"><span class="keyword">if</span> (MultiplayerTPSHUD-&gt;Announcement) &#123;</span><br><span class="line">MultiplayerTPSHUD-&gt;Announcement-&gt;<span class="built_in">SetVisibility</span>(ESlateVisibility::Visible);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-各种武器"><a href="#9-各种武器" class="headerlink" title="9.各种武器"></a>9.各种武器</h2><p>目前已经完成了射击游戏的大部分核心内容，包括完善的开火、换弹等逻辑，以及<strong>武器和弹药基类</strong>。要实现多种多样的武器，只需要在之前的基础上添加各种武器特有的功能就行了。这就是精心设计基类的好处啊。</p><p>之前已经设计好了武器类，及其两个派生类：<strong><code>ProjectileWeapon</code>（弹道武器）和<code>HitscanWeapon</code>（即时命中武器）</strong>。弹道武器的设计主要集中在投射物上，而即时命中武器的设计则集中于武器本身。</p><p><em>注意，对于每一种新武器，都要添加对应的武器类型以及初始弹药。</em></p><h3 id="9-1-火箭发射器（天降正义！）"><a href="#9-1-火箭发射器（天降正义！）" class="headerlink" title="9.1 火箭发射器（天降正义！）"></a>9.1 火箭发射器（天降正义！）</h3><p>和上面说的一样，火箭发射器和突击步枪没什么本质区别，区别只是发射的子弹不同罢了。从<code>Projectile</code>类派生<code>ProjectileRocket</code>类。</p><p>仔细思考，火箭弹和子弹有什么区别？首先<strong>命中时不是直接对命中的角色造成伤害，而是造成范围伤害</strong>；其次火箭弹的飞行速度较慢，因此必须要有<strong>自己的网格体</strong>；最后，火箭弹在飞行时会有<strong>逐渐消散的烟雾尾迹，以及飞行音效</strong>，不能和子弹一样直接绑定一个尾迹。</p><p>至于其它部分，如命中音效、特效等，就和基类没什么区别了，直接在编辑器中指定即可。</p><p>知道了火箭弹独有的特性，接下来去实现就可以了。网格体和范围伤害没什么好说的，对于尾迹，这里使用了<code>Niagara</code>系统，而随之而来的一个问题是，<code>Niagara</code>系统组件是绑定在火箭弹上的，<strong>如果火箭弹发射碰撞后直接被摧毁，那么<code>Niagara</code>系统组件也会被摧毁，导致尾迹直接全部消失</strong>。这里的解决方法是发生碰撞后不直接摧毁火箭弹，而是将其隐藏并关闭碰撞，并启动计时器，当计时器结束时尾迹已经消失了，这时候再摧毁火箭弹就没问题了。相应的，<code>Projectile</code>类中音效、特性和伤害等逻辑无论时在<code>OnHit</code>中触发还是在<code>Destroyed</code>中触发都没问题，而在火箭弹中必须在<code>OnHit</code>中触发。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ProjectileRocket.cpp</span></span><br><span class="line">AProjectileRocket::<span class="built_in">AProjectileRocket</span>()</span><br><span class="line">&#123;</span><br><span class="line">RocketMesh = <span class="built_in">CreateDefaultSubobject</span>&lt;UStaticMeshComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;Rocket Mesh&quot;</span>));</span><br><span class="line">RocketMesh-&gt;<span class="built_in">SetupAttachment</span>(RootComponent);</span><br><span class="line">RocketMesh-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AProjectileRocket::OnHit</span><span class="params">(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, <span class="type">const</span> FHitResult&amp; Hit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">APawn* FiringPawn = <span class="built_in">GetInstigator</span>();</span><br><span class="line"><span class="keyword">if</span> (FiringPawn &amp;&amp; <span class="built_in">HasAuthority</span>()) &#123;</span><br><span class="line">AController* FiringController = FiringPawn-&gt;<span class="built_in">GetController</span>();</span><br><span class="line"><span class="keyword">if</span> (FiringController) &#123;</span><br><span class="line"><span class="comment">//添加径向伤害</span></span><br><span class="line">            UGameplayStatics::<span class="built_in">ApplyRadialDamageWithFalloff</span>(</span><br><span class="line"><span class="keyword">this</span>, <span class="comment">//世界上下文对象</span></span><br><span class="line">Damage, <span class="comment">//基础伤害</span></span><br><span class="line"><span class="number">10.f</span>, <span class="comment">//最低伤害</span></span><br><span class="line"><span class="built_in">GetActorLocation</span>(), <span class="comment">//原点</span></span><br><span class="line"><span class="number">200.f</span>, <span class="comment">//内圈半径</span></span><br><span class="line"><span class="number">500.f</span>, <span class="comment">//外圈半径</span></span><br><span class="line"><span class="number">1.f</span>, <span class="comment">//伤害衰减</span></span><br><span class="line">UDamageType::<span class="built_in">StaticClass</span>(), <span class="comment">//伤害类</span></span><br><span class="line"><span class="built_in">TArray</span>&lt;AActor*&gt;(), <span class="comment">//忽略的Actor</span></span><br><span class="line"><span class="keyword">this</span>, <span class="comment">//造成伤害的Actor</span></span><br><span class="line">FiringController <span class="comment">//发起者控制器</span></span><br><span class="line">);</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">GetWorldTimerManager</span>().<span class="built_in">SetTimer</span>(</span><br><span class="line">DestroyTimer,</span><br><span class="line"><span class="keyword">this</span>,</span><br><span class="line">&amp;AProjectileRocket::DestroyTimerFinished,</span><br><span class="line">DestroyTime</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ImpactParticles) &#123;</span><br><span class="line">UGameplayStatics::<span class="built_in">SpawnEmitterAtLocation</span>(<span class="built_in">GetWorld</span>(), ImpactParticles, <span class="built_in">GetActorTransform</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ImpactSound) &#123;</span><br><span class="line">UGameplayStatics::<span class="built_in">PlaySoundAtLocation</span>(<span class="keyword">this</span>, ImpactSound, <span class="built_in">GetActorLocation</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (RocketMesh) &#123;</span><br><span class="line">RocketMesh-&gt;<span class="built_in">SetVisibility</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (CollisionBox) &#123;</span><br><span class="line">CollisionBox-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (TrailSystemComponent &amp;&amp; TrailSystemComponent-&gt;<span class="built_in">GetSystemInstance</span>()) &#123;</span><br><span class="line">TrailSystemComponent-&gt;<span class="built_in">GetSystemInstance</span>()-&gt;<span class="built_in">Deactivate</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ProjectileLoopComponent &amp;&amp; ProjectileLoopComponent-&gt;<span class="built_in">IsPlaying</span>()) &#123;</span><br><span class="line">ProjectileLoopComponent-&gt;<span class="built_in">Stop</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AProjectileRocket::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">HasAuthority</span>()) &#123;</span><br><span class="line">CollisionBox-&gt;OnComponentHit.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;ThisClass::OnHit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (TrailSystem) &#123;</span><br><span class="line">TrailSystemComponent = UNiagaraFunctionLibrary::<span class="built_in">SpawnSystemAttached</span>(</span><br><span class="line">TrailSystem,</span><br><span class="line"><span class="built_in">GetRootComponent</span>(),</span><br><span class="line"><span class="built_in">FName</span>(),</span><br><span class="line"><span class="built_in">GetActorLocation</span>(),</span><br><span class="line"><span class="built_in">GetActorRotation</span>(),</span><br><span class="line">EAttachLocation::KeepWorldPosition,</span><br><span class="line"><span class="literal">false</span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ProjectileLoop &amp;&amp; LoopingSoundAttenuation) &#123;</span><br><span class="line">ProjectileLoopComponent = UGameplayStatics::<span class="built_in">SpawnSoundAttached</span>(</span><br><span class="line">ProjectileLoop,</span><br><span class="line"><span class="built_in">GetRootComponent</span>(),</span><br><span class="line"><span class="built_in">FName</span>(),</span><br><span class="line"><span class="built_in">GetActorLocation</span>(),</span><br><span class="line">EAttachLocation::KeepWorldPosition,</span><br><span class="line"><span class="literal">false</span>,</span><br><span class="line"><span class="number">1.f</span>,</span><br><span class="line"><span class="number">1.f</span>,</span><br><span class="line"><span class="number">0.f</span>,</span><br><span class="line">LoopingSoundAttenuation,</span><br><span class="line">(USoundConcurrency*)<span class="literal">nullptr</span>,</span><br><span class="line"><span class="literal">false</span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AProjectileRocket::DestroyTimerFinished</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Destroy</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个小问题时，火箭弹的飞行速度较慢，而其生成位置是火箭发射器的枪口<code>Socket</code>，如果角色一边前进一边发射，可能会直接原地爆炸。当然最简单的方式就是将生成点向前移，但是总觉得这种妥协的做法有点不爽。</p><p>如果简单地在碰撞时判断碰撞对象是发射者就直接返回，确实不会触发爆炸，但是火箭弹会在原地停止不动。这是因为<strong>投射物运动组件的默认逻辑时发生碰撞后立即停止投射物的运动，但是事实上根本不需要这个逻辑</strong>。既然如此，那么重写投射物运动组件的碰撞逻辑就行了。</p><p>创建自己的<code>RocketMovementComponent</code>类，派生自<code>ProjectileMovementComponent</code>类。重写两个核心函数，当发生碰撞时返回<code>AdvanceNextSubstep</code>，并且讲碰撞事件置空。这样就可以完全通过火箭弹自己处理碰撞的相关逻辑了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RocketMovementComponent.cpp</span></span><br><span class="line"><span class="function">URocketMovementComponent::EHandleBlockingHitResult <span class="title">URocketMovementComponent::HandleBlockingHit</span><span class="params">(<span class="type">const</span> FHitResult&amp; Hit, <span class="type">float</span> TimeTick, <span class="type">const</span> FVector&amp; MoveDelta, <span class="type">float</span>&amp; SubTickTimeRemaining)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">HandleBlockingHit</span>(Hit, TimeTick, MoveDelta, SubTickTimeRemaining);</span><br><span class="line"><span class="keyword">return</span> EHandleBlockingHitResult::AdvanceNextSubstep;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">URocketMovementComponent::HandleImpact</span><span class="params">(<span class="type">const</span> FHitResult&amp; Hit, <span class="type">float</span> TimeSlice, <span class="type">const</span> FVector&amp; MoveDelta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-2-冲锋枪（脉冲炸弹！）"><a href="#9-2-冲锋枪（脉冲炸弹！）" class="headerlink" title="9.2 冲锋枪（脉冲炸弹！）"></a>9.2 冲锋枪（脉冲炸弹！）</h3><p>在本项目中，武器分为弹道武器和即时命中武器，而<strong>只有即时命中武器会应用随机散布</strong>（总感觉弹道武器还有随机散布的话有点bt了，通过自己的努力把哈沃克压成一个点才是享受把，要是有随机散布负反馈就太多了）。</p><p>随机散布的原理是：之前直接将准星瞄准的地方作为命中目标，而随机散布会在命中目标的方向距离玩家一定距离处生成一个球，在球内随机选择一点作为命中目标的方向。</p><p><img src="/undefined/f9d4ce84/image-20250811172319785.png" alt="image-20250811172319785"></p><p>影响随机散布的参数有两个：<strong>球体的半径</strong>和<strong>球心与角色的距离</strong>。下面就来实现这个功能吧。</p><blockquote><p>说实话，这个功能表面上挺简单，实际上手却发现有很多小问题。这些问题和功能本身无关，而是在于网络同步方面。</p><p>目前的开火逻辑是在所有客户端上都调用武器的Fire函数，其参数是命中目标。随机散布就是根据这个参数来计算的。那么问题来了，随机散布的计算要在哪里进行？最简单的方式是直接在Fire函数中进行计算，这个方法的问题是每一个客户端的计算结果都是随机的，而只有服务器负责伤害的判定。那么就会出现玩家本地看到子弹轨迹命中了敌人，但是服务器上的计算结果却是未命中。这对游戏体验的破坏是致命性的。</p><p>接下来的方法就是我学到的，玩家在客户端直接计算命中目标，然后将其作为参数传给其它客户端和服务器用于开火，这样所有客户端的随机散布的计算结果就完全一样了。看起来是个完美的解决方案。</p><p>但是正如我上面说的，随机散布由两个参数决定：球体的半径和球心与角色的距离，那么，直接让客户端自行计算随机散布结果真的安全吗？只要在本地将球体半径的数据修改为接近于0，或者将球心与角色的距离修改为无限远，随机散布不就近乎于0了吗？</p><p>对于UE引擎的反作弊，一个要点是对于所有涉及到重要数据的操作都由服务器来处理，不使用客户端的数据，这对于上面的方法已经行不通了；另一个方法是在调用RPC时使用<code>WithValidation</code>来验证数据的合理性。问题是，这里传入的参数是计算结果，而不是半径或者距离，那么即使在调用Fire的RPC时使用<code>WithValidation</code>验证这两个值，是否会存在计算前修改这两个值，计算完后调用RPC前将这两个值复原的可能性？</p><p>我自己想到的解决方法是，在玩家开火时，只将命中目标通过<code>Server RPC</code>发送到服务器，由服务器进行命中点的计算，然后通过多播RPC将特效、音效、尾迹等同步到所有客户端。</p><p>但是这个做法也给之后实现延迟补偿埋下了一个坑，在下一部分会进行解释。除此之外还有一个明面上的问题：玩家开火后不能立刻看到效果，而是要等请求发送到了服务器，服务器处理完成后再将结果发送到客户端，才能看到开火的效果。</p><p>（在这部分功能完成后，我使用<code>clumsy</code>手动提高网络延迟，在<code>CS</code>、<code>Valorant</code>和<code>Overwatch</code>中进行了测试，结果是在高延迟的情况下开火都能立刻看到效果，而命中效果则会在延迟后产生。其中<code>Valorant</code>是高度依赖于随机扩散的，并且其同样是由虚幻引擎制作的。所以可能随机扩散确实是在本地计算的，并且不需要担心作弊的问题或者有其它的解决方法。接下来我会想办法搞清楚这个问题。）</p><p>总之，下面的随机扩散计算方法可能不算成熟，但是确实是我思考以后得出的最好方法（也有可能因为知识不足导致副作用就是了）。</p></blockquote><p>首先是随机散布的计算，传入一个向量，经过计算后返回随机散布的向量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FVector <span class="title">AHitScanWeapon::TraceEndWithScatter</span><span class="params">(<span class="type">const</span> FVector&amp; HitTarget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> USkeletalMeshSocket* MuzzleFlashSocket = <span class="built_in">GetWeaponMesh</span>()-&gt;<span class="built_in">GetSocketByName</span>(<span class="string">&quot;MuzzleFlash&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!MuzzleFlashSocket) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">FVector</span>();</span><br><span class="line">&#125;</span><br><span class="line">FTransform SocketTransform = MuzzleFlashSocket-&gt;<span class="built_in">GetSocketTransform</span>(<span class="built_in">GetWeaponMesh</span>());</span><br><span class="line">FVector TraceStart = SocketTransform.<span class="built_in">GetLocation</span>();</span><br><span class="line"></span><br><span class="line">FVector ToTargetNormalized = (HitTarget - TraceStart).<span class="built_in">GetSafeNormal</span>();</span><br><span class="line">FVector SphereCenter = TraceStart + ToTargetNormalized * DistanceToSphere;</span><br><span class="line">FVector RandVec = UKismetMathLibrary::<span class="built_in">RandomUnitVector</span>() * FMath::<span class="built_in">FRandRange</span>(<span class="number">0.f</span>, SphereRadius);</span><br><span class="line">FVector EndLoc = SphereCenter + RandVec;</span><br><span class="line">FVector ToEndLoc = EndLoc - TraceStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DrawDebugSphere(GetWorld(), SphereCenter, SphereRadius, 12, FColor::Red, true);</span></span><br><span class="line"><span class="comment">//DrawDebugSphere(GetWorld(), EndLoc, 4.f, 12, FColor::Green, true);</span></span><br><span class="line"><span class="comment">//DrawDebugLine(GetWorld(), TraceStart, FVector(TraceStart + ToEndLoc * TRACE_LENGTH / ToEndLoc.Size()), FColor::Cyan, true);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">FVector</span>(TraceStart + ToEndLoc * TRACE_LENGTH / ToEndLoc.<span class="built_in">Size</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是射线检测，根据武器是否启用了随机散布来决定命中点，然后进行射线检测，检测结果通过参数中的引用进行传递。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AHitScanWeapon::WeaponTraceHit</span><span class="params">(<span class="type">const</span> FVector&amp; TraceStart, <span class="type">const</span> FVector&amp; HitTarget, FHitResult&amp; OutHit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">UWorld* World = <span class="built_in">GetWorld</span>();</span><br><span class="line"><span class="keyword">if</span> (World) &#123;</span><br><span class="line">HitEnd = bUseScatter ? <span class="built_in">TraceEndWithScatter</span>(HitTarget) : TraceStart + (HitTarget - TraceStart) * <span class="number">1.25f</span>;</span><br><span class="line">World-&gt;<span class="built_in">LineTraceSingleByChannel</span>(</span><br><span class="line">OutHit,</span><br><span class="line">TraceStart,</span><br><span class="line">HitEnd,</span><br><span class="line">ECollisionChannel::ECC_Visibility</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，开火时在服务器上进行命中结果的计算，然后通过多播<code>RPC</code>同步到所有客户端。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AHitScanWeapon::Fire</span><span class="params">(<span class="type">const</span> FVector&amp; HitTarget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">Fire</span>(HitTarget);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">HasAuthority</span>()) &#123;</span><br><span class="line">APawn* OwnerPawn = <span class="built_in">Cast</span>&lt;APawn&gt;(<span class="built_in">GetOwner</span>());</span><br><span class="line"><span class="keyword">if</span> (!OwnerPawn) <span class="keyword">return</span>;</span><br><span class="line">AController* InstigatorController = OwnerPawn-&gt;<span class="built_in">GetController</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> USkeletalMeshSocket* MuzzleFlashSocket = <span class="built_in">GetWeaponMesh</span>()-&gt;<span class="built_in">GetSocketByName</span>(<span class="string">&quot;MuzzleFlash&quot;</span>);</span><br><span class="line">FHitResult FireHit;</span><br><span class="line"><span class="keyword">if</span> (MuzzleFlashSocket) &#123;</span><br><span class="line">FTransform SocketTransform = MuzzleFlashSocket-&gt;<span class="built_in">GetSocketTransform</span>(<span class="built_in">GetWeaponMesh</span>());</span><br><span class="line">FVector Start = SocketTransform.<span class="built_in">GetLocation</span>();</span><br><span class="line"><span class="built_in">WeaponTraceHit</span>(Start, HitTarget, FireHit);</span><br><span class="line">AMultiplayerTPSCharacter* MultiplayerTPSCharacter = <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(FireHit.<span class="built_in">GetActor</span>());</span><br><span class="line"><span class="keyword">if</span> (InstigatorController &amp;&amp; MultiplayerTPSCharacter) &#123;</span><br><span class="line">UGameplayStatics::<span class="built_in">ApplyDamage</span>(</span><br><span class="line">MultiplayerTPSCharacter,</span><br><span class="line">Damage,</span><br><span class="line">InstigatorController,</span><br><span class="line"><span class="keyword">this</span>,</span><br><span class="line">UDamageType::<span class="built_in">StaticClass</span>()</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">MulticastHitScanFire</span>(FireHit);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AHitScanWeapon::MulticastHitScanFire_Implementation</span><span class="params">(<span class="type">const</span> FHitResult&amp; FireHit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">DrawDebugSphere</span>(<span class="built_in">GetWorld</span>(), FireHit.ImpactPoint, <span class="number">16.f</span>, <span class="number">12</span>, FColor::Orange, <span class="literal">true</span>);</span><br><span class="line"><span class="type">const</span> USkeletalMeshSocket* MuzzleFlashSocket = <span class="built_in">GetWeaponMesh</span>()-&gt;<span class="built_in">GetSocketByName</span>(<span class="string">&quot;MuzzleFlash&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (MuzzleFlashSocket) &#123;</span><br><span class="line">FTransform SocketTransform = MuzzleFlashSocket-&gt;<span class="built_in">GetSocketTransform</span>(<span class="built_in">GetWeaponMesh</span>());</span><br><span class="line">FVector Start = SocketTransform.<span class="built_in">GetLocation</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (FireHit.bBlockingHit) &#123;</span><br><span class="line"><span class="keyword">if</span> (ImpactParticles) &#123;</span><br><span class="line">UGameplayStatics::<span class="built_in">SpawnEmitterAtLocation</span>(</span><br><span class="line"><span class="built_in">GetWorld</span>(),</span><br><span class="line">ImpactParticles,</span><br><span class="line">FireHit.ImpactPoint,</span><br><span class="line">FireHit.ImpactNormal.<span class="built_in">Rotation</span>()</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (HitSound) &#123;</span><br><span class="line">UGameplayStatics::<span class="built_in">PlaySoundAtLocation</span>(</span><br><span class="line"><span class="keyword">this</span>,</span><br><span class="line">HitSound,</span><br><span class="line">FireHit.ImpactPoint</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (MuzzleFlash) &#123;</span><br><span class="line">UGameplayStatics::<span class="built_in">SpawnEmitterAtLocation</span>(</span><br><span class="line"><span class="built_in">GetWorld</span>(),</span><br><span class="line">MuzzleFlash,</span><br><span class="line">SocketTransform</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (FireSound) &#123;</span><br><span class="line">UGameplayStatics::<span class="built_in">PlaySoundAtLocation</span>(</span><br><span class="line"><span class="keyword">this</span>,</span><br><span class="line">FireSound,</span><br><span class="line"><span class="built_in">GetActorLocation</span>()</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (BeamParticles) &#123;</span><br><span class="line">UParticleSystemComponent* Beam = UGameplayStatics::<span class="built_in">SpawnEmitterAtLocation</span>(</span><br><span class="line"><span class="built_in">GetWorld</span>(),</span><br><span class="line">BeamParticles,</span><br><span class="line">Start,</span><br><span class="line">FRotator::ZeroRotator,</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (Beam) &#123;</span><br><span class="line">FVector BeamEnd = HitEnd;</span><br><span class="line"><span class="keyword">if</span> (FireHit.bBlockingHit) &#123;</span><br><span class="line">BeamEnd = FireHit.ImpactPoint;</span><br><span class="line">&#125;</span><br><span class="line">Beam-&gt;<span class="built_in">SetVectorParameter</span>(<span class="built_in">FName</span>(<span class="string">&quot;Target&quot;</span>), BeamEnd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-霰弹枪（Spa-Spa-）"><a href="#9-3-霰弹枪（Spa-Spa-）" class="headerlink" title="9.3 霰弹枪（Spa! Spa!）"></a>9.3 霰弹枪（Spa! Spa!）</h3><p>对于霰弹枪，唯一的区别就是每次射击时需要执行多次射线检测，因此将所有的检测结果存放在一个<code>Tarray</code>中。于此同时，霰弹枪可能会命中多个目标，因此需要用<code>TMap</code>存储所有命中的角色以及对应的命中数，最后遍历<code>TMap</code>来对所有命中角色造成对应的伤害。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AShotgun::Fire</span><span class="params">(<span class="type">const</span> FVector&amp; HitTarget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">AWeapon::<span class="built_in">Fire</span>(HitTarget);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">HasAuthority</span>()) &#123;</span><br><span class="line">APawn* OwnerPawn = <span class="built_in">Cast</span>&lt;APawn&gt;(<span class="built_in">GetOwner</span>());</span><br><span class="line"><span class="keyword">if</span> (!OwnerPawn) <span class="keyword">return</span>;</span><br><span class="line">AController* InstigatorController = OwnerPawn-&gt;<span class="built_in">GetController</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> USkeletalMeshSocket* MuzzleFlashSocket = <span class="built_in">GetWeaponMesh</span>()-&gt;<span class="built_in">GetSocketByName</span>(<span class="string">&quot;MuzzleFlash&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (MuzzleFlashSocket) &#123;</span><br><span class="line">FTransform SocketTransform = MuzzleFlashSocket-&gt;<span class="built_in">GetSocketTransform</span>(<span class="built_in">GetWeaponMesh</span>());</span><br><span class="line">FVector Start = SocketTransform.<span class="built_in">GetLocation</span>();</span><br><span class="line"></span><br><span class="line">TMap&lt;AMultiplayerTPSCharacter*, uint32&gt; HitMap;</span><br><span class="line"><span class="keyword">for</span> (uint32 i = <span class="number">0</span>; i &lt; NumberOfPellets; ++i) &#123;</span><br><span class="line">FHitResult FireHit;</span><br><span class="line"><span class="built_in">WeaponTraceHit</span>(Start, HitTarget, FireHit);</span><br><span class="line">HitResults.<span class="built_in">Add</span>(FireHit);</span><br><span class="line">HitEnds.<span class="built_in">Add</span>(HitEnd);</span><br><span class="line"></span><br><span class="line">AMultiplayerTPSCharacter* MultiplayerTPSCharacter = <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(FireHit.<span class="built_in">GetActor</span>());</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">HasAuthority</span>() &amp;&amp; MultiplayerTPSCharacter &amp;&amp; InstigatorController) &#123;</span><br><span class="line"><span class="keyword">if</span> (HitMap.<span class="built_in">Contains</span>(MultiplayerTPSCharacter)) &#123;</span><br><span class="line">++HitMap[MultiplayerTPSCharacter];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">HitMap.<span class="built_in">Emplace</span>(MultiplayerTPSCharacter, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; HitPair : HitMap) &#123;</span><br><span class="line"><span class="keyword">if</span> (HitPair.Key &amp;&amp; <span class="built_in">HasAuthority</span>() &amp;&amp; InstigatorController) &#123;</span><br><span class="line">UGameplayStatics::<span class="built_in">ApplyDamage</span>(</span><br><span class="line">HitPair.Key,</span><br><span class="line">Damage * HitPair.Value,</span><br><span class="line">InstigatorController,</span><br><span class="line"><span class="keyword">this</span>,</span><br><span class="line">UDamageType::<span class="built_in">StaticClass</span>()</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">MulticastShotgunFire</span>(HitResults, HitEnds);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AShotgun::MulticastShotgunFire_Implementation</span><span class="params">(<span class="type">const</span> TArray&lt;FHitResult&gt;&amp; Hits, <span class="type">const</span> TArray&lt;FVector&gt;&amp; Ends)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> USkeletalMeshSocket* MuzzleFlashSocket = <span class="built_in">GetWeaponMesh</span>()-&gt;<span class="built_in">GetSocketByName</span>(<span class="string">&quot;MuzzleFlash&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (MuzzleFlashSocket) &#123;</span><br><span class="line">FTransform SocketTransform = MuzzleFlashSocket-&gt;<span class="built_in">GetSocketTransform</span>(<span class="built_in">GetWeaponMesh</span>());</span><br><span class="line">FVector Start = SocketTransform.<span class="built_in">GetLocation</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (uint32 i = <span class="number">0</span>; i &lt; NumberOfPellets; ++i) &#123;</span><br><span class="line"><span class="built_in">DrawDebugSphere</span>(<span class="built_in">GetWorld</span>(), Hits[i].ImpactPoint, <span class="number">16.f</span>, <span class="number">12</span>, FColor::Orange, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">if</span> (Hits[i].bBlockingHit &amp;&amp; ImpactParticles &amp;&amp; HitSound) &#123;</span><br><span class="line">UGameplayStatics::<span class="built_in">SpawnEmitterAtLocation</span>(</span><br><span class="line"><span class="built_in">GetWorld</span>(),</span><br><span class="line">ImpactParticles,</span><br><span class="line">Hits[i].ImpactPoint,</span><br><span class="line">Hits[i].ImpactNormal.<span class="built_in">Rotation</span>()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">UGameplayStatics::<span class="built_in">PlaySoundAtLocation</span>(</span><br><span class="line"><span class="keyword">this</span>,</span><br><span class="line">HitSound,</span><br><span class="line">Hits[i].ImpactPoint,</span><br><span class="line"><span class="number">.5f</span>,</span><br><span class="line">FMath::<span class="built_in">FRandRange</span>(<span class="number">-.5f</span>, <span class="number">.5f</span>)</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (BeamParticles) &#123;</span><br><span class="line">UParticleSystemComponent* Beam = UGameplayStatics::<span class="built_in">SpawnEmitterAtLocation</span>(</span><br><span class="line"><span class="built_in">GetWorld</span>(),</span><br><span class="line">BeamParticles,</span><br><span class="line">Start,</span><br><span class="line">FRotator::ZeroRotator,</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (Beam) &#123;</span><br><span class="line">FVector BeamEnd = Ends[i];</span><br><span class="line"><span class="keyword">if</span> (Hits[i].bBlockingHit) &#123;</span><br><span class="line">BeamEnd = Hits[i].ImpactPoint;</span><br><span class="line">&#125;</span><br><span class="line">Beam-&gt;<span class="built_in">SetVectorParameter</span>(<span class="built_in">FName</span>(<span class="string">&quot;Target&quot;</span>), BeamEnd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">HitEnds.<span class="built_in">Empty</span>();</span><br><span class="line">HitResults.<span class="built_in">Empty</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>霰弹枪有自己独特的换弹机制，那就是子弹都是一发一发上的，同时可以打断换弹的过程直接进行射击。</p><p>为霰弹枪的换弹单独写了一个函数，在动画蒙太奇中，每一次上弹都会有一个动画通知，会调用这个函数函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::UpdateShotgunAmmoValues</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!EquippedWeapon || !Character) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (CarriedAmmoMap.<span class="built_in">Contains</span>(EquippedWeapon-&gt;<span class="built_in">GetWeaponType</span>())) &#123;</span><br><span class="line">CarriedAmmoMap[EquippedWeapon-&gt;<span class="built_in">GetWeaponType</span>()] -= <span class="number">1</span>;</span><br><span class="line">CarriedAmmo = CarriedAmmoMap[EquippedWeapon-&gt;<span class="built_in">GetWeaponType</span>()];</span><br><span class="line">&#125;</span><br><span class="line">Controller = Controller ? Controller : <span class="built_in">Cast</span>&lt;AMPTPSPlayerController&gt;(Character-&gt;Controller);</span><br><span class="line"><span class="keyword">if</span> (Controller) &#123;</span><br><span class="line">Controller-&gt;<span class="built_in">SetHUDCarriedAmmo</span>(CarriedAmmo);</span><br><span class="line">&#125;</span><br><span class="line">EquippedWeapon-&gt;<span class="built_in">AddAmmo</span>(<span class="number">1</span>);</span><br><span class="line">bCanFire = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (EquippedWeapon-&gt;<span class="built_in">IsFull</span>() || CarriedAmmo == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">JumpToShotgunEnd</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::ShotgunShellReload</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Character &amp;&amp; Character-&gt;<span class="built_in">HasAuthority</span>()) &#123;</span><br><span class="line"><span class="built_in">UpdateShotgunAmmoValues</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当子弹满了或者没有备弹了，就会跳到结束片段。跳转片段的过程要进行同步，分别在携带弹药复制和武器的弹药复制中进行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::JumpToShotgunEnd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">UAnimInstance* AnimInstance = Character-&gt;<span class="built_in">GetMesh</span>()-&gt;<span class="built_in">GetAnimInstance</span>();</span><br><span class="line"><span class="keyword">if</span> (AnimInstance &amp;&amp; Character-&gt;<span class="built_in">GetReloadMontage</span>()) &#123;</span><br><span class="line">AnimInstance-&gt;<span class="built_in">Montage_JumpToSection</span>(<span class="built_in">FName</span>(<span class="string">&quot;ShotgunEnd&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UCombatComponent::CanFire</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!EquippedWeapon) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> !EquippedWeapon-&gt;<span class="built_in">IsEmpty</span>() &amp;&amp; bCanFire &amp;&amp; (CombatState == ECombatState::ECS_Unoccupied || CombatState == ECombatState::ECS_Reloading &amp;&amp; EquippedWeapon-&gt;<span class="built_in">GetWeaponType</span>() == EWeaponType::EWT_Shotgun);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::OnRep_CarriedAmmo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Controller = Controller ? Controller : <span class="built_in">Cast</span>&lt;AMPTPSPlayerController&gt;(Character-&gt;Controller);</span><br><span class="line"><span class="keyword">if</span> (Controller) &#123;</span><br><span class="line">Controller-&gt;<span class="built_in">SetHUDCarriedAmmo</span>(CarriedAmmo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> bJumpToShotgunEnd = CombatState == ECombatState::ECS_Reloading &amp;&amp; EquippedWeapon &amp;&amp; EquippedWeapon-&gt;<span class="built_in">GetWeaponType</span>() == EWeaponType::EWT_Shotgun &amp;&amp; CarriedAmmo == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (bJumpToShotgunEnd) &#123;</span><br><span class="line"><span class="built_in">JumpToShotgunEnd</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AWeapon::OnRep_Ammo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MultiplayerTPSOwnerCharacter = MultiplayerTPSOwnerCharacter ? MultiplayerTPSOwnerCharacter : <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(<span class="built_in">GetOwner</span>());</span><br><span class="line"><span class="keyword">if</span> (MultiplayerTPSOwnerCharacter&amp;&amp;MultiplayerTPSOwnerCharacter-&gt;<span class="built_in">GetCombat</span>()) &#123;</span><br><span class="line">MultiplayerTPSOwnerCharacter-&gt;<span class="built_in">GetCombat</span>()-&gt;<span class="built_in">JumpToShotgunEnd</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">SetHUDAmmo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开火时记得将战斗状态设为Unoccupied。</p><h3 id="9-4-狙击枪（没人可以躲过我的眼睛-）"><a href="#9-4-狙击枪（没人可以躲过我的眼睛-）" class="headerlink" title="9.4 狙击枪（没人可以躲过我的眼睛~）"></a>9.4 狙击枪（没人可以躲过我的眼睛~）</h3><p>狙击枪的特点就是瞄准时会出现瞄准镜。通过一个<code>UserWidget</code>就可以轻松搞定。当开镜时播放<code>UserWidget</code>的动画来显示瞄准键，关镜时将动画倒放即可，具体逻辑在蓝图中实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowSniperScopeWidget</span><span class="params">(<span class="type">bool</span> bShowScope)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::SetAiming</span><span class="params">(<span class="type">bool</span> bIsAiming)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!Character || !EquippedWeapon) <span class="keyword">return</span>;</span><br><span class="line">bAiming = bIsAiming;</span><br><span class="line"><span class="built_in">ServerSetAiming</span>(bIsAiming);</span><br><span class="line"><span class="keyword">if</span> (Character) &#123;</span><br><span class="line">Character-&gt;<span class="built_in">GetCharacterMovement</span>()-&gt;MaxWalkSpeed = bIsAiming ? AimWalkSpeed : BaseWalkSpeed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Character-&gt;<span class="built_in">IsLocallyControlled</span>() &amp;&amp; EquippedWeapon-&gt;<span class="built_in">GetWeaponType</span>() == EWeaponType::EWT_SniperRifle) &#123;</span><br><span class="line">Character-&gt;<span class="built_in">ShowSniperScopeWidget</span>(bIsAiming);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当角色被淘汰时，如果正在用狙击枪瞄准，要为其关闭瞄准键： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">IsLocallyControlled</span>() &amp;&amp; Combat &amp;&amp; Combat-&gt;EquippedWeapon&amp;&amp; Combat-&gt;bAiming &amp;&amp; Combat-&gt;EquippedWeapon-&gt;<span class="built_in">GetWeaponType</span>() == EWeaponType::EWT_SniperRifle) &#123;</span><br><span class="line"><span class="built_in">ShowSniperScopeWidget</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还遇到了一个无语的Bug，在客户端，每次上弹动作都会上两次弹。找了一下午原因，在各种地方打Log，问AI，硬是每想起来直接搜一下，最后一搜就搜到了。这是UE自己的BUG，如果使用了上半身体与下半身体分开运行动画，客户端远程调用在服务器播放动画蒙太奇就会出现通知被触发两次的情况，解决方法是使用do once节点，当换弹后延迟一点时间将do once重置。</p><h3 id="9-5-榴弹发射器（炸弹轮胎滚起来了！）"><a href="#9-5-榴弹发射器（炸弹轮胎滚起来了！）" class="headerlink" title="9.5 榴弹发射器（炸弹轮胎滚起来了！）"></a>9.5 榴弹发射器（炸弹轮胎滚起来了！）</h3><p>榴弹的特点和火箭弹类似，就是爆炸。区别是榴弹启用了重力，同时会进行弹跳。</p><p>其实实现很简单，只要在投射物运动组件中将<code>bShouldBounce</code>设为true就行了（投射物运动组件万岁！），同时绑定弹跳事件的回调函数，播放弹跳的音效。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">AProjectileGrenade::<span class="built_in">AProjectileGrenade</span>()</span><br><span class="line">&#123;</span><br><span class="line">ProjectileMesh = <span class="built_in">CreateDefaultSubobject</span>&lt;UStaticMeshComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;Grenade Mesh&quot;</span>));</span><br><span class="line">ProjectileMesh-&gt;<span class="built_in">SetupAttachment</span>(RootComponent);</span><br><span class="line">ProjectileMesh-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);</span><br><span class="line"></span><br><span class="line">ProjectileMovementComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;UProjectileMovementComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;ProjectileMovementComponent&quot;</span>));</span><br><span class="line">ProjectileMovementComponent-&gt;bRotationFollowsVelocity = <span class="literal">true</span>;</span><br><span class="line">ProjectileMovementComponent-&gt;<span class="built_in">SetIsReplicated</span>(<span class="literal">true</span>);</span><br><span class="line">ProjectileMovementComponent-&gt;bShouldBounce = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AProjectileGrenade::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">AActor::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">StartDestroyTimer</span>();</span><br><span class="line"><span class="built_in">SpawnTrailSystem</span>();</span><br><span class="line"></span><br><span class="line">ProjectileMovementComponent-&gt;OnProjectileBounce.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;AProjectileGrenade::OnBounce);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AProjectileGrenade::OnBounce</span><span class="params">(<span class="type">const</span> FHitResult&amp; ImpactResult, <span class="type">const</span> FVector&amp; ImpactVelocity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (BounceSound) &#123;</span><br><span class="line">UGameplayStatics::<span class="built_in">PlaySoundAtLocation</span>(</span><br><span class="line"><span class="keyword">this</span>,</span><br><span class="line">BounceSound,</span><br><span class="line"><span class="built_in">GetActorLocation</span>()</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AProjectileGrenade::Destroyed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">ExplodeDamage</span>();</span><br><span class="line"></span><br><span class="line">Super::<span class="built_in">Destroyed</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-总结"><a href="#10-总结" class="headerlink" title="10.总结"></a>10.总结</h2><p>说实话，做这个项目比我想的要有趣，尤其是在遇到具体问题和需求，思考解决方案的时候，有时候想着想着就把整个逻辑理通顺了。一直想不出来的时候是真红温，终于想出来了的时候也是真爽。</p><p>下一部分，延迟补偿篇，敬请期待。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【UE5】多人联机TPS游戏开发（二） —— 基础框架</title>
      <link href="/undefined/e6c9f323.html"/>
      <url>/undefined/e6c9f323.html</url>
      
        <content type="html"><![CDATA[<h1 id="【UE5】多人联机TPS游戏开发（二）-——-基础框架"><a href="#【UE5】多人联机TPS游戏开发（二）-——-基础框架" class="headerlink" title="【UE5】多人联机TPS游戏开发（二） —— 基础框架"></a>【UE5】多人联机TPS游戏开发（二） —— 基础框架</h1><blockquote><p>终于要正式开始游戏的制作了。在这一部分中，将进行射击游戏的基本框架的搭建。</p><p>这部分内容的目标是完成射击游戏的<strong>基础网络框架</strong>搭建。虽然这些步骤看起来有些“公式化”，但它们实际上奠定了整个多人游戏的网络底层环境。</p><p>这部分有两个首次接触的多人游戏中的重点：<strong>复制</strong>和<strong>RPC</strong>。这两项是多人游戏最核心的同步机制。我们需要在各种需要同步的地方使用这两个功能，在实现同步功能的同时尽可能地节省网络带宽资源。</p><p>除了上面这两个知识点在遇到的时候会有比较详细的解释，其它部分基本上就一笔带过了，毕竟这个项目还有很多别的要讲呢。</p></blockquote><h2 id="1-安装联机插件"><a href="#1-安装联机插件" class="headerlink" title="1.安装联机插件"></a>1.安装联机插件</h2><p>上一部分中，我花了大量的精力制作了一个用于多人联机的UE5插件，是时候让它发挥作用了。</p><p>创建一个新的空项目，将打包好的插件文件复制到正确的位置：</p><p><img src="/undefined/e6c9f323/image-20250713200110018.png" alt="image-20250713200110018"></p><p>进行一些常规配置：</p><p><strong><code>NetDriverDefinitions</code></strong>：指定 UE 在多人模式下使用 <code>SteamNetDriver</code> 作为底层网络驱动。它利用Steam的中继服务器(Steam Relay)实现P2P连接，解决NAT穿透问题；<code>DriverClassNameFallback</code> 则是在无法使用 Steam 时回退到本地 IP 驱动。</p><p><strong><code>DefaultPlatformService=Steam</code></strong>：选择 Steam 作为当前网络平台子系统。如果不设置，将默认使用 NULL 子系统（仅支持本地多人）。</p><p><strong><code>SteamDevAppId=480</code></strong>：<code>Steam</code>官方提供的测试<code>AppID</code>，任何开发者都可以用它进行多人联机调试。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//Config/DefaultEngine.ini</span><br><span class="line"></span><br><span class="line"><span class="section">[/Script/Engine.GameEngine]</span></span><br><span class="line">+<span class="attr">NetDriverDefinitions</span>=(DefName=<span class="string">&quot;GameNetDriver&quot;</span>,DriverClassName=<span class="string">&quot;OnlineSubsystemSteam.SteamNetDriver&quot;</span>,DriverClassNameFallback=<span class="string">&quot;OnlineSubsystemUtils.IpNetDriver&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="section">[OnlineSubsystem]</span></span><br><span class="line"><span class="attr">DefaultPlatformService</span>=Steam</span><br><span class="line"> </span><br><span class="line"><span class="section">[OnlineSubsystemSteam]</span></span><br><span class="line"><span class="attr">bEnabled</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">SteamDevAppId</span>=<span class="number">480</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">; If using Sessions</span></span><br><span class="line"><span class="comment">; bInitServerOnClient=true</span></span><br><span class="line"> </span><br><span class="line"><span class="section">[/Script/OnlineSubsystemSteam.SteamNetDriver]</span></span><br><span class="line"><span class="attr">NetConnectionClassName</span>=<span class="string">&quot;OnlineSubsystemSteam.SteamNetConnection&quot;</span></span><br></pre></td></tr></table></figure><p>在 <code>.Build.cs</code> 添加模块依赖（<code>OnlineSubsystem</code>, <code>OnlineSubsystemSteam</code>）。</p><p>创建大厅地图，将项目打包后发送到另一台电脑，就可以轻松实现联机了。因为大厅地图只是一个空地图，使用的是默认游戏模式，玩家控制的是UE默认的Pawn：一个球。</p><p><img src="/undefined/e6c9f323/image-20250707151801594.png" alt="image-20250707151801594"></p><h2 id="2-项目基础搭建"><a href="#2-项目基础搭建" class="headerlink" title="2.项目基础搭建"></a>2.项目基础搭建</h2><p>在完成网络环境验证后，就可以开始搭建射击游戏的最基础框架了，包括角色、动画和游戏模式等。</p><h3 id="2-1-角色"><a href="#2-1-角色" class="headerlink" title="2.1 角色"></a>2.1 角色</h3><p>这套流程已经进行过不知道多少次了，这里直接一笔带过。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CameraBoom = <span class="built_in">CreateDefaultSubobject</span>&lt;USpringArmComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;CameraBoom&quot;</span>));</span><br><span class="line">CameraBoom-&gt;<span class="built_in">SetupAttachment</span>(<span class="built_in">GetMesh</span>());</span><br><span class="line">CameraBoom-&gt;TargetArmLength = <span class="number">600.f</span>;</span><br><span class="line">CameraBoom-&gt;bUsePawnControlRotation = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">FollowCamera = <span class="built_in">CreateDefaultSubobject</span>&lt;UCameraComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;FollowCamera&quot;</span>));</span><br><span class="line">FollowCamera-&gt;<span class="built_in">SetupAttachment</span>(CameraBoom, USpringArmComponent::SocketName);</span><br><span class="line">FollowCamera-&gt;bUsePawnControlRotation = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">bUseControllerRotationYaw = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">GetCharacterMovement</span>()-&gt;bOrientRotationToMovement = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>网格体和增强输入子系统的配置都在蓝图中完成。</p><h3 id="2-2-大厅游戏模式"><a href="#2-2-大厅游戏模式" class="headerlink" title="2.2 大厅游戏模式"></a>2.2 大厅游戏模式</h3><p>游戏模式是以关卡为单位，规定关卡中的一些规则的一个类。而大厅作为一个关卡，也可以通过游戏模式去进行一些管理。</p><p>这里创建一个简单的游戏模式<code>LobbyGameNide</code>，重写了<code>PostLogin</code>函数，规定当大厅人数达到要求后就使用<code>ServerTravel</code>函数将所有玩家传送到游戏地图。<code>PostLogin</code>在服务器端调用，表示有新的客户端成功连接到该关卡。这里在测试时规定的是写死的2个玩家，之后会实现通过菜单进行配置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ALobbyGameMode::PostLogin</span><span class="params">(APlayerController* NewPlayer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">PostLogin</span>(NewPlayer);</span><br><span class="line"></span><br><span class="line">int32 NumberOfPlayer = GameState.<span class="built_in">Get</span>()-&gt;PlayerArray.<span class="built_in">Num</span>();</span><br><span class="line"><span class="keyword">if</span> (NumberOfPlayer == <span class="number">2</span>) &#123;</span><br><span class="line">UWorld* World = <span class="built_in">GetWorld</span>();</span><br><span class="line"><span class="keyword">if</span> (World) &#123;</span><br><span class="line">bUseSeamlessTravel = <span class="literal">true</span>;</span><br><span class="line">World-&gt;<span class="built_in">ServerTravel</span>(<span class="built_in">FString</span>(<span class="string">&quot;/Games/_MultiplayerTPS/Maps/MultiplayerTPSMap?listen&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中有一句：<code>bUseSeamlessTravel = true</code>，意思是启用<strong>无缝传送</strong>，使玩家在切换地图时保持角色状态和连接，不需要重新登录。启用后，UE 会在切图前先加载一个“中转地图”，避免切换过程中客户端掉线。而如果想启用无缝传送，我们需要创建一个空地图，并在项目设置中将其设为<strong>转移地图</strong>。</p><p><img src="/undefined/e6c9f323/image-20250713202944487.png" alt="image-20250713202944487"></p><h3 id="补充知识：Net-Role"><a href="#补充知识：Net-Role" class="headerlink" title="补充知识：Net Role"></a>补充知识：Net Role</h3><p><strong>Net Role 就是角色（Actor）在网络中“扮演的身份”</strong>。每个 Actor（Pawn、角色、物体等）在多人游戏中都会有两个“网络身份”：本机上的角色和远处机器上的角色。</p><p>Net Role有以下取值：</p><ul><li><strong><code>ROLE_Authority</code>（权威）：代表服务器端拥有控制权</strong>，只有服务器上的 Actor 才会是 Authority，只有 Authority 才能调用 <code>Server</code> 函数，进行<strong>状态更改、复制、指令广播等。</strong></li><li><p><strong><code>ROLE_AutonomousProxy</code>（自主代理）：代表“我在客户端上拥有控制权”</strong>，常用于玩家自己控制的角色，本地玩家操控自己的角色时，该角色在客户端是 <code>AutonomousProxy</code>。</p></li><li><p><strong><code>ROLE_SimulatedProxy</code>（模拟代理）：代表“这是别人控制的角色，我本地只做视觉模拟”</strong>，这类对象不能执行本地输入，只能接受服务器同步的数据（比如位置、动画状态）。</p></li></ul><p>通过区分不同的Net Role可以辅助实现一些联机中的功能，如同步变量、RPC等。</p><h2 id="3-射击游戏基础"><a href="#3-射击游戏基础" class="headerlink" title="3 射击游戏基础"></a>3 射击游戏基础</h2><p>在网络环境和大厅逻辑就绪后，就可以开始构建射击游戏的基础组件了。</p><h3 id="3-1-武器类"><a href="#3-1-武器类" class="headerlink" title="3.1 武器类"></a>3.1 武器类</h3><p>武器类继承自<code>AActor</code>类，具有以下要素：</p><p><strong>枚举<code>EWeaponState</code></strong>表示武器当前的装备状态，如初始、丢弃、装备中等。</p><p><strong>武器网格体</strong>：武器的外观。</p><p><strong>球体碰撞体积</strong>：检测玩家是否接近武器，用于触发拾取逻辑。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Weapon.h</span></span><br><span class="line"><span class="built_in">UENUM</span>(BlueprintType)</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">EWeaponState</span> :uint8</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">EWS_Initial <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Initial State&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">EWS_Equipped <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Equipped&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">EWS_Dropped <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Dropped&quot;</span>)</span>,</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">EWS_MAX <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;DefaultMAX&quot;</span>)</span></span></span><br><span class="line"><span class="function">&#125;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MULTIPLAYERTPS_API</span> AWeapon : <span class="keyword">public</span> AActor</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">AWeapon</span>();</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere, Category = <span class="string">&quot;Weapon Properties&quot;</span>)</span><br><span class="line">USkeletalMeshComponent* WeaponMesh;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere, Category = <span class="string">&quot;Weapon Properties&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">USphereComponent</span>* AreaSphere;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere)</span><br><span class="line">EWeaponState WeaponState;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在构造函数中：对网格体设置默认的碰撞响应，阻挡除 <code>Pawn</code> 外的所有通道；初始状态关闭球体的碰撞，避免无关检测；将 <code>bReplicates = true</code>，使武器可以在服务器和客户端之间同步状态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Weapon.cpp</span></span><br><span class="line">AWeapon::<span class="built_in">AWeapon</span>()</span><br><span class="line">&#123;</span><br><span class="line">PrimaryActorTick.bCanEverTick = <span class="literal">false</span>;</span><br><span class="line">bReplicates = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">WeaponMesh = <span class="built_in">CreateDefaultSubobject</span>&lt;USkeletalMeshComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;WeaponMesh&quot;</span>));</span><br><span class="line"><span class="built_in">SetRootComponent</span>(WeaponMesh);</span><br><span class="line"></span><br><span class="line">WeaponMesh-&gt;<span class="built_in">SetCollisionResponseToAllChannels</span>(ECollisionResponse::ECR_Block);</span><br><span class="line">WeaponMesh-&gt;<span class="built_in">SetCollisionResponseToChannel</span>(ECollisionChannel::ECC_Pawn, ECollisionResponse::ECR_Ignore);</span><br><span class="line">WeaponMesh-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);</span><br><span class="line"></span><br><span class="line">AreaSphere = <span class="built_in">CreateDefaultSubobject</span>&lt;USphereComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;AreaSphere&quot;</span>));</span><br><span class="line">AreaSphere-&gt;<span class="built_in">SetupAttachment</span>(RootComponent);</span><br><span class="line">AreaSphere-&gt;<span class="built_in">SetCollisionResponseToAllChannels</span>(ECollisionResponse::ECR_Ignore);</span><br><span class="line">AreaSphere-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AWeapon::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">HasAuthority</span>()) &#123;</span><br><span class="line">AreaSphere-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::QueryAndPhysics);</span><br><span class="line">AreaSphere-&gt;<span class="built_in">SetCollisionResponseToChannel</span>(ECollisionChannel::ECC_Pawn, ECollisionResponse::ECR_Overlap);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-拾取UI组件（复制）"><a href="#3-2-拾取UI组件（复制）" class="headerlink" title="3.2 拾取UI组件（复制）"></a>3.2 拾取UI组件（复制）</h3><p>当玩家和武器的球体碰撞体积重叠后，需要有一个UI提示玩家拾取武器。这个拾取UI组件本质上是一个文字块，是<code>Weapon</code>类的一个变量。它被标记为<code>UPROPERTY</code>，在编辑器中设定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PickupWidget = <span class="built_in">CreateDefaultSubobject</span>&lt;UWidgetComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;PickupWidget&quot;</span>));</span><br><span class="line">PickupWidget-&gt;<span class="built_in">SetupAttachment</span>(RootComponent);</span><br></pre></td></tr></table></figure><p>在武器类中写了一个球体重叠的函数，当球体碰撞体积检测到玩家时会被调用，将拾取UI组件设为可见：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AWeapon::OnSphereOverlap</span><span class="params">(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, <span class="type">bool</span> bFromSweep, <span class="type">const</span> FHitResult&amp; SweepResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">AMultiplayerTPSCharacter* MultiplayerTPSCharacter = <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(OtherActor);</span><br><span class="line"><span class="keyword">if</span> (MultiplayerTPSCharacter &amp;&amp; PickupWidget) &#123;</span><br><span class="line">PickupWidget-&gt;<span class="built_in">SetVisibility</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>BeginPlay</code> 中，如果当前运行在服务器（<code>HasAuthority()</code> 为真），则开启球体的碰撞检测并绑定重叠回调：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AWeapon::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">HasAuthority</span>()) &#123;</span><br><span class="line">AreaSphere-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::QueryAndPhysics);</span><br><span class="line">AreaSphere-&gt;<span class="built_in">SetCollisionResponseToChannel</span>(ECollisionChannel::ECC_Pawn, ECollisionResponse::ECR_Overlap);</span><br><span class="line">AreaSphere-&gt;OnComponentBeginOverlap.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;ThisClass::OnSphereOverlap);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (PickupWidget) &#123;</span><br><span class="line">PickupWidget-&gt;<span class="built_in">SetVisibility</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，就能<strong>在服务器中看到拾取UI组件了</strong>。在客户端看不到的原因是，<strong>只有在服务器上才会开启武器的球体碰撞体积，也只有在服务器上会进行球体碰撞体积开始重叠的回调函数绑定</strong>。<strong>这是多人游戏中为了防止作弊的常规做法</strong>。那么要怎么在客户端上看到拾取UI组件呢？答案是<strong>复制(Replication)</strong>。</p><p><a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/replicate-actor-properties-in-unreal-engine?application_version=5.5">在虚幻引擎中复制Actor属性 | 虚幻引擎 5.5 文档 | Epic Developer Community</a></p><p><strong>复制</strong>是指权威服务器将状态数据发送到连接的客户端的过程。简单来说，对于标注了复制的变量，当它被改变时（通常在权威服务器上），这个改变会被同步到所有客户端上。<strong>复制只对Actor及其相关属性生效</strong>。</p><p>如果想要复制Actor的变量，这个Actor自身必须是可复制的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bReplicates = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>角色类本身就是可复制的，所以不用显式开启。</p><p>对于要复制的变量，必须要用<code>UPROPERTY</code>宏将其标记。如果只是需要将这个变量标记为复制，可以用<code>Replicated</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(Replicated)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AWeapon</span>* OverlappingWeapon;</span><br></pre></td></tr></table></figure><p>这个变量用来表示当前重叠的武器。还需要一个<code>Set</code>函数来设置这个变量。<code>SetOverlappingWeapon</code> 用于在网络同步时更新角色的重叠武器状态，并控制拾取 UI 的可见性。只有在本地控制的角色上才会显示拾取 UI。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::SetOverlappingWeapon</span><span class="params">(AWeapon* Weapon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//如果当前重叠的武器有值，需要将其拾取组件隐藏</span></span><br><span class="line">    <span class="keyword">if</span> (OverlappingWeapon) &#123;</span><br><span class="line">OverlappingWeapon-&gt;<span class="built_in">ShowPickWidget</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//显示新的重叠的武器的拾取组件（只有是本地控制的角色时才显示）</span></span><br><span class="line">OverlappingWeapon = Weapon;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IsLocallyControlled</span>()) &#123;</span><br><span class="line"><span class="keyword">if</span> (OverlappingWeapon) &#123;</span><br><span class="line">OverlappingWeapon-&gt;<span class="built_in">ShowPickWidget</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AWeapon::ShowPickWidget</span><span class="params">(<span class="type">bool</span> bShowWidget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (PickupWidget) &#123;</span><br><span class="line">PickupWidget-&gt;<span class="built_in">SetVisibility</span>(bShowWidget);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改之前武器球体开始重叠的回调函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AWeapon::OnSphereOverlap</span><span class="params">(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, <span class="type">bool</span> bFromSweep, <span class="type">const</span> FHitResult&amp; SweepResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">AMultiplayerTPSCharacter* MultiplayerTPSCharacter = <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(OtherActor);</span><br><span class="line"><span class="keyword">if</span> (MultiplayerTPSCharacter) &#123;</span><br><span class="line">MultiplayerTPSCharacter-&gt;<span class="built_in">SetOverlappingWeapon</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果有需要复制的变量，我们就需要下面的这个函数去注册这个变量</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSCharacter.h</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">GetLifetimeReplicatedProps</span><span class="params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MultiplayerTPSCharacter.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::GetLifetimeReplicatedProps</span><span class="params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">GetLifetimeReplicatedProps</span>(OutLifetimeProps);</span><br><span class="line"></span><br><span class="line"><span class="built_in">DOREPLIFETIME</span>(AMultiplayerTPSCharacter, OverlappingWeapon);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果想要有条件地复制<code>Actor</code>属性，如仅复制到Actor的所有者，在进行注册时需要用<code>DOREPLIFETIME_CONDITION</code>宏而不是<code>DOREPLIFETIME</code>宏，同时用<code>COND_Custom</code>控制复制的条件</strong>。具体用法在官方文档中有详细讲解。</p><p>这样一来，当这个变量在服务器上被改变后，它就会自动复制到客户端。在这里，当服务器上角色和地上的武器重叠后，<code>OverlappingWeapon</code>被设为重叠的武器，发生了改变，这时这个变量就会同步到所有客户端。</p><p>现在当服务器上角色和武器重叠时，所有客户端的对应角色的<code>OverlappingWeapon</code>变量都会被设为正确的值，但是要怎样让这个变量显示拾取组件呢？</p><p><strong>如果想要当复制发生时调用某个函数，可以用下面这个<code>UPROPERTY</code>标记：<code>ReplicatedUsing = FunctionName</code></strong>。<strong>（回调函数必须要有UFUNCTION()宏）</strong></p><p>回调函数通常需要加上<code>OnRep_</code>的前缀：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::OnRep_OverlappingWeapon</span><span class="params">(AWeapon* LastWeapon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (OverlappingWeapon) &#123;</span><br><span class="line">OverlappingWeapon-&gt;<span class="built_in">ShowPickWidget</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (LastWeapon) &#123;</span><br><span class="line">LastWeapon-&gt;<span class="built_in">ShowPickWidget</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>回调函数通常是无参的</strong>，但是<strong>也可以带一个要复制的变量类的指针的参数，其值为变量在复制前的值</strong>。可以通过这个参数对复制之前的值进行一些操作。</p><p>这样一来，当<code>OverlappingWeapon</code>被复制的时候，所有通过的复制同步了这个变量的客户端都会执行<code>OnRep_OverlappingWeapon</code>函数，设置武器拾取控制的可见性。当然，只有拾取武器的那个角色能看到效果。</p><p>在结束重叠的回调函数中将重叠的武器设为空。同样，这会触发复制，并且将之前重叠的武器的拾取UI组件隐藏。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AWeapon::OnSphereEndOverlap</span><span class="params">(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">AMultiplayerTPSCharacter* MultiplayerTPSCharacter = <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(OtherActor);</span><br><span class="line"><span class="keyword">if</span> (MultiplayerTPSCharacter) &#123;</span><br><span class="line">MultiplayerTPSCharacter-&gt;<span class="built_in">SetOverlappingWeapon</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-装备武器（RPC）"><a href="#3-3-装备武器（RPC）" class="headerlink" title="3.3 装备武器（RPC）"></a>3.3 装备武器（RPC）</h3><p>为了实现模块化，可以把所有处理和战斗相关的逻辑写在一个角色组件<code>CombatComponent</code>中。在其中声明两个变量，分别为角色和装备的武器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AMultiplayerTPSCharacter</span>* Character;</span><br><span class="line">AWeapon* EquippedWeapon;</span><br></pre></td></tr></table></figure><p>为了方便角色访问组件，这里将角色类设为了组件类的友元类。这种行为一般来说是不推荐的，但是因为组件本质上是角色的一部分，所以这里这样做没问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">AMultiplayerTPSCharacter</span>;</span><br></pre></td></tr></table></figure><p>装备武器的逻辑实现如下，将武器附着到角色的手部插槽，并更新武器状态为已装备。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::EquipWeapon</span><span class="params">(AWeapon* WeaponToEquip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Character == <span class="literal">nullptr</span> || WeaponToEquip == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">EquippedWeapon = WeaponToEquip;</span><br><span class="line">EquippedWeapon-&gt;<span class="built_in">SetWeaponState</span>(EWeaponState::EWS_Equipped);</span><br><span class="line"><span class="type">const</span> USkeletalMeshSocket* HandSocket = Character-&gt;<span class="built_in">GetMesh</span>()-&gt;<span class="built_in">GetSocketByName</span>(<span class="built_in">FName</span>(<span class="string">&quot;RightHandSocket&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (HandSocket) &#123;</span><br><span class="line">HandSocket-&gt;<span class="built_in">AttachActor</span>(EquippedWeapon, Character-&gt;<span class="built_in">GetMesh</span>());</span><br><span class="line">&#125;</span><br><span class="line">EquippedWeapon-&gt;<span class="built_in">SetOwner</span>(Character);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>角色类是复制的，但是战斗组件不是，所以角色持有战斗组件后要将其设为复制的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSCharacter.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UCombatComponent</span>* Combat;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MultiplayerTPSCharacter.cpp</span></span><br><span class="line">Combat = <span class="built_in">CreateDefaultSubobject</span>&lt;UCombatComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;CombatComponent&quot;</span>));</span><br><span class="line">Combat-&gt;<span class="built_in">SetIsReplicated</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::PostInitializeComponents</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">PostInitializeComponents</span>();</span><br><span class="line"><span class="keyword">if</span> (Combat) &#123;</span><br><span class="line">Combat-&gt;Character = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拾取武器的操作只能在服务器上进行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::EquipButtonPressed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Combat &amp;&amp; <span class="built_in">HasAuthority</span>()) &#123;</span><br><span class="line">Combat-&gt;<span class="built_in">EquipWeapon</span>(OverlappingWeapon);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前服务器的装备武器操作还没有同步到客户端上。对于变量，我们使用复制的方式进行同步，那对于“操作”呢。</p><p><strong>远程程序调用(RPC)</strong> 是在一台或多台连接的机器上远程执行本地调用的函数。RPC可帮助客户端和服务器通过网络连接相互调用函数。RPC是一种重要机制，它补充了使用 <code>Replicated</code> 或 <code>ReplicatedUsing</code> 说明符的复制属性。要调用RPC，必须从Actor或Actor组件调用RPC，并设置要复制的Actor或相关Actor组件。</p><p>简单来说，RPC可以分为<strong>调用</strong>和<strong>执行</strong>，当调用RPC函数时会根据规则在本机或者别的机器上执行实现函数。</p><p><a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/remote-procedure-calls-in-unreal-engine?application_version=5.5">虚幻引擎中的远程程序调用 | 虚幻引擎 5.5 文档 | Epic Developer Community</a></p><p><a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/actor-owner-and-owning-connection-in-unreal-engine?application_version=5.5">虚幻引擎中的Actor所有者和所属连接 | 虚幻引擎 5.5 文档 | Epic Developer Community</a></p><p>我画了几张图来表示几种<code>RPC</code>的工作原理。</p><p>假设一共有三个玩家在一起进行游戏，其中有两个客户端，他们都连接到<code>Listened Server</code>。对于使用<code>Listened Server</code>的模型，<code>Listened Server</code>本身即是服务器，同时也是特殊的客户端。在每一个客户端上都存在三个角色（对于Actor也是同理），对于自己的角色，可以称之为称之为<strong>本地控制的(Locally Controlled)</strong>；而另外两个角色都是经由服务器发送的数据进行模拟的，可以称之为<strong>本地模拟的(Simulated)</strong>；另外，服务器上的角色都是<strong>权威的(Authority)</strong>，通常那些重要数据只能在权威的Actor上才能进行修改。</p><p>注意，这是我自己根据实际开发的过程中的理解进行划分的，叫法和之前的<code>Net Role</code>略有不同，但是意思基本一样，因为在开发中基本上就是通过<code>HasAuthority()</code>和<code>IsLocallyControlled()</code>来判断<code>Actor</code>所属的。同时，对于<code>Listened Server</code>，<code>Actor</code>可能既是权威的，又是本地控制的。</p><p><img src="/undefined/e6c9f323/CS模型.png" alt="CS模型"></p><p><strong><code>Server RPC</code></strong>：如果是本地控制的<code>Actor</code>调用，将会由服务器上对应的<code>Actor</code>来执行。</p><p><img src="/undefined/e6c9f323/Server RPC.png" alt="Server RPC"></p><p><strong><code>Client RPC</code></strong>：如果是服务器上的<code>Actor</code>调用，将会由<code>Actor</code>的所属客户端上的对应来执行。</p><p><img src="/undefined/e6c9f323/Client RPC.png" alt="Client RPC"></p><p><strong><code>NetMultacast RPC</code></strong>：我通常直接称之为<code>Multicast RPC</code>或者多播RPC（因为官方文档中其函数前缀就是<code>Multacast</code>），被设计于在服务器上调用，会由所有客户端上对应的<code>Actor</code>来执行。</p><p><img src="/undefined/e6c9f323/Multicast RPC.png" alt="Multicast RPC"></p><p>这里使用<strong><code>Server RPC</code></strong>来实现装备武器的同步，以及初步了解RPC的用法。</p><p>首先要声明一个RPC函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RPC函数一般以RPC类型为前缀，如Server，Client，Multicast</span></span><br><span class="line"><span class="comment">//UFUNCTION宏中需要声明RPC类型，以及是否可靠。类似于TCP和UDP，如果声明RPC为Reliable，RPC调用会确保成功执行了RPC函数，但是会增加网络开销，尽量用于比较重要的操作</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(Server, Reliable)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ServerEquipButtonPressed</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p><strong>在定义函数时要在函数后面加上后缀<code>_Implementation</code></strong>，代表RPC函数的实现。编译时不会报错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::ServerEquipButtonPressed_Implementation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Combat) &#123;</span><br><span class="line">Combat-&gt;<span class="built_in">EquipWeapon</span>(OverlappingWeapon);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按下装备键的回调函数改为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::EquipButtonPressed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Combat) &#123;</span><br><span class="line"><span class="comment">//如果在服务器上调用，直接装备武器</span></span><br><span class="line"><span class="comment">//否则调用Server RPC</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">HasAuthority</span>()) &#123; </span><br><span class="line">Combat-&gt;<span class="built_in">EquipWeapon</span>(OverlappingWeapon);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">ServerEquipButtonPressed</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说实话，我觉得这样写真的很不优雅。经过查阅资料和自己验证，我确定这里不需要判断是否是权威的，直接调用<code>Server RPC</code>即可。对于<code>Listened Server</code>，其同样算是特殊的客户端，所以同样会执行<code>Server RPC</code>，并且是直接在本地执行的，不会经过网络。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::EquipButtonPressed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Combat) &#123;</span><br><span class="line"><span class="built_in">ServerEquipButtonPressed</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>这样就保证了任何机器试图装备武器时，其操作都是在服务器上执行的。</p><p>再回过头来看装备武器的逻辑。将要装备的武器的状态改为<code>EWS_Equipped</code>，将其附着到角色的手部插槽上，然后将其Owner设为角色，将其拾取UI组件隐藏。Weapon自身是可复制的，所以这里面大部分操作都会自动同步到所有机器，除了“将其拾取UI组件隐藏”这一步，因为这是我们自己的逻辑和变量。那么要如何实现拾取UI组件逻辑的同步？</p><p>可以注意到，装备武器后会改变<code>WeaponState</code>这个变量。那么我们将其设为复制，然后在回调函数中隐藏拾取UI组件不就行了吗？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Weapon.h</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">GetLifetimeReplicatedProps</span><span class="params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnRep_WeaponState</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(ReplicatedUsing = OnRep_WeaponState, VisibleAnywhere, Category = <span class="string">&quot;Weapon Properties&quot;</span>)</span><br><span class="line">EWeaponState WeaponState;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Weapon.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AWeapon::GetLifetimeReplicatedProps</span><span class="params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">GetLifetimeReplicatedProps</span>(OutLifetimeProps);</span><br><span class="line"><span class="built_in">DOREPLIFETIME</span>(AWeapon, WeaponState);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AWeapon::OnRep_WeaponState</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (WeaponState) &#123;</span><br><span class="line"><span class="keyword">case</span> EWeaponState::EWS_Equipped:</span><br><span class="line"><span class="built_in">ShowPickWidget</span>(<span class="literal">false</span>);</span><br><span class="line">AreaSphere-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补一个设置武器状态的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AWeapon::SetWeaponState</span><span class="params">(EWeaponState State)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">WeaponState = State;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>装备武器后需要更新角色的动画。实现的逻辑和简单，在角色类中实现一个接口返回当前是否装备武器，动画实例类中实时通过这个接口获取当前是否装备武器，并据此在动画蓝图中切换动画状态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSCharacter.cpp</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AMultiplayerTPSCharacter::IsWeaponEquipped</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (Combat &amp;&amp; Combat-&gt;EquippedWeapon);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MultiplayerTPSAnimInstance.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly, Category = <span class="string">&quot;Movement&quot;</span>, meta = (AllowPrivateAccess = <span class="string">&quot;true&quot;</span>))</span><br><span class="line"><span class="type">bool</span> bWeaponEquipped;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MultiplayerTPSAnimInstance.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMultiplayerTPSAnimInstance::NativeUpdateAnimation</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">NativeUpdateAnimation</span>(DeltaTime);</span><br><span class="line">...</span><br><span class="line">    bWeaponEquipped = MultiplayerTPSCharacter-&gt;<span class="built_in">IsWeaponEquipped</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唯一的问题是装备的武器是在服务器上更新的，需要进行复制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CombatComponent.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(Replicated)</span><br><span class="line">AWeapon* EquippedWeapon;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CombatComponent.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::GetLifetimeReplicatedProps</span><span class="params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">GetLifetimeReplicatedProps</span>(OutLifetimeProps);</span><br><span class="line"></span><br><span class="line"><span class="built_in">DOREPLIFETIME</span>(UCombatComponent, EquippedWeapon);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-蹲伏"><a href="#3-4-蹲伏" class="headerlink" title="3.4 蹲伏"></a>3.4 蹲伏</h3><p>蹲伏功能很简单，可以直接调用角色类实现的函数。记得要启用蹲伏功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//角色的构造函数</span></span><br><span class="line"><span class="built_in">GetCharacterMovement</span>()-&gt;NavAgentProps.bCanCrouch = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定蹲伏按键的回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::CrouchButtonPressed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bIsCrouched) &#123;</span><br><span class="line"><span class="built_in">UnCrouch</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">Crouch</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以直接在动画蓝图中获取当前是否在蹲伏来切换动画状态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bIsCrouched = MultiplayerTPSCharacter-&gt;bIsCrouched;</span><br></pre></td></tr></table></figure><p>作为角色类的内置功能，<code>Crouch()</code>和<code>UnCrouch()</code>已经处理好了网络同步的相关功能，我们不需要考虑相关问题。</p><h3 id="3-5-瞄准"><a href="#3-5-瞄准" class="headerlink" title="3.5 瞄准"></a>3.5 瞄准</h3><p>瞄准主要依赖于战斗组件中的一个变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSCharacter.h</span></span><br><span class="line"><span class="type">bool</span> bAiming;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MultiplayerTPSCharacter.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::AimButtonPressed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Combat) &#123;</span><br><span class="line">Combat-&gt;bAiming = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::AimButtonReleased</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Combat) &#123;</span><br><span class="line">Combat-&gt;bAiming = <span class="literal">false</span>;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AMultiplayerTPSCharacter::IsAiming</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (Combat &amp;&amp; Combat-&gt;bAiming);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动画实例类中实时获取当前是否在瞄准，来切换动画蓝图中的状态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly, Category = <span class="string">&quot;Movement&quot;</span>, meta = (AllowPrivateAccess = <span class="string">&quot;true&quot;</span>))</span><br><span class="line"><span class="type">bool</span> bAiming;</span><br></pre></td></tr></table></figure><p>这样就完成了瞄准的<strong>本地实现</strong>，现在需要将瞄准同步到所有客户端。要用什么方法呢？</p><p>瞄准是在本地按键后执行的，而<strong>复制只能在当服务器上的值改变时将其同步到所有连接</strong>，如果将<code>bAiming</code>设为复制属性，那么客户端瞄准时也无法将这个状态同步给服务器和其它客户端。所以除了复制以外，还要使用<code>Server RPC</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CombatComponent.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(Replicated)</span><br><span class="line"><span class="type">bool</span> bAiming;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetAiming</span><span class="params">(<span class="type">bool</span> bIsAiming)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>(Server, Reliable)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ServerSetAiming</span><span class="params">(<span class="type">bool</span> bIsAiming)</span></span>;</span><br></pre></td></tr></table></figure><p>角色瞄准时从直接设置瞄准变为执行<code>SetAiming</code>函数。在<code>SetAiming</code>函数中会执行<code>ServerSetAiming</code>函数，在服务器上设置<code>bAiming</code>。而当服务器上<code>bAiming</code>改变后，就会通过复制改变所有连接的对应属性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSCharacter.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::AimButtonPressed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Combat) &#123;</span><br><span class="line">Combat-&gt;<span class="built_in">SetAiming</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::AimButtonReleased</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Combat) &#123;</span><br><span class="line">Combat-&gt;<span class="built_in">SetAiming</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CombatComponent.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::SetAiming</span><span class="params">(<span class="type">bool</span> bIsAiming)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">bAiming = bIsAiming;</span><br><span class="line"><span class="built_in">ServerSetAiming</span>(bIsAiming);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::ServerSetAiming_Implementation</span><span class="params">(<span class="type">bool</span> bIsAiming)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">bAiming = bIsAiming;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当装备武器时会使用控制器控制角色Yaw方向的旋转，此时需要使用混合空间来控制角色在不同方向移动时的动作。混合空间需要Yaw和Lean两个输入，我们在动画实例类中实时计算这两个值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSAnimInstance.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly, Category = <span class="string">&quot;Movement&quot;</span>, meta = (AllowPrivateAccess = <span class="string">&quot;true&quot;</span>))</span><br><span class="line"><span class="type">float</span> YawOffset;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly, Category = <span class="string">&quot;Movement&quot;</span>, meta = (AllowPrivateAccess = <span class="string">&quot;true&quot;</span>))</span><br><span class="line"><span class="type">float</span> Lean;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MultiplayerTPSAnimInstance.cpp</span></span><br><span class="line">FRotator AimRotation = MultiplayerTPSCharacter-&gt;<span class="built_in">GetBaseAimRotation</span>();</span><br><span class="line">FRotator MovementRotation = UKismetMathLibrary::<span class="built_in">MakeRotFromX</span>(MultiplayerTPSCharacter-&gt;<span class="built_in">GetVelocity</span>());</span><br><span class="line"></span><br><span class="line">FRotator DeltaRot = UKismetMathLibrary::<span class="built_in">NormalizedDeltaRotator</span>(MovementRotation, AimRotation);</span><br><span class="line">DeltaRotation = FMath::<span class="built_in">RInterpTo</span>(DeltaRotation, DeltaRot, DeltaTime, <span class="number">6.f</span>);</span><br><span class="line">YawOffset = DeltaRotation.Yaw;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lean</span></span><br><span class="line">CharacterRotationLastFrame = CharacterRotation;</span><br><span class="line">CharacterRotation = MultiplayerTPSCharacter-&gt;<span class="built_in">GetActorRotation</span>();</span><br><span class="line"><span class="type">const</span> FRotator Delta = UKismetMathLibrary::<span class="built_in">NormalizedDeltaRotator</span>(CharacterRotation, CharacterRotationLastFrame);</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> Target = Delta.Yaw / DeltaTime;</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> Interp = FMath::<span class="built_in">FInterpTo</span>(Lean, Target, DeltaTime, <span class="number">6.f</span>);</span><br><span class="line">Lean = FMath::<span class="built_in">Clamp</span>(Interp, <span class="number">-90.f</span>, <span class="number">90.f</span>);</span><br></pre></td></tr></table></figure><p>在装备武器时设置<code>bOrientRotationToMovement = false</code>和<code>bUseControllerRotationYaw = true</code>，但是这两个值是不会自动复制的。可以使用之前已经设为<code>EquippedWeapon</code>属性，当其改变时检测其是否为空，如果不为空，说明装备了武器，此时可以用<code>ReplicatedUsing =</code>来调用回调函数设置这两个值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CombatComponent.h</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnRep_EquipWeapon</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(ReplicatedUsing = OnRep_EquipWeapon)</span><br><span class="line">AWeapon* EquippedWeapon;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CombatComponent.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::OnRep_EquipWeapon</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (EquippedWeapon &amp;&amp; Character) &#123;</span><br><span class="line">Character-&gt;<span class="built_in">GetCharacterMovement</span>()-&gt;bOrientRotationToMovement = <span class="literal">false</span>;</span><br><span class="line">Character-&gt;bUseControllerRotationYaw = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>瞄准时需要降低移动速度，逻辑很简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CombatComponent.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line"><span class="type">float</span> BaseWalkSpeed;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line"><span class="type">float</span> AimWalkSpeed;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CombatComponent.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::SetAiming</span><span class="params">(<span class="type">bool</span> bIsAiming)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">bAiming = bIsAiming;</span><br><span class="line"><span class="built_in">ServerSetAiming</span>(bIsAiming);</span><br><span class="line"><span class="keyword">if</span> (Character) &#123;</span><br><span class="line">Character-&gt;<span class="built_in">GetCharacterMovement</span>()-&gt;MaxWalkSpeed = bIsAiming ? AimWalkSpeed : BaseWalkSpeed;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移动速度作为角色类的内置属性应该是会自动复制的。然而<strong>移动速度这个值是由服务器权威控制的</strong>，在客户端本地修改这个值不但同步无法生效，甚至在客户端本地的修改也不会生效，而是会被服务器的值不断覆盖。因此我们只能在服务器修改这个值。之前我们实现了瞄准时的<code>Server RPC</code>，在那里进行修改即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::ServerSetAiming_Implementation</span><span class="params">(<span class="type">bool</span> bIsAiming)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">bAiming = bIsAiming;</span><br><span class="line"><span class="keyword">if</span> (Character) &#123;</span><br><span class="line">Character-&gt;<span class="built_in">GetCharacterMovement</span>()-&gt;MaxWalkSpeed = bIsAiming ? AimWalkSpeed : BaseWalkSpeed;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>瞄准时还要放大<code>FOV</code>。通过插值完成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Weapon.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line"><span class="type">float</span> ZoomedFOV = <span class="number">30.f</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line"><span class="type">float</span> ZoomInterpSpeed = <span class="number">20.f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">FORCEINLINE <span class="type">float</span> <span class="title">GetZoomedFOV</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> ZoomedFOV; &#125;</span><br><span class="line"><span class="function">FORCEINLINE <span class="type">float</span> <span class="title">GetZoomInterpSpeed</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> ZoomInterpSpeed; &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CombatComponent.h</span></span><br><span class="line"><span class="comment">//Aiming and FOV</span></span><br><span class="line"><span class="type">float</span> DefaultFOV;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, Category = <span class="string">&quot;Combat&quot;</span>)</span><br><span class="line"><span class="type">float</span> ZoomedFOV = <span class="number">30.f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> CurrentFOV;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, Category = <span class="string">&quot;Combat&quot;</span>)</span><br><span class="line"><span class="type">float</span> ZoomInterpSpeed = <span class="number">20.f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InterpFOV</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CombatComponent.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Character) &#123;</span><br><span class="line">        ...</span><br><span class="line"><span class="keyword">if</span> (Character-&gt;<span class="built_in">GetFollowCamera</span>()) &#123;</span><br><span class="line">DefaultFOV = Character-&gt;<span class="built_in">GetFollowCamera</span>()-&gt;FieldOfView;</span><br><span class="line">CurrentFOV = DefaultFOV;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::InterpFOV</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!EquippedWeapon) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bAiming) &#123;</span><br><span class="line">CurrentFOV = FMath::<span class="built_in">FInterpTo</span>(CurrentFOV, EquippedWeapon-&gt;<span class="built_in">GetZoomedFOV</span>(), DeltaTime, EquippedWeapon-&gt;<span class="built_in">GetZoomInterpSpeed</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">CurrentFOV = FMath::<span class="built_in">FInterpTo</span>(CurrentFOV, DefaultFOV, DeltaTime, ZoomInterpSpeed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Character &amp;&amp; Character-&gt;<span class="built_in">GetFollowCamera</span>()) &#123;</span><br><span class="line">Character-&gt;<span class="built_in">GetFollowCamera</span>()-&gt;<span class="built_in">SetFieldOfView</span>(CurrentFOV);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::TickComponent</span><span class="params">(<span class="type">float</span> DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">TickComponent</span>(DeltaTime, TickType, ThisTickFunction);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Character &amp;&amp; Character-&gt;<span class="built_in">IsLocallyControlled</span>()) &#123;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">InterpFOV</span>(DeltaTime);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-瞄准偏移"><a href="#3-6-瞄准偏移" class="headerlink" title="3.6 瞄准偏移"></a>3.6 瞄准偏移</h3><p>在很多第三人称游戏中，当我们移动视角时，角色并不会一直随着摄像机进行旋转。当视角旋转幅度不大时角色会转动头部或上半身，直到视角旋转到了角色身后才会转身。这种转动上半身的效果可以通过瞄准偏移实现。</p><p>瞄准偏移属于动画的一种，根据输入的<code>Yaw</code>和<code>Pitch</code>计算角色上半身的旋转和俯仰。</p><p>在角色类中声明这两个值，并在Tick中进行计算：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSCharacter.h</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">float</span> AO_Yaw;</span><br><span class="line"><span class="type">float</span> AO_Pitch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">FORCEINLINE <span class="type">float</span> <span class="title">GetAO_Yaw</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> AO_Yaw; &#125;</span><br><span class="line"><span class="function">FORCEINLINE <span class="type">float</span> <span class="title">GetAO_Pitch</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> AO_Pitch; &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSCharacter.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::AimOffset</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Combat &amp;&amp; !Combat-&gt;EquippedWeapon) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">FVector Velocity = <span class="built_in">GetVelocity</span>();</span><br><span class="line">Velocity.Z = <span class="number">0.f</span>;</span><br><span class="line"><span class="type">float</span> Speed = Velocity.<span class="built_in">Size</span>();</span><br><span class="line"><span class="type">bool</span> bIsInAir = <span class="built_in">GetCharacterMovement</span>()-&gt;<span class="built_in">IsFalling</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果站在原地不动</span></span><br><span class="line"><span class="keyword">if</span> (Speed == <span class="number">0.f</span> &amp;&amp; !bIsInAir) &#123;</span><br><span class="line">FRotator CurrentAimRotation = <span class="built_in">FRotator</span>(<span class="number">0.f</span>, <span class="built_in">GetBaseAimRotation</span>().Yaw, <span class="number">0.f</span>);</span><br><span class="line">FRotator DeltaAimRotation = UKismetMathLibrary::<span class="built_in">NormalizedDeltaRotator</span>(CurrentAimRotation, StartingAimRotation);</span><br><span class="line">AO_Yaw = DeltaAimRotation.Yaw;</span><br><span class="line">        <span class="keyword">if</span> (TurningInPlace == ETurningInPlace::ETIP_NotTurning) &#123;</span><br><span class="line">InterpAO_Yaw = AO_Yaw;</span><br><span class="line">&#125;</span><br><span class="line">bUseControllerRotationYaw = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//如果正在移动或者在空中</span></span><br><span class="line"><span class="keyword">if</span> (Speed &gt; <span class="number">0.f</span> || bIsInAir) &#123;</span><br><span class="line">StartingAimRotation = <span class="built_in">FRotator</span>(<span class="number">0.f</span>, <span class="built_in">GetBaseAimRotation</span>().Yaw, <span class="number">0.f</span>);</span><br><span class="line">bUseControllerRotationYaw = <span class="literal">true</span>;</span><br><span class="line">AO_Yaw = <span class="number">0.f</span>;</span><br><span class="line">&#125;</span><br><span class="line">AO_Pitch = <span class="built_in">GetBaseAimRotation</span>().Pitch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在动画蓝图中就可以使用这两个值实现瞄准偏移了。</p><p>还有一个问题。角色类中的AO_Pitch会进行自动复制，但是在传输过程中引擎会将这个值进行压缩来实现更高的传输效率，但是在解压时会解压成一个在[0,360]之间的值。当角色低头时，Pitch在[-90,0]之间，压缩再解压后就变成了[270,360]之间的值，导致在传输后的低头逻辑错误。解决方法很简单，将解压后的值进行映射即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">IsLocallyControlled</span>() &amp;&amp; AO_Pitch &gt; <span class="number">90.f</span>) &#123;</span><br><span class="line"><span class="comment">//将Pitch从[270,360)映射到[-90,0)</span></span><br><span class="line"><span class="function">FVector2D <span class="title">InRange</span><span class="params">(<span class="number">270.f</span>, <span class="number">360.f</span>)</span></span>;</span><br><span class="line"><span class="function">FVector2D <span class="title">OutRange</span><span class="params">(<span class="number">-90.f</span>, <span class="number">0.f</span>)</span></span>;</span><br><span class="line">AO_Pitch = FMath::<span class="built_in">GetMappedRangeValueClamped</span>(InRange, OutRange, AO_Pitch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随着上半身的旋转，会出现角色的左手和武器无法匹配的情况，可以使用<code>FABRIK</code>来解决，将左手放在武器对应的插槽上。这里主要讲一下如何获取左手要放置的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSAnimInstance.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly, Category = <span class="string">&quot;Movement&quot;</span>, meta = (AllowPrivateAccess = <span class="string">&quot;true&quot;</span>))</span><br><span class="line">FTransform LeftHandTransform;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSAnimInstance.cpp</span></span><br><span class="line"><span class="keyword">if</span> (bWeaponEquipped &amp;&amp; EquippedWeapon &amp;&amp; EquippedWeapon-&gt;<span class="built_in">GetWeaponMesh</span>() &amp;&amp; MultiplayerTPSCharacter-&gt;<span class="built_in">GetMesh</span>()) &#123;</span><br><span class="line">LeftHandTransform = EquippedWeapon-&gt;<span class="built_in">GetWeaponMesh</span>()-&gt;<span class="built_in">GetSocketTransform</span>(<span class="built_in">FName</span>(<span class="string">&quot;LeftHandSocket&quot;</span>), ERelativeTransformSpace::RTS_World);</span><br><span class="line">FVector OutPosition;</span><br><span class="line">FRotator OutRotation;</span><br><span class="line">MultiplayerTPSCharacter-&gt;<span class="built_in">GetMesh</span>()-&gt;<span class="built_in">TransformToBoneSpace</span>(<span class="built_in">FName</span>(<span class="string">&quot;hand_r&quot;</span>), LeftHandTransform.<span class="built_in">GetLocation</span>(), FRotator::ZeroRotator, OutPosition, OutRotation);</span><br><span class="line">LeftHandTransform.<span class="built_in">SetLocation</span>(OutPosition);</span><br><span class="line">LeftHandTransform.<span class="built_in">SetRotation</span>(<span class="built_in">FQuat</span>(OutRotation));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和瞄准偏移相对应的是当偏移到一定程度后角色要进行转身。</p><p>定义一个枚举表示角色当前的转身状态。当AO_Yaw超过指定范围后就切换转身状态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSCharacter.h</span></span><br><span class="line"><span class="built_in">UENUM</span>(BlueprintType)</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">ETurningInPlace</span> : uint8 &#123;</span><br><span class="line"><span class="function">ETIP_Left <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Turning Left&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">ETIP_Right <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Turning Right&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">ETIP_NotTurning <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Not Turning&quot;</span>)</span>,</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">ETIP_MAX <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;DefaultMAX&quot;</span>)</span></span></span><br><span class="line"><span class="function">&#125;</span>;</span><br><span class="line"></span><br><span class="line">ETurningInPlace TurningInPlace;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TurnInPlace</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::TurnInPlace</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (AO_Yaw &gt; <span class="number">90.f</span>) &#123;</span><br><span class="line">TurningInPlace = ETurningInPlace::ETIP_Right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (AO_Yaw &lt; <span class="number">-90.f</span>) &#123;</span><br><span class="line">TurningInPlace = ETurningInPlace::ETIP_Left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (TurningInPlace != ETurningInPlace::ETIP_NotTurning) &#123;</span><br><span class="line">InterpAO_Yaw = FMath::<span class="built_in">FInterpTo</span>(InterpAO_Yaw, <span class="number">0.f</span>, DeltaTime, <span class="number">4.f</span>);</span><br><span class="line">AO_Yaw = InterpAO_Yaw;</span><br><span class="line"><span class="keyword">if</span> (FMath::<span class="built_in">Abs</span>(AO_Yaw) &lt; <span class="number">15.f</span>) &#123;</span><br><span class="line">TurningInPlace = ETurningInPlace::ETIP_NotTurning;</span><br><span class="line">StartingAimRotation = <span class="built_in">FRotator</span>(<span class="number">0.f</span>, <span class="built_in">GetBaseAimRotation</span>().Yaw, <span class="number">0.f</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个变量在初始时设为<code>NotInTurning</code>，并在<code>AimOffset</code>函数中计算枚举的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果站在原地不动</span></span><br><span class="line"><span class="keyword">if</span> (Speed == <span class="number">0.f</span> &amp;&amp; !bIsInAir) &#123;</span><br><span class="line">FRotator CurrentAimRotation = <span class="built_in">FRotator</span>(<span class="number">0.f</span>, <span class="built_in">GetBaseAimRotation</span>().Yaw, <span class="number">0.f</span>);</span><br><span class="line">FRotator DeltaAimRotation = UKismetMathLibrary::<span class="built_in">NormalizedDeltaRotator</span>(CurrentAimRotation, StartingAimRotation);</span><br><span class="line">AO_Yaw = DeltaAimRotation.Yaw;</span><br><span class="line">bUseControllerRotationYaw = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">TurnInPlace</span>(DeltaTime);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运动时</span></span><br><span class="line"><span class="keyword">if</span> (Speed &gt; <span class="number">0.f</span> || bIsInAir) &#123;</span><br><span class="line">StartingAimRotation = <span class="built_in">FRotator</span>(<span class="number">0.f</span>, <span class="built_in">GetBaseAimRotation</span>().Yaw, <span class="number">0.f</span>);</span><br><span class="line">bUseControllerRotationYaw = <span class="literal">true</span>;</span><br><span class="line">AO_Yaw = <span class="number">0.f</span>;</span><br><span class="line">TurningInPlace = ETurningInPlace::ETIP_NotTurning;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FORCEINLINE ETurningInPlace <span class="title">GetTurningInPlace</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> TurningInPlace; &#125;</span><br></pre></td></tr></table></figure><p>在动画实例类中实时获取这个值，并根据这个值在动画蓝图中使用<code>RotateRootBone</code>节点实现转身即可。</p><h3 id="3-7-基础射击"><a href="#3-7-基础射击" class="headerlink" title="3.7 基础射击"></a>3.7 基础射击</h3><p>本项目的射击方式分为两种：<strong>延迟弹道</strong>和<strong>即时命中</strong>。首先实现延迟弹道。</p><p>延迟弹道是指开火时会发射子弹，子弹命中后造成伤害。所以我们首先需要创建一个投射物类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AProjectile::<span class="built_in">AProjectile</span>()</span><br><span class="line">&#123;</span><br><span class="line">PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line">CollisionBox = <span class="built_in">CreateDefaultSubobject</span>&lt;UBoxComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;CollisionBox&quot;</span>));</span><br><span class="line"><span class="built_in">SetRootComponent</span>(CollisionBox);</span><br><span class="line">CollisionBox-&gt;<span class="built_in">SetCollisionObjectType</span>(ECollisionChannel::ECC_WorldDynamic);</span><br><span class="line">CollisionBox-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::QueryAndPhysics);</span><br><span class="line">CollisionBox-&gt;<span class="built_in">SetCollisionResponseToAllChannels</span>(ECollisionResponse::ECR_Ignore);</span><br><span class="line">CollisionBox-&gt;<span class="built_in">SetCollisionResponseToChannel</span>(ECollisionChannel::ECC_Visibility, ECollisionResponse::ECR_Block);</span><br><span class="line">CollisionBox-&gt;<span class="built_in">SetCollisionResponseToChannel</span>(ECollisionChannel::ECC_WorldStatic, ECollisionResponse::ECR_Block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按下开火键后为角色和武器播放开火动画。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSCharacter.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::FireButtonPressed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Combat) &#123;</span><br><span class="line">Combat-&gt;<span class="built_in">FireButtonPressed</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::FireButtonReleased</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Combat) &#123;</span><br><span class="line">Combat-&gt;<span class="built_in">FireButtonPressed</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::PlayFireMontage</span><span class="params">(<span class="type">bool</span> bAiming)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!Combat || !Combat-&gt;EquippedWeapon) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UAnimInstance* AnimInstance = <span class="built_in">GetMesh</span>()-&gt;<span class="built_in">GetAnimInstance</span>();</span><br><span class="line"><span class="keyword">if</span> (AnimInstance &amp;&amp; FireWeaponMontage) &#123;</span><br><span class="line">AnimInstance-&gt;<span class="built_in">Montage_Play</span>(FireWeaponMontage);</span><br><span class="line">FName SectionName;</span><br><span class="line">SectionName = bAiming ? <span class="built_in">FName</span>(<span class="string">&quot;RifleAim&quot;</span>) : <span class="built_in">FName</span>(<span class="string">&quot;RifleHip&quot;</span>);</span><br><span class="line">AnimInstance-&gt;<span class="built_in">Montage_JumpToSection</span>(SectionName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CombatComponent.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::FireButtonPressed</span><span class="params">(<span class="type">bool</span> bPressed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">bFireButtonPressed = bPressed;</span><br><span class="line"><span class="keyword">if</span> (!EquippedWeapon) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (Character &amp;&amp; bFireButtonPressed) &#123;</span><br><span class="line">Character-&gt;<span class="built_in">PlayerFireMontage</span>(bAiming);</span><br><span class="line">EquippedWeapon-&gt;<span class="built_in">Fire</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Weapon.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, Category = <span class="string">&quot;Weapon Properties&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UAnimationAsset</span>* FireAnimation;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fire</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Weapon.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AWeapon::Fire</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (FireAnimation) &#123;</span><br><span class="line">WeaponMesh-&gt;<span class="built_in">PlayAnimation</span>(FireAnimation, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就实现了<strong>本地的射击</strong>。</p><p>要实现开火的同步，解决方法当然是RPC。我们可以使用一个<code>Server RPC</code>和一个<code>Multicast RPC</code>，当开火时调用<code>Server RPC</code>，服务器在执行<code>Server RPC</code>时再调用<code>Multicast RPC</code>，而真正的开火逻辑则放在<code>Multicast RPC</code>的实现中，调用<code>Multicast RPC</code>后会在每一台电脑上执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSCharacter.h</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(Server, Reliable)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ServerFire</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>(NetMulticast, Reliable)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MulticastFire</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>之前战斗组件中开火键设置的逻辑改为调用<code>Server RPC</code>。开火同步完成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CombatComponent.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::FireButtonPressed</span><span class="params">(<span class="type">bool</span> bPressed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">bFireButtonPressed = bPressed;</span><br><span class="line"><span class="keyword">if</span> (bFireButtonPressed) &#123;</span><br><span class="line"><span class="built_in">ServerFire</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::ServerFire_Implementation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">MulticastFire</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::MulticastFire_Implementation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!EquippedWeapon) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (Character) &#123;</span><br><span class="line">Character-&gt;<span class="built_in">PlayerFireMontage</span>(bAiming);</span><br><span class="line">EquippedWeapon-&gt;<span class="built_in">Fire</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是射击的对象。使用射线检测，以准星为起点向前发射，在Tick中计算准星瞄准的对象，并保存到成员变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::TraceUnderCrosshairs</span><span class="params">(FHitResult&amp; TraceHitResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FVector2D ViewportSize;</span><br><span class="line"><span class="keyword">if</span> (GEngine &amp;&amp; GEngine-&gt;GameViewport) &#123;</span><br><span class="line">GEngine-&gt;GameViewport-&gt;<span class="built_in">GetViewportSize</span>(ViewportSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FVector2D <span class="title">CrosshairLocation</span><span class="params">(ViewportSize.X / <span class="number">2.f</span>, ViewportSize.Y / <span class="number">2.f</span>)</span></span>;</span><br><span class="line">FVector CrosshairWorldPosition;</span><br><span class="line">FVector CrosshairWorldDirection;</span><br><span class="line"><span class="type">bool</span> bScreenToWorld = UGameplayStatics::<span class="built_in">DeprojectScreenToWorld</span>(</span><br><span class="line">UGameplayStatics::<span class="built_in">GetPlayerController</span>(<span class="keyword">this</span>, <span class="number">0</span>),</span><br><span class="line">CrosshairLocation,</span><br><span class="line">CrosshairWorldPosition,</span><br><span class="line">CrosshairWorldDirection</span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (bScreenToWorld) &#123;</span><br><span class="line">FVector Start = CrosshairWorldPosition;</span><br><span class="line">        <span class="comment">//起点向前移一点，防止瞄准到角色自身</span></span><br><span class="line">        <span class="keyword">if</span> (Character) &#123;</span><br><span class="line"><span class="type">float</span> DistanceToCharacter = (Character-&gt;<span class="built_in">GetActorLocation</span>() - Start).<span class="built_in">Size</span>();</span><br><span class="line">Start += CrosshairWorldDirection * (DistanceToCharacter + <span class="number">100.f</span>);</span><br><span class="line">&#125;</span><br><span class="line">FVector End = Start + CrosshairWorldDirection * TRACE_LENGTH;</span><br><span class="line"><span class="built_in">GetWorld</span>()-&gt;<span class="built_in">LineTraceSingleByChannel</span>(</span><br><span class="line">TraceHitResult,</span><br><span class="line">Start,</span><br><span class="line">End,</span><br><span class="line">ECollisionChannel::ECC_Visibility</span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (!TraceHitResult.bBlockingHit) &#123;</span><br><span class="line">TraceHitResult.ImpactPoint = End;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">DrawDebugSphere</span>(</span><br><span class="line"><span class="built_in">GetWorld</span>(),</span><br><span class="line">TraceHitResult.ImpactPoint,</span><br><span class="line"><span class="number">12.f</span>,</span><br><span class="line"><span class="number">12</span>,</span><br><span class="line">FColor::Red</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">if</span> (!TraceHitResult.bBlockingHit) &#123;</span><br><span class="line">TraceHitResult.ImpactPoint = End;</span><br><span class="line">HitTarget = End;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">HitTarget = TraceHitResult.ImpactPoint;</span><br><span class="line"><span class="built_in">DrawDebugSphere</span>(</span><br><span class="line"><span class="built_in">GetWorld</span>(),</span><br><span class="line">TraceHitResult.ImpactPoint,</span><br><span class="line"><span class="number">12.f</span>,</span><br><span class="line"><span class="number">12</span>,</span><br><span class="line">FColor::Red</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-8-弹道武器"><a href="#3-8-弹道武器" class="headerlink" title="3.8 弹道武器"></a>3.8 弹道武器</h3><p>弹道武器的要点就是<strong>在开火时生成一颗子弹，并发射出去</strong>。</p><p>生成子弹的过程很简单，在弹道武器类中重写开火函数，执行父类的开火函数后获取枪口插槽的位置以及目标点到插槽的方向，根据这些信息生成子弹即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AProjectileWeapon::Fire</span><span class="params">(<span class="type">const</span> FVector&amp; HitTarget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">Fire</span>(HitTarget);</span><br><span class="line">APawn* InstigatorPawn = <span class="built_in">Cast</span>&lt;APawn&gt;(<span class="built_in">GetOwner</span>());</span><br><span class="line"><span class="type">const</span> USkeletalMeshSocket* MuzzleFlashSocket = <span class="built_in">GetWeaponMesh</span>()-&gt;<span class="built_in">GetSocketByName</span>(<span class="built_in">FName</span>(<span class="string">&quot;MuzzleFlash&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (MuzzleFlashSocket &amp;&amp; InstigatorPawn) &#123;</span><br><span class="line">FTransform SocketTransform = MuzzleFlashSocket-&gt;<span class="built_in">GetSocketTransform</span>(<span class="built_in">GetWeaponMesh</span>());</span><br><span class="line"><span class="comment">//从MuzzleSocket到命中点</span></span><br><span class="line">FVector ToTarget = HitTarget - SocketTransform.<span class="built_in">GetLocation</span>();</span><br><span class="line">FRotator TargetRotatrion = ToTarget.<span class="built_in">Rotation</span>();</span><br><span class="line"><span class="keyword">if</span> (ProjectileClass) &#123;</span><br><span class="line">FActorSpawnParameters SpawnParams;</span><br><span class="line">SpawnParams.Owner = <span class="built_in">GetOwner</span>();</span><br><span class="line">SpawnParams.Instigator = InstigatorPawn;</span><br><span class="line">UWorld* World = <span class="built_in">GetWorld</span>();</span><br><span class="line"><span class="keyword">if</span> (World) &#123;</span><br><span class="line">World-&gt;<span class="built_in">SpawnActor</span>&lt;AProjectile&gt;(</span><br><span class="line">ProjectileClass,</span><br><span class="line">SocketTransform.<span class="built_in">GetLocation</span>(),</span><br><span class="line">TargetRotatrion,</span><br><span class="line">SpawnParams</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是发射子弹了。幸运的是，UE提供了现成的发射器组件，只需要为子弹附带上这个组件，就可以轻松发射子弹。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Projectile.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UProjectileMovementComponent</span>* ProjectileMovementComponent;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Projectile.cpp</span></span><br><span class="line">AProjectile::<span class="built_in">AProjectile</span>()</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">ProjectileMovementComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;UProjectileMovementComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;ProjectileMovementComponent&quot;</span>));</span><br><span class="line">ProjectileMovementComponent-&gt;bRotationFollowsVelocity = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发射子弹后我们基本上是看不到的，所以需要为子弹添加轨迹来增强视觉效果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Weapon.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UParticleSystem</span>* Tracer;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UParticleSystemComponent</span>* TracerComponent;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Weapon.cpp</span></span><br><span class="line"><span class="keyword">if</span> (Tracer) &#123;</span><br><span class="line">TracerComponent = UGameplayStatics::<span class="built_in">SpawnEmitterAttached</span>(</span><br><span class="line">Tracer,</span><br><span class="line">CollisionBox,</span><br><span class="line"><span class="built_in">FName</span>(),</span><br><span class="line"><span class="built_in">GetActorLocation</span>(),</span><br><span class="line"><span class="built_in">GetActorRotation</span>(),</span><br><span class="line">EAttachLocation::KeepWorldPosition</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子弹也是需要同步的，除了复制子弹之外，还要将准星瞄准的目标也设为复制，当开火时将其传入准星瞄准的参数，才能正确实现子弹的飞行。</p><p>子弹在碰撞后要进行销毁。绑定<code>OnHit</code>事件，在回调函数中处理销毁逻辑：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Projectile.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UParticleSystem* ImpactParticles;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">USoundCue</span>* ImpactSound;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Projectile.cpp</span></span><br><span class="line"><span class="built_in">BeginPlay</span>()&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">HasAuthority</span>()) &#123;</span><br><span class="line">CollisionBox-&gt;OnComponentHit.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;ThisClass::OnHit);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AProjectile::OnHit</span><span class="params">(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, <span class="type">const</span> FHitResult&amp; Hit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Destroy</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AProjectile::Destroyed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">Destroyed</span>();</span><br><span class="line"><span class="keyword">if</span> (ImpactParticles) &#123;</span><br><span class="line">UGameplayStatics::<span class="built_in">SpawnEmitterAtLocation</span>(<span class="built_in">GetWorld</span>(), ImpactParticles, <span class="built_in">GetActorTransform</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ImpactSound) &#123;</span><br><span class="line">UGameplayStatics::<span class="built_in">PlaySoundAtLocation</span>(<span class="keyword">this</span>, ImpactSound, <span class="built_in">GetActorLocation</span>());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>射击后需要抛出弹壳，创建一个<code>Casing</code>类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere)</span><br><span class="line">UStaticMeshComponent* CasingMesh;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ACasing::<span class="built_in">ACasing</span>()</span><br><span class="line">&#123;</span><br><span class="line">PrimaryActorTick.bCanEverTick = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">CasingMesh = <span class="built_in">CreateDefaultSubobject</span>&lt;UStaticMeshComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;CasingMesh&quot;</span>));</span><br><span class="line"><span class="built_in">SetRootComponent</span>(CasingMesh);</span><br><span class="line">    CasingMesh-&gt;<span class="built_in">SetCollisionResponseToChannel</span>(ECollisionChannel::ECC_Camera, ECollisionResponse::ECR_Ignore);</span><br><span class="line">CasingMesh-&gt;<span class="built_in">SetSimulatePhysics</span>(<span class="literal">true</span>);</span><br><span class="line">CasingMesh-&gt;<span class="built_in">SetEnableGravity</span>(<span class="literal">true</span>);</span><br><span class="line">CasingMesh-&gt;<span class="built_in">SetNotifyRigidBodyCollision</span>(<span class="literal">true</span>);</span><br><span class="line">ShellEjectionImpulse = <span class="number">5.f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Weapon.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">TSubclassOf&lt;<span class="keyword">class</span> <span class="title class_">ACasing</span>&gt; CasingClass;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Weapon.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AWeapon::Fire</span><span class="params">(<span class="type">const</span> FVector&amp; HitTarget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (FireAnimation) &#123;</span><br><span class="line">WeaponMesh-&gt;<span class="built_in">PlayAnimation</span>(FireAnimation, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (CasingClass) &#123;</span><br><span class="line"><span class="type">const</span> USkeletalMeshSocket* AmmoEjectSocket = WeaponMesh-&gt;<span class="built_in">GetSocketByName</span>(<span class="built_in">FName</span>(<span class="string">&quot;AmmoEject&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (AmmoEjectSocket) &#123;</span><br><span class="line">FTransform SocketTransform = AmmoEjectSocket-&gt;<span class="built_in">GetSocketTransform</span>(WeaponMesh);</span><br><span class="line">UWorld* World = <span class="built_in">GetWorld</span>();</span><br><span class="line"><span class="keyword">if</span> (World) &#123;</span><br><span class="line">World-&gt;<span class="built_in">SpawnActor</span>&lt;ACasing&gt;(</span><br><span class="line">CasingClass,</span><br><span class="line">SocketTransform.<span class="built_in">GetLocation</span>(),</span><br><span class="line">SocketTransform.<span class="built_in">GetRotation</span>().<span class="built_in">Rotator</span>()</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>落地后要进行销毁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ShellSound) &#123;</span><br><span class="line">UGameplayStatics::<span class="built_in">PlaySoundAtLocation</span>(<span class="keyword">this</span>, ShellSound, <span class="built_in">GetActorLocation</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Destroy</span>();</span><br></pre></td></tr></table></figure><h3 id="3-9-即时命中武器"><a href="#3-9-即时命中武器" class="headerlink" title="3.9 即时命中武器"></a>3.9 即时命中武器</h3><p>没什么好说的，开火时进行射线检测，如果命中角色，对其造成伤害，然后在命中点生成音效和命中特效，并且生成子弹的轨迹。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AHitScanWeapon::Fire</span><span class="params">(<span class="type">const</span> FVector&amp; HitTarget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">Fire</span>(HitTarget);</span><br><span class="line"></span><br><span class="line">APawn* OwnerPawn = <span class="built_in">Cast</span>&lt;APawn&gt;(<span class="built_in">GetOwner</span>());</span><br><span class="line"><span class="keyword">if</span> (!OwnerPawn) <span class="keyword">return</span>;</span><br><span class="line">AController* InstigatorController = OwnerPawn-&gt;<span class="built_in">GetController</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> USkeletalMeshSocket* MuzzleFlashSocket = <span class="built_in">GetWeaponMesh</span>()-&gt;<span class="built_in">GetSocketByName</span>(<span class="string">&quot;MuzzleFlash&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (MuzzleFlashSocket) &#123;</span><br><span class="line">FTransform SocketTransform = MuzzleFlashSocket-&gt;<span class="built_in">GetSocketTransform</span>(<span class="built_in">GetWeaponMesh</span>());</span><br><span class="line">FVector Start = SocketTransform.<span class="built_in">GetLocation</span>();</span><br><span class="line">FVector End = Start + (HitTarget - Start) * <span class="number">1.25f</span>;</span><br><span class="line"></span><br><span class="line">FHitResult FireHit;</span><br><span class="line">UWorld* World = <span class="built_in">GetWorld</span>();</span><br><span class="line"><span class="keyword">if</span> (World) &#123;</span><br><span class="line">World-&gt;<span class="built_in">LineTraceSingleByChannel</span>(</span><br><span class="line">FireHit,</span><br><span class="line">Start,</span><br><span class="line">End,</span><br><span class="line">ECollisionChannel::ECC_Visibility</span><br><span class="line">);</span><br><span class="line">FVector BeamEnd = End;</span><br><span class="line"><span class="keyword">if</span> (FireHit.bBlockingHit) &#123;</span><br><span class="line">BeamEnd = FireHit.ImpactPoint;</span><br><span class="line">AMultiplayerTPSCharacter* MultiplayerTPSCharacter = <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(FireHit.<span class="built_in">GetActor</span>());</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">HasAuthority</span>() &amp;&amp; MultiplayerTPSCharacter &amp;&amp; InstigatorController) &#123;</span><br><span class="line">UGameplayStatics::<span class="built_in">ApplyDamage</span>(</span><br><span class="line">MultiplayerTPSCharacter,</span><br><span class="line">Damage,</span><br><span class="line">InstigatorController,</span><br><span class="line"><span class="keyword">this</span>,</span><br><span class="line">UDamageType::<span class="built_in">StaticClass</span>()</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ImpactParticles) &#123;</span><br><span class="line">UGameplayStatics::<span class="built_in">SpawnEmitterAtLocation</span>(</span><br><span class="line">World,</span><br><span class="line">ImpactParticles,</span><br><span class="line">FireHit.ImpactPoint,</span><br><span class="line">FireHit.ImpactNormal.<span class="built_in">Rotation</span>()</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (BeamParticles) &#123;</span><br><span class="line">UParticleSystemComponent* Beam = UGameplayStatics::<span class="built_in">SpawnEmitterAtLocation</span>(</span><br><span class="line">World,</span><br><span class="line">BeamParticles,</span><br><span class="line">SocketTransform</span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (Beam) &#123;</span><br><span class="line">Beam-&gt;<span class="built_in">SetVectorParameter</span>(<span class="built_in">FName</span>(<span class="string">&quot;Target&quot;</span>), BeamEnd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-10-准星"><a href="#3-10-准星" class="headerlink" title="3.10 准星"></a>3.10 准星</h3><p>准星可以在HUD类中进行绘制，而这个过程一般是由玩家控制器来控制的。因此这里需要创建自己的<code>PlayerController</code>类和<code>HUD</code>类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSHUD.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个结构体，存储准星的五个部分以及扩散和颜色</span></span><br><span class="line"><span class="built_in">USTRUCT</span>(BlueprintType)</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FHUDPackage</span> &#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UTexture2D</span>* CrosshairCenter;</span><br><span class="line">UTexture2D* CrosshairLeft;</span><br><span class="line">UTexture2D* CrosshairRight;</span><br><span class="line">UTexture2D* CrosshairTop;</span><br><span class="line">UTexture2D* CrosshairBottom;</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> CrosshairSpread;</span><br><span class="line">    FLinearColor CrosshairColor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DrawHUD</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">FHUDPackage HUDPackage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">FORCEINLINE <span class="type">void</span> <span class="title">SetHUDPackage</span><span class="params">(<span class="type">const</span> FHUDPackage&amp; Package)</span> </span>&#123; HUDPackage = Package; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在武器类中同样声明五个2D材质变量，用来存储每个武器自己的准星。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Weapon.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UTexture2D</span>* CrosshairCenter;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UTexture2D* CrosshairLeft;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UTexture2D* CrosshairRight;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UTexture2D* CrosshairTop;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UTexture2D* CrosshairBottom;</span><br></pre></td></tr></table></figure><p>在战斗组件中每帧进行准星设置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CombatComponent.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AMPTPSPlayerController</span>* Controller;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AMultiplayerTPSHUD</span>* HUD;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CombatComponent.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::SetHUDCrosshairs</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!Character || !Character-&gt;Controller) <span class="keyword">return</span>;</span><br><span class="line">Controller = Controller == <span class="literal">nullptr</span> ? <span class="built_in">Cast</span>&lt;AMPTPSPlayerController&gt;(Character-&gt;Controller) : Controller;</span><br><span class="line"><span class="keyword">if</span> (Controller) &#123;</span><br><span class="line">HUD = HUD == <span class="literal">nullptr</span> ? <span class="built_in">Cast</span>&lt;AMultiplayerTPSHUD&gt;(Controller-&gt;<span class="built_in">GetHUD</span>()) : HUD;</span><br><span class="line"><span class="keyword">if</span> (HUD) &#123;</span><br><span class="line">FHUDPackage HUDPackage;</span><br><span class="line"><span class="keyword">if</span> (EquippedWeapon) &#123;</span><br><span class="line">HUDPackage.CrosshairCenter = EquippedWeapon-&gt;CrosshairCenter;</span><br><span class="line">HUDPackage.CrosshairLeft = EquippedWeapon-&gt;CrosshairLeft;</span><br><span class="line">HUDPackage.CrosshairRight = EquippedWeapon-&gt;CrosshairRight;</span><br><span class="line">HUDPackage.CrosshairTop = EquippedWeapon-&gt;CrosshairTop;</span><br><span class="line">HUDPackage.CrosshairBottom = EquippedWeapon-&gt;CrosshairBottom;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">HUDPackage.CrosshairCenter = <span class="literal">nullptr</span>;</span><br><span class="line">HUDPackage.CrosshairLeft = <span class="literal">nullptr</span>;</span><br><span class="line">HUDPackage.CrosshairRight = <span class="literal">nullptr</span>;</span><br><span class="line">HUDPackage.CrosshairTop = <span class="literal">nullptr</span>;</span><br><span class="line">HUDPackage.CrosshairBottom = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">HUD-&gt;<span class="built_in">SetHUDPackage</span>(HUDPackage);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在HUD类中实现准星绘制：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSHUD::DrawHUD</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">DrawHUD</span>();</span><br><span class="line"></span><br><span class="line">FVector2D ViewportSize;</span><br><span class="line"><span class="keyword">if</span> (GEngine) &#123;</span><br><span class="line">GEngine-&gt;GameViewport-&gt;<span class="built_in">GetViewportSize</span>(ViewportSize);</span><br><span class="line"><span class="function"><span class="type">const</span> FVector2D <span class="title">ViewportCenter</span><span class="params">(ViewportSize.X / <span class="number">2.f</span>, ViewportSize.Y / <span class="number">2.f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (HUDPackage.CrosshairCenter) &#123;</span><br><span class="line"><span class="built_in">DrawCrosshair</span>(HUDPackage.CrosshairCenter, ViewportCenter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (HUDPackage.CrosshairLeft) &#123;</span><br><span class="line"><span class="built_in">DrawCrosshair</span>(HUDPackage.CrosshairLeft, ViewportCenter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (HUDPackage.CrosshairRight) &#123;</span><br><span class="line"><span class="built_in">DrawCrosshair</span>(HUDPackage.CrosshairRight, ViewportCenter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (HUDPackage.CrosshairTop) &#123;</span><br><span class="line"><span class="built_in">DrawCrosshair</span>(HUDPackage.CrosshairTop, ViewportCenter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (HUDPackage.CrosshairBottom) &#123;</span><br><span class="line"><span class="built_in">DrawCrosshair</span>(HUDPackage.CrosshairBottom, ViewportCenter);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSHUD::DrawCrosshair</span><span class="params">(UTexture2D* Texture, FVector2D ViewportCenter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> TextureWidth = Texture-&gt;<span class="built_in">GetSizeX</span>();</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> TextureHeight = Texture-&gt;<span class="built_in">GetSizeY</span>();</span><br><span class="line"><span class="function"><span class="type">const</span> FVector2D <span class="title">TextureDrawPoint</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">ViewportCenter.X - (TextureWidth / <span class="number">2.f</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">ViewportCenter.Y - (TextureHeight / <span class="number">2.f</span>)</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">DrawTexture</span>(</span><br><span class="line">Texture,</span><br><span class="line">TextureDrawPoint.X,</span><br><span class="line">TextureDrawPoint.Y,</span><br><span class="line">TextureWidth,</span><br><span class="line">TextureHeight,</span><br><span class="line"><span class="number">0.f</span>,</span><br><span class="line"><span class="number">0.f</span>,</span><br><span class="line"><span class="number">1.f</span>,</span><br><span class="line"><span class="number">1.f</span>,</span><br><span class="line">FLinearColor::White</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在射击游戏中，通常准星都会有各种扩散（当然一般来说没什么人会开，但是开不开是玩家的事，有没有是开发者的事），这个扩散值由用各种“因子”来决定，包括速度，瞄准，跳跃，射击等。这里直接给出添加了扩散后的准星绘制代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSHUD.h</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, Category = <span class="string">&quot;Player Stats&quot;</span>)</span><br><span class="line">TSubclassOf&lt;<span class="keyword">class</span> <span class="title class_">UUserWidget</span>&gt; CharacterOverlayClass;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CombatComponent.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::TickComponent</span><span class="params">(<span class="type">float</span> DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (Character &amp;&amp; Character-&gt;<span class="built_in">IsLocallyControlled</span>()) &#123;</span><br><span class="line"><span class="built_in">SetHUDCrosshairs</span>(DeltaTime);</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::SetHUDCrosshairs</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//UE_LOG(LogTemp, Warning, TEXT(&quot;Crosshair set.&quot;));</span></span><br><span class="line"><span class="keyword">if</span> (!Character || !Character-&gt;Controller) <span class="keyword">return</span>;</span><br><span class="line">Controller = Controller == <span class="literal">nullptr</span> ? <span class="built_in">Cast</span>&lt;AMPTPSPlayerController&gt;(Character-&gt;Controller) : Controller;</span><br><span class="line"><span class="keyword">if</span> (Controller) &#123;</span><br><span class="line">HUD = HUD == <span class="literal">nullptr</span> ? <span class="built_in">Cast</span>&lt;AMultiplayerTPSHUD&gt;(Controller-&gt;<span class="built_in">GetHUD</span>()) : HUD;</span><br><span class="line"><span class="keyword">if</span> (HUD) &#123;</span><br><span class="line"><span class="keyword">if</span> (EquippedWeapon) &#123;</span><br><span class="line">HUDPackage.CrosshairCenter = EquippedWeapon-&gt;CrosshairCenter;</span><br><span class="line">HUDPackage.CrosshairLeft = EquippedWeapon-&gt;CrosshairLeft;</span><br><span class="line">HUDPackage.CrosshairRight = EquippedWeapon-&gt;CrosshairRight;</span><br><span class="line">HUDPackage.CrosshairTop = EquippedWeapon-&gt;CrosshairTop;</span><br><span class="line">HUDPackage.CrosshairBottom = EquippedWeapon-&gt;CrosshairBottom;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">HUDPackage.CrosshairCenter = <span class="literal">nullptr</span>;</span><br><span class="line">HUDPackage.CrosshairLeft = <span class="literal">nullptr</span>;</span><br><span class="line">HUDPackage.CrosshairRight = <span class="literal">nullptr</span>;</span><br><span class="line">HUDPackage.CrosshairTop = <span class="literal">nullptr</span>;</span><br><span class="line">HUDPackage.CrosshairBottom = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">FVector2D <span class="title">WalkSpeedRange</span><span class="params">(<span class="number">0.f</span>, Character-&gt;GetCharacterMovement()-&gt;MaxWalkSpeed)</span></span>;</span><br><span class="line"><span class="function">FVector2d <span class="title">VelocityMultiplierRange</span><span class="params">(<span class="number">0.f</span>, <span class="number">1.f</span>)</span></span>;</span><br><span class="line">FVector Velocity = Character-&gt;<span class="built_in">GetVelocity</span>();</span><br><span class="line">Velocity.Z = <span class="number">0.f</span>;</span><br><span class="line">CrosshairVelocityFactor = FMath::<span class="built_in">GetMappedRangeValueClamped</span>(WalkSpeedRange, VelocityMultiplierRange, Velocity.<span class="built_in">Size</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Character-&gt;<span class="built_in">GetCharacterMovement</span>()-&gt;<span class="built_in">IsFalling</span>()) &#123;</span><br><span class="line">CrosshairInAirFactor = FMath::<span class="built_in">FInterpTo</span>(CrosshairInAirFactor, <span class="number">2.25f</span>, DeltaTime, <span class="number">2.25f</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">CrosshairInAirFactor= FMath::<span class="built_in">FInterpTo</span>(CrosshairInAirFactor, <span class="number">0.f</span>, DeltaTime, <span class="number">30.f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bAiming) &#123;</span><br><span class="line">CrosshairAimFactor = FMath::<span class="built_in">FInterpTo</span>(CrosshairAimFactor, <span class="number">0.58f</span>, DeltaTime, <span class="number">30.f</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">CrosshairAimFactor = FMath::<span class="built_in">FInterpTo</span>(CrosshairAimFactor, <span class="number">0.f</span>, DeltaTime, <span class="number">30.f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CrosshairShootingFactor = FMath::<span class="built_in">FInterpTo</span>(CrosshairShootingFactor, <span class="number">0.f</span>, DeltaTime, <span class="number">40.f</span>);</span><br><span class="line"></span><br><span class="line">HUDPackage.CrosshairSpread = <span class="number">0.5f</span> + CrosshairVelocityFactor + CrosshairInAirFactor - CrosshairAimFactor + CrosshairShootingFactor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HUD-&gt;<span class="built_in">SetHUDPackage</span>(HUDPackage);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSHUD</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSHUD::DrawHUD</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">DrawHUD</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> SpreadScaled = CrosshairSpreadMax * HUDPackage.CrosshairSpread;</span><br><span class="line"></span><br><span class="line">FVector2D ViewportSize;</span><br><span class="line"><span class="keyword">if</span> (GEngine) &#123;</span><br><span class="line">GEngine-&gt;GameViewport-&gt;<span class="built_in">GetViewportSize</span>(ViewportSize);</span><br><span class="line"><span class="function"><span class="type">const</span> FVector2D <span class="title">ViewportCenter</span><span class="params">(ViewportSize.X / <span class="number">2.f</span>, ViewportSize.Y / <span class="number">2.f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (HUDPackage.CrosshairCenter) &#123;</span><br><span class="line"><span class="function">FVector2D <span class="title">Spread</span><span class="params">(<span class="number">0.f</span>, <span class="number">0.f</span>)</span></span>;</span><br><span class="line"><span class="built_in">DrawCrosshair</span>(HUDPackage.CrosshairCenter, ViewportCenter, Spread, HUDPackage.CrosshairColor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (HUDPackage.CrosshairLeft) &#123;</span><br><span class="line"><span class="function">FVector2D <span class="title">Spread</span><span class="params">(-SpreadScaled, <span class="number">0.f</span>)</span></span>;</span><br><span class="line"><span class="built_in">DrawCrosshair</span>(HUDPackage.CrosshairLeft, ViewportCenter, Spread, HUDPackage.CrosshairColor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (HUDPackage.CrosshairRight) &#123;</span><br><span class="line"><span class="function">FVector2D <span class="title">Spread</span><span class="params">(SpreadScaled, <span class="number">0.f</span>)</span></span>;</span><br><span class="line"><span class="built_in">DrawCrosshair</span>(HUDPackage.CrosshairRight, ViewportCenter, Spread, HUDPackage.CrosshairColor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (HUDPackage.CrosshairTop) &#123;</span><br><span class="line"><span class="function">FVector2D <span class="title">Spread</span><span class="params">(<span class="number">0.f</span>, -SpreadScaled)</span></span>;</span><br><span class="line"><span class="built_in">DrawCrosshair</span>(HUDPackage.CrosshairTop, ViewportCenter, Spread, HUDPackage.CrosshairColor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (HUDPackage.CrosshairBottom) &#123;</span><br><span class="line"><span class="function">FVector2D <span class="title">Spread</span><span class="params">(<span class="number">0.f</span>, SpreadScaled)</span></span>;</span><br><span class="line"><span class="built_in">DrawCrosshair</span>(HUDPackage.CrosshairBottom, ViewportCenter, Spread, HUDPackage.CrosshairColor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当准星瞄准特定的对象时应该改变颜色。这里的特定对象不仅包含敌人，也可能包含场景中的可破坏道具等，所以不能简单地将瞄准的对象进行转换来实现。这里的实现方式是<strong>接口</strong>。</p><p>面向对象编程的一个核心思想是<strong>数据抽象</strong>，而接口的思想与这有些相似，我称之为<strong>功能抽象</strong>：它允许一些彼此可能类似也可能完全不同的对象去执行名称相同、概念相似的操作。例如门、开关和冰箱，它们是不同的对象，但都可以执行“开”这个动作，尽管动作的内部逻辑并不相同。</p><p>创建接口类后，如果想要使用接口，需要保证使用接口的类继承这个接口类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MULTIPLAYERTPS_API</span> AMultiplayerTPSCharacter : <span class="keyword">public</span> ACharacter, <span class="keyword">public</span> IInteractWithCrosshairsInterface</span><br></pre></td></tr></table></figure><p>这里使用的只是接口的一个小功能。我们可以通过<code>Implements&lt;UInteractWithCrosshairsInterface&gt;()</code>函数来判断一个类有没有实现特定的接口，如果瞄准的对象实现了这个接口，就设置准星的颜色为红色，否则为白色：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (TraceHitResult.<span class="built_in">GetActor</span>() &amp;&amp; TraceHitResult.<span class="built_in">GetActor</span>()-&gt;<span class="built_in">Implements</span>&lt;UInteractWithCrosshairsInterface&gt;()) &#123;</span><br><span class="line">HUDPackage.CrosshairColor = FLinearColor::Red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">HUDPackage.CrosshairColor = FLinearColor::White;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个小细节。在 UE 中，接口由两部分组成：</p><ul><li><code>U</code> 开头的类（如 <code>UInteractWithCrosshairsInterface</code>）：继承自 <code>UInterface</code>，用于反射系统识别接口类型，支持蓝图调用与类型检查。</li><li><code>I</code> 开头的类（如 <code>IInteractWithCrosshairsInterface</code>）：纯 C++ 接口，包含你要实现的函数声明。</li></ul><p>在继承接口类时，继承的是<code>IInteractWithCrosshairsInterface</code>，而在检测对象是否实现了接口时使用的是<code>UInteractWithCrosshairsInterface</code>。<em>**</em></p><h3 id="3-11-受击"><a href="#3-11-受击" class="headerlink" title="3.11 受击"></a>3.11 受击</h3><p>和开火时一样，受击动画也要通过多播RPC进行同步。不同的时，受击只会在服务器上发生，所以不需要在客户端调用<code>Server RPC</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSCharacter.h</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PlayHitReactMontage</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">UFUNCTION</span>(NetMulticast, Unreliable)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MulticastHit</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerTPSCharacter.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::PlayHitReactMontage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!Combat || !Combat-&gt;EquippedWeapon) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UAnimInstance* AnimInstance = <span class="built_in">GetMesh</span>()-&gt;<span class="built_in">GetAnimInstance</span>();</span><br><span class="line"><span class="keyword">if</span> (AnimInstance &amp;&amp; HitReactMontage) &#123;</span><br><span class="line">AnimInstance-&gt;<span class="built_in">Montage_Play</span>(HitReactMontage);</span><br><span class="line"><span class="function">FName <span class="title">SectionName</span><span class="params">(<span class="string">&quot;FromFront&quot;</span>)</span></span>;</span><br><span class="line">AnimInstance-&gt;<span class="built_in">Montage_JumpToSection</span>(SectionName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::MulticastHit_Implementation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">PlayHitReactMontage</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当子弹碰到角色时调用多播RPC：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Projectile.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AProjectile::OnHit</span><span class="params">(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, <span class="type">const</span> FHitResult&amp; Hit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">AMultiplayerTPSCharacter* MultiplayerTPSCharacter = <span class="built_in">Cast</span>&lt;AMultiplayerTPSCharacter&gt;(OtherActor);</span><br><span class="line"><span class="keyword">if</span> (MultiplayerTPSCharacter) &#123;</span><br><span class="line">MultiplayerTPSCharacter-&gt;<span class="built_in">MulticastHit</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Destroy</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了使子弹能精确击中敌人的网格体而不是胶囊，这里添加了一个检测碰撞通道，并将Projectile对这个通道的碰撞设为<code>Block</code>。为了使用能够理解的名字而不是“第一个通道”，添加了一个宏。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ECC_SkeletalMesh ECollisionChannel::ECC_GameTraceChannel1</span></span><br><span class="line"></span><br><span class="line">CollisionBox-&gt;<span class="built_in">SetCollisionResponseToChannel</span>(ECC_SkeletalMesh, ECollisionResponse::ECR_Block);</span><br></pre></td></tr></table></figure><p>将角色的骨骼网格体的碰撞通道设为自定义的通道即可。</p><h3 id="3-12-自动开火"><a href="#3-12-自动开火" class="headerlink" title="3.12 自动开火"></a>3.12 自动开火</h3><p>对于可以自动开火的武器，当一次射击完成，到达开火间隔后如果仍然按着开火键，应该自动进行下一次开火。可以通过计时器完成这个操作。</p><p>在战斗组件中声明计时器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CombatComponent.h</span></span><br><span class="line">FTimerHandle FireTimer;</span><br><span class="line"><span class="type">bool</span> bCanFire = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StartFireTimer</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FireTimerFinished</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>当开火时启动计时器，同时将<code>bCanFire</code>设为false，计时结束后重写将<code>bCanFire</code>设为true，同时如果是自动武器并且仍然按着开火键，就继续射击。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CombatComponent.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::FireButtonPressed</span><span class="params">(<span class="type">bool</span> bPressed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">bFireButtonPressed = bPressed;</span><br><span class="line"><span class="keyword">if</span> (bFireButtonPressed) &#123;</span><br><span class="line"><span class="keyword">if</span> (EquippedWeapon) &#123;</span><br><span class="line"><span class="built_in">Fire</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::Fire</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bCanFire) &#123;</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;Fire!&quot;</span>));</span><br><span class="line">bCanFire = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">ServerFire</span>(HitTarget);</span><br><span class="line"><span class="keyword">if</span> (EquippedWeapon) &#123;</span><br><span class="line">CrosshairShootingFactor = <span class="number">0.8f</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">StartFireTimer</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">计时结束后重写将bCanFire设为<span class="literal">true</span>，同时如果是自动武器并且仍然按着开火键，就继续射击。</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::StartFireTimer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!EquippedWeapon || !Character) <span class="keyword">return</span>;</span><br><span class="line">Character-&gt;<span class="built_in">GetWorldTimerManager</span>().<span class="built_in">SetTimer</span>(</span><br><span class="line">FireTimer,</span><br><span class="line"><span class="keyword">this</span>,</span><br><span class="line">&amp;UCombatComponent::FireTimerFinished,</span><br><span class="line">EquippedWeapon-&gt;FireDelay</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::FireTimerFinished</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!EquippedWeapon) <span class="keyword">return</span>;</span><br><span class="line">bCanFire = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (bFireButtonPressed &amp;&amp; EquippedWeapon-&gt;bAutomatic) &#123;</span><br><span class="line"><span class="built_in">Fire</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-13-优化"><a href="#3-13-优化" class="headerlink" title="3.13 优化"></a>3.13 优化</h3><p>当瞄准的对象从远处的对象突然到近处的对象时，枪口会有瞬移的效果，所以在枪口移动时需要做一个插值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (MultiplayerTPSCharacter-&gt;<span class="built_in">IsLocallyControlled</span>()) &#123;</span><br><span class="line">bLocallyControlled = <span class="literal">true</span>;</span><br><span class="line">FTransform RightHnadTransform = EquippedWeapon-&gt;<span class="built_in">GetWeaponMesh</span>()-&gt;<span class="built_in">GetSocketTransform</span>(<span class="built_in">FName</span>(<span class="string">&quot;hand_r&quot;</span>), ERelativeTransformSpace::RTS_World);</span><br><span class="line">FRotator LookAtRotation = UKismetMathLibrary::<span class="built_in">FindLookAtRotation</span>(RightHnadTransform.<span class="built_in">GetLocation</span>(), RightHnadTransform.<span class="built_in">GetLocation</span>() + (RightHnadTransform.<span class="built_in">GetLocation</span>() - MultiplayerTPSCharacter-&gt;<span class="built_in">GetHitTarget</span>()));</span><br><span class="line">RightHandRotation = FMath::<span class="built_in">RInterpTo</span>(RightHandRotation, LookAtRotation, DeltaTime, <span class="number">30.f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当摄像机被墙挡住时会拉近和角色之间的距离，此时准星可能会对准角色身后的角色甚至自己，导致武器指向身后并且准星对准自己的时候会变红。解决方法是在射线检测时将起点移到角色前面：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FVector Start = CrosshairWorldPosition;</span><br><span class="line"><span class="keyword">if</span> (Character) &#123;</span><br><span class="line"><span class="type">float</span> DistanceToCharacter = (Character-&gt;<span class="built_in">GetActorLocation</span>() - Start).<span class="built_in">Size</span>();</span><br><span class="line">Start += CrosshairWorldDirection * (DistanceToCharacter + <span class="number">100.f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当摄像机撞墙时可能视野会被角色完全遮挡，此时需要隐藏角色：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line"><span class="type">float</span> CameraThreshold = <span class="number">200.f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在Tick中调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMultiplayerTPSCharacter::HideCameraIfCharacterClose</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">IsLocallyControlled</span>()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((FollowCamera-&gt;<span class="built_in">GetComponentLocation</span>() - <span class="built_in">GetActorLocation</span>()).<span class="built_in">Size</span>() &lt; CameraThreshold) &#123;</span><br><span class="line"><span class="built_in">GetMesh</span>()-&gt;<span class="built_in">SetVisibility</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (Combat &amp;&amp; Combat-&gt;EquippedWeapon &amp;&amp; Combat-&gt;EquippedWeapon-&gt;<span class="built_in">GetWeaponMesh</span>()) &#123;</span><br><span class="line">Combat-&gt;EquippedWeapon-&gt;<span class="built_in">GetWeaponMesh</span>()-&gt;bOwnerNoSee = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">GetMesh</span>()-&gt;<span class="built_in">SetVisibility</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">if</span> (Combat &amp;&amp; Combat-&gt;EquippedWeapon &amp;&amp; Combat-&gt;EquippedWeapon-&gt;<span class="built_in">GetWeaponMesh</span>()) &#123;</span><br><span class="line">Combat-&gt;EquippedWeapon-&gt;<span class="built_in">GetWeaponMesh</span>()-&gt;bOwnerNoSee = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【UE5】多人联机TPS游戏开发（一） ——  制作联机插件</title>
      <link href="/undefined/f18ea7eb.html"/>
      <url>/undefined/f18ea7eb.html</url>
      
        <content type="html"><![CDATA[<h1 id="【UE5】多人联机TPS游戏开发（一）-——-制作联机插件"><a href="#【UE5】多人联机TPS游戏开发（一）-——-制作联机插件" class="headerlink" title="【UE5】多人联机TPS游戏开发（一） ——  制作联机插件"></a>【UE5】多人联机TPS游戏开发（一） ——  制作联机插件</h1><blockquote><p>前言：</p><p>本来准备继续深入学习GAS系统的，但是被学院弄去实训一个月后对前面学的东西有点陌生了，而且到7月还没找到实习，准备直接秋招了，所以想先把网络相关的内容学起来。</p><p>网络部分是我在之前的学习中完全没有接触过的内容，当看到两个角色出现在一张地图中并且可以进行互动的时候感觉还是挺有意思的。当然这个项目中使用的方法比较有局限性，但是从中学习到的一些理念和框架也足够我初步了解并动手实现网络联机了。</p><p>又是一段艰难的旅程，但是也没办法，谁让我就是头铁要走这条路呢~</p></blockquote><h2 id="1-联机基础"><a href="#1-联机基础" class="headerlink" title="1.联机基础"></a>1.联机基础</h2><p>联机游戏的本质，是<strong>在多台设备上运行的多个游戏实例之间建立状态同步</strong>。为了保证所有玩家在同一个“游戏世界”中实时互动，这些实例必须通过网络通信同步位置、输入、事件等关键数据。联机的方式大概可以分为两类：<strong><code>Peer-to-Peer(P2P)</code></strong>和<strong><code>Client-Server(CS)</code></strong>。</p><p>在<code>P2P</code>架构中，所有玩家都需要时刻向其他所有玩家发送自己的信息，而发送信息的数量会随着玩家数量的增加而快速增长，因此这是一种<strong>简单但局限性极大</strong>的方式。</p><p><code>Client-Server</code>架构则是存在一个服务器，所有玩家只需要和服务器进行通信，服务器会接收所有玩家的信息，并向所有玩家同步这些信息。<code>CS</code>架构又可以分为两类：<strong><code>Listen-Server</code>（监听服务器）</strong>，一台玩家主机既运行游戏客户端，也承担服务器角色。主机上的逻辑会被当作权威状态，服务器会把必要的状态（位置、事件等）同步到连接的客户端。这种方法使用于网络传输需求较小的游戏。个人猜测<code>Warframe</code>就是使用了这种方式；<strong><code>Dedicated-Server</code>（专用服务器）</strong>，有一个专门的服务器负责接收请求并发送数据，通常用于对网络要求较高的游戏，如大型MMO、战术射击游戏等。</p><p>本项目使用的是收听服务器的方式进行联机。在实现联机功能时，一个主要挑战是<strong>如何对接各个平台（Steam、Epic、Xbox、PS 等）的底层 API</strong>。每个平台的网络服务机制不同，实现方式也不统一。为了解决这个问题，Unreal 提供了一个跨平台的抽象层 —— <strong><code>OnlineSubsystem</code>（简称 OSS）</strong>。OSS 为开发者屏蔽了平台差异，使我们可以使用统一的接口来实现会话创建、玩家身份识别、好友系统等功能。</p><p>本项目使用的是 OSS 中的 <strong><code>OnlineSubsystemSteam</code>插件</strong>，通过 Steam 提供的 API 实现跨局域网的联机功能。</p><h3 id="1-1-测试局域网联机"><a href="#1-1-测试局域网联机" class="headerlink" title="1.1 测试局域网联机"></a>1.1 测试局域网联机</h3><p>首先进行联机功能的第一步，也是最简单的一步：实现局域网联机。</p><p>创建一个第三人称项目，并创建一个名为“Lobby”的关卡。在角色蓝图中实现以下功能：</p><p><img src="/undefined/f18ea7eb/image-20250704221601626.png" alt="image-20250704221601626"></p><p>打包项目，并将其拷贝到客机。客机需要和主机连接到同一局域网。</p><p>在主机按下“1”后，主机会加载关卡“Lobby”，Options中的“listen”表明要以<strong>监听服务器</strong>身份运行，它会打开 socket 接口等待其他玩家连接。随后在客机按下”2“，游戏会执行命令“Open 121.48.198.53”，客户端尝试通过 socket 连接到该地址运行的 listen server。如果目标IP是监听服务器，它会接受连接，并将客户端加载到正确的地图中。</p><p>完成上面的操作后，就可以看到两台电脑的角色在一起活蹦乱跳了。</p><p><img src="/undefined/f18ea7eb/image-20250704222653264.png" alt="image-20250704222653264"></p><h3 id="1-2-使用代码实现局域网联机"><a href="#1-2-使用代码实现局域网联机" class="headerlink" title="1.2 使用代码实现局域网联机"></a>1.2 使用代码实现局域网联机</h3><p>逻辑很简单，直接贴代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTestingCharacter::OpenLobby</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">UWorld* world = <span class="built_in">GetWorld</span>();</span><br><span class="line"><span class="keyword">if</span> (world) &#123;</span><br><span class="line">world-&gt;<span class="built_in">ServerTravel</span>(<span class="string">&quot;/Game/ThirdPerson/Maps/Lobby?Listen&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTestingCharacter::CallOpenLevel</span><span class="params">(<span class="type">const</span> FString&amp; Address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">UGameplayStatics::<span class="built_in">OpenLevel</span>(<span class="keyword">this</span>, *Address);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMPTestingCharacter::CallClientTravel</span><span class="params">(<span class="type">const</span> FString&amp; Address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">APlayerController* playerController = <span class="built_in">GetGameInstance</span>()-&gt;<span class="built_in">GetFirstLocalPlayerController</span>();</span><br><span class="line"><span class="keyword">if</span> (playerController) &#123;</span><br><span class="line">playerController-&gt;<span class="built_in">ClientTravel</span>(Address, ETravelType::TRAVEL_Absolute);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑和上一小节基本上是一样的，只不过多了一种用于连接主机的方法。用相同的方式进行测试。</p><p><img src="/undefined/f18ea7eb/image-20250704222414649.png" alt="image-20250704222414649"></p><p>联机成功。</p><p><img src="/undefined/f18ea7eb/image-20250704222825472.png" alt="image-20250704222825472"></p><p>目前我们实现了最基础的局域网联机。使用 UE 提供的 <code>ServerTravel</code> 和 <code>ClientTravel</code> 方法，我们可以让一台设备以 listen server 的身份运行，并允许其他局域网内的设备通过 IP 地址连接进来。虽然方式简单直接，但依赖于网络环境，难以在公网环境中稳定使用。为了解决这一问题，我们将在下一节引入 UE 的 <code>OnlineSubsystem</code>模块，并通过 Steam 实现跨网段联机。</p><h2 id="2-测试通过Steam进行联机"><a href="#2-测试通过Steam进行联机" class="headerlink" title="2 测试通过Steam进行联机"></a>2 测试通过Steam进行联机</h2><p><strong>在线子系统（Online Subsystem）</strong> 及其接口提供一种可访问<code>Steam</code>、<code>Xbox Live</code>、<code>Facebook</code>等在线服务功能的常用方法。开发一款在多平台上发行或支持多在线服务的游戏时，在线子系统可确保开发者唯一需要做的变更就是对所有支持的服务进行配置调整。UE引擎提供了一系列针对不同平台的Online Subsystem插件，而本项目中使用的就是针对Steam平台的插件，它提供了底层 <code>SteamNetDriver</code>、<code>SteamSession</code>、<code>SteamAPI</code>调用封装等模块。</p><p><a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/online-subsystem-in-unreal-engine?application_version=5.5">Online Subsystem in Unreal Engine | 虚幻引擎 5.5 文档 | Epic Developer Community</a></p><p><a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/online-subsystem-steam-interface-in-unreal-engine?application_version=5.5">虚幻引擎Steam在线子系统接口 | 虚幻引擎 5.5 文档 | Epic Developer Community</a></p><p>详细的使用方法可以参照官方文档。</p><h3 id="2-1-配置"><a href="#2-1-配置" class="headerlink" title="2.1 配置"></a>2.1 配置</h3><p>创建新的项目后，我们需要开启这个插件：</p><p><img src="/undefined/f18ea7eb/image-20250704223838193.png" alt="image-20250704223838193"></p><p>并且在配置文件(Config/DefaultEngine.INI)中添加以下内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[/Script/Engine.GameEngine]</span></span><br><span class="line">+<span class="attr">NetDriverDefinitions</span>=(DefName=<span class="string">&quot;GameNetDriver&quot;</span>,DriverClassName=<span class="string">&quot;OnlineSubsystemSteam.SteamNetDriver&quot;</span>,DriverClassNameFallback=<span class="string">&quot;OnlineSubsystemUtils.IpNetDriver&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">[OnlineSubsystem]</span></span><br><span class="line"><span class="attr">DefaultPlatformService</span>=Steam</span><br><span class="line"></span><br><span class="line"><span class="section">[OnlineSubsystemSteam]</span></span><br><span class="line"><span class="attr">bEnabled</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">SteamDevAppId</span>=<span class="number">480</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; If using Sessions</span></span><br><span class="line"><span class="comment">; bInitServerOnClient=true</span></span><br><span class="line"></span><br><span class="line"><span class="section">[/Script/OnlineSubsystemSteam.SteamNetDriver]</span></span><br><span class="line"><span class="attr">NetConnectionClassName</span>=<span class="string">&quot;OnlineSubsystemSteam.SteamNetConnection&quot;</span></span><br></pre></td></tr></table></figure><p>这么做是为了告诉 UE：”默认的联机服务平台是 Steam。“<code>SteamDevAppId=480</code> 是 Valve 提供的<strong>开发专用测试 ID（SpaceWar）</strong>，允许不通过 Steam 发布就进行测试联机。<code>bEnabled=true</code> 是显式启用插件。</p><p>我们还需要手动在构建文件<code>MenuSystem.Build.cs</code>中添加模块依赖：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MenuSystem</span> : ModuleRules</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MenuSystem</span><span class="params">(ReadOnlyTargetRules Target)</span> : base(Target)</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line">PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;</span><br><span class="line"></span><br><span class="line">PublicDependencyModuleNames.<span class="built_in">AddRange</span>(<span class="keyword">new</span> string[] &#123; ...（原有模块）, <span class="string">&quot;OnlineSubsystemSteam&quot;</span>, <span class="string">&quot;OnlineSubsystem&quot;</span> &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UE 构建系统依赖这些模块标记来将插件静态链接进你的项目。OSS 是跨模块插件，不声明无法访问接口。</p><p>最后重新构建项目，就完成了配置。</p><h3 id="2-2-获取会话接口"><a href="#2-2-获取会话接口" class="headerlink" title="2.2 获取会话接口"></a>2.2 获取会话接口</h3><p>因为现在要做的是测试Steam的联机功能，所以就不新建一个类了，而是直接在角色类中实现。</p><p>要通过在线子系统实现联机，我们首先要做的就是<strong>访问在线子系统并获取Session接口</strong>。这是后续实现 <strong>创建/查找/加入会话</strong>（Session）功能的基础。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MenuSystemCharacter.h</span></span><br><span class="line">IOnlineSessionPtr OnlineSessionInterface; </span><br><span class="line"></span><br><span class="line"><span class="comment">//MenuSystemCharacter.cpp</span></span><br><span class="line">AMenuSystemCharacter::<span class="built_in">AMenuSystemCharacter</span>() :</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 构造函数的其它逻辑</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">IOnlineSubsystem* OnlineSubsystem = IOnlineSubsystem::<span class="built_in">Get</span>();</span><br><span class="line"><span class="keyword">if</span> (OnlineSubsystem) &#123;</span><br><span class="line">OnlineSessionInterface = OnlineSubsystem-&gt;<span class="built_in">GetSessionInterface</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (GEngine) &#123;</span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(</span><br><span class="line"><span class="number">-1</span>,</span><br><span class="line"><span class="number">15.f</span>,</span><br><span class="line">FColor::Blue,</span><br><span class="line">FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Found subsystem %s&quot;</span>), *OnlineSubsystem-&gt;<span class="built_in">GetSubsystemName</span>().<span class="built_in">ToString</span>())</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先声明了一个<code>IOnlineSessionPtr</code>成员变量，这个变量本质上是一个<code>IOnlineSessiion</code>类的共享指针，并保证了线程安全。在构造函数中，我们通过<code>IOnlineSubsystem::Get()</code>方法获取到了当前激活的在线子系统。这里的 <code>Get()</code> 是一个 <strong>静态方法</strong>，它是通过名称条件，查找已经进行注册/创建的实例。<strong>各个平台注册自己的子系统，然后让用户通过 <code>Get()</code> 全局访问。</strong></p><p>获取成功后，我们就可以通过在线子系统为<code>OnlineSessionInterface</code>进行赋值，从而获得了会话模块的接口（下文简称<strong>会话接口</strong>）。通过会话接口，我们就可以进行接下来的创建、查找、加入会话等工作。</p><p>获得接口后，我们可以将其名称打印在屏幕上，来观察是否成功获取了Steam子系统。</p><p>注意，这里要打包项目后运行打包好的项目才能观察到正确的结果。因为编辑器里不会启用 Steam OSS，打包后才会真正加载 Steam 子系统。</p><p><img src="/undefined/f18ea7eb/image-20250704230838975.png" alt="image-20250704230838975"></p><h3 id="2-3-创建会话"><a href="#2-3-创建会话" class="headerlink" title="2.3 创建会话"></a>2.3 创建会话</h3><p>获得了会话接口后，就可以用其提供的各种方法进行对话的创建、寻找、加入、销毁等操作，从而实现联机。首先从创建会话开始。</p><p>创建会话的流程包含三个步骤：</p><ul><li><p>绑定创建会话委托（用于接收异步回调）</p></li><li><p>构造会话设置对象（设置连接数、匹配类型等）</p></li><li><p>调用在线子系统接口创建会话（异步操作）</p></li></ul><p>我声明了一个创建会话的接口函数和一个<strong>回调函数</strong>，以及一个<strong>委托</strong>。简单来说，委托可以绑定一个（或多个，根据委托的类型来决定）回调函数，我们可以对委托进行（手动或自动）广播，这样所有和这个委托绑定的回调函数都会被调用。委托是实现异步通信的一个常用方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateGameSession</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Delegate fired when a session create request has completed</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @param SessionName the name of the session this callback is for</span></span><br><span class="line"><span class="comment">* @param bWasSuccessful true if the async action completed without error, false if there was an error</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnCreateSessionComplete</span><span class="params">(FName SessionName, <span class="type">bool</span> bWasSuccessful)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">FOnCreateSessionCompleteDelegate CreateSessionCompleteDelegate;</span><br></pre></td></tr></table></figure><p>UE 的 OSS 就是一个<strong>异步系统</strong>，创建 Session 不会立刻完成，必须用回调函数处理结果。<code>FOnCreateSessionCompleteDelegate</code> 是一个专门用于监听创建结果的事件类型。</p><p>我们可以直接在构造函数的初始化列表中将委托与回调函数进行绑定：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CreateSessionCompleteDelegate</span>(FOnCreateSessionCompleteDelegate::<span class="built_in">CreateUObject</span>(<span class="keyword">this</span>, &amp;ThisClass::OnCreateSessionComplete))</span><br></pre></td></tr></table></figure><p>接下来就是创建会话了。在<code>CreateGameSession</code>函数实现以下逻辑：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMenuSystemCharacter::CreateGameSession</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//按“1”调用函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//检查指针是否有效</span></span><br><span class="line"><span class="keyword">if</span> (!OnlineSessionInterface.<span class="built_in">IsValid</span>()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查当前是否存在会话，如果有，将其销毁</span></span><br><span class="line"><span class="keyword">auto</span> ExistingSession = OnlineSessionInterface-&gt;<span class="built_in">GetNamedSession</span>(NAME_GameSession);</span><br><span class="line"><span class="keyword">if</span> (ExistingSession) &#123;</span><br><span class="line">OnlineSessionInterface-&gt;<span class="built_in">DestroySession</span>(NAME_GameSession);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将委托添加到列表，进行会话设置，创建会话</span></span><br><span class="line">OnlineSessionInterface-&gt;<span class="built_in">AddOnCreateSessionCompleteDelegate_Handle</span>(CreateSessionCompleteDelegate);</span><br><span class="line"></span><br><span class="line">TSharedPtr&lt;FOnlineSessionSettings&gt; SessionSettings = <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FOnlineSessionSettings</span>());</span><br><span class="line">SessionSettings-&gt;bIsLANMatch = <span class="literal">false</span>; <span class="comment">//是否为局域网匹配</span></span><br><span class="line">SessionSettings-&gt;NumPublicConnections = <span class="number">4</span>; <span class="comment">//最大联机数量</span></span><br><span class="line">SessionSettings-&gt;bAllowJoinInProgress = <span class="literal">true</span>; <span class="comment">//是否允许中途加入</span></span><br><span class="line">SessionSettings-&gt;bAllowJoinViaPresence = <span class="literal">true</span>; <span class="comment">//是否允许通过 Steam 好友加入</span></span><br><span class="line">SessionSettings-&gt;bShouldAdvertise = <span class="literal">true</span>; <span class="comment">//是否将房间暴露出去</span></span><br><span class="line">SessionSettings-&gt;bUsesPresence = <span class="literal">true</span>; <span class="comment">//是否使用“在线状态系统”</span></span><br><span class="line">SessionSettings-&gt;bUseLobbiesIfAvailable = <span class="literal">true</span>; <span class="comment">//是否使用 Steam Lobby 功能</span></span><br><span class="line">SessionSettings-&gt;<span class="built_in">Set</span>(<span class="built_in">FName</span>(<span class="string">&quot;MatchType&quot;</span>), <span class="built_in">FString</span>(<span class="string">&quot;FreeForAll&quot;</span>), EOnlineDataAdvertisementType::ViaOnlineServiceAndPing);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ULocalPlayer* localPlayer = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetFirstLocalPlayerFromController</span>();</span><br><span class="line">OnlineSessionInterface-&gt;<span class="built_in">CreateSession</span>(*localPlayer-&gt;<span class="built_in">GetPreferredUniqueNetId</span>(), NAME_GameSession, *SessionSettings);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前已经存在会话，我们需要将其销毁。然后将我们声明的委托添加到列表中。这是OSS提供的方法，当使用OSS的接口创建会话后，它就会对列表中的所有委托进行广播，进而调用与委托绑定的函数。下面通过共享指针定义了一个会话设置，里面定义了一些要创建的会话的信息。在我使用的版本(UE5.5)需要设置<code>bUseLobbiesIfAvailable = true</code>才能进行正常联机。最后就是创建会话了。UE 的 Session 创建需要提供唯一身份 ID，<code>localPlayer-&gt;GetPreferredUniqueNetId()</code> 就是当前 Steam 登录用户的标识，需要通过获得当前的玩家去获得身份ID。</p><blockquote><p>为什么在创建会话设置的对象时，要在堆上创建并使用共享指针进行管理，而不是创建一个临时变量？</p><p><code>Unreal</code>的会话接口（如 <code>CreateSession</code>）是<strong>异步操作</strong>，也就是说函数返回后，实际的会话创建过程仍在后台执行，直到系统触发对应的回调函数。如果我们使用的是函数内的局部变量，那么在函数结束时，该对象会自动析构。而此时后台异步操作还未完成，它若尝试访问这个已销毁的对象，就会产生<strong>未定义行为</strong>，导致程序崩溃。如果改为值传递，虽然避免了悬空指针的问题，但这会引入一次<strong>不必要的深拷贝开销</strong>。因此，更推荐的做法是使用 <code>TSharedPtr</code>，通过 <code>MakeShareable(new ...)</code> 将 <code>SessionSettings</code> 分配到堆上，主动管理生命周期，即使函数返回，内部的引用计数仍保持为 1（或以上），直到异步流程完成后系统再销毁该对象。这样既避免了复制，也保证了稳定性。</p><p>之后有很多功能都会用到这个操作，思想大概都是这样。</p></blockquote><p>回调函数的逻辑很简单，当创建会话完成后触发<code>CreateSessionCompleteDelegate</code>委托的广播，自动调用创建会话的回调函数。如果传入的值为<code>true</code>，说明创建成功，传送到大厅并设为监听服务器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMenuSystemCharacter::OnCreateSessionComplete</span><span class="params">(FName SessionName, <span class="type">bool</span> bWasSussful)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bWasSussful) &#123;</span><br><span class="line"><span class="keyword">if</span> (GEngine) &#123;</span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(</span><br><span class="line"><span class="number">-1</span>,</span><br><span class="line"><span class="number">15.f</span>,</span><br><span class="line">FColor::Blue,</span><br><span class="line">FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Created session: %s&quot;</span>),*SessionName.<span class="built_in">ToString</span>())</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UWorld* world = <span class="built_in">GetWorld</span>();</span><br><span class="line"><span class="keyword">if</span> (world) &#123;</span><br><span class="line">world-&gt;<span class="built_in">ServerTravel</span>(<span class="built_in">FString</span>(<span class="string">&quot;/Game/ThirdPerson/Maps/Lobby?listen&quot;</span>)); <span class="comment">//打开大厅地图并设为服务器</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (GEngine) &#123;</span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(</span><br><span class="line"><span class="number">-1</span>,</span><br><span class="line"><span class="number">15.f</span>,</span><br><span class="line">FColor::Red,</span><br><span class="line"><span class="built_in">FString</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Failed to create session!&quot;</span>))</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-加入会话"><a href="#2-4-加入会话" class="headerlink" title="2.4 加入会话"></a>2.4 加入会话</h3><p>实现创建会话后，顺理成章的就要开始实现加入会话了。和创建会话时相同，声明加入会话的函数和两个回调函数，以及两个相应的委托，分别用于发现会话和加入会话，并将委托和回调函数进行绑定。还声明了一个成员变量，用来存储搜索的条件和结果等（存疑）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//MenuSystemCharacter.h</span><br><span class="line">UFUNCTION(BlueprintCallable)</span><br><span class="line">void JoinGameSession();</span><br><span class="line"></span><br><span class="line">void OnFindSessionsComplete(bool bWasSuccessful);</span><br><span class="line">void OnJoinSessionComplete(FName SessionName, EOnJoinSessionCompleteResult::Type Result);</span><br><span class="line"></span><br><span class="line">FOnFindSessionsCompleteDelegate FindSessionsCompleteDelegate;</span><br><span class="line">FOnJoinSessionCompleteDelegate JoinSessionCompleteDelegate;</span><br><span class="line">TSharedPtr&lt;FOnlineSessionSearch&gt; SessionSearch;</span><br><span class="line"></span><br><span class="line">//MenuSystemCharacter.cpp</span><br><span class="line">//构造函数的初始化列表</span><br><span class="line">FindSessionsCompleteDelegate(FOnFindSessionsCompleteDelegate::CreateUObject(this, &amp;ThisClass::OnFindSessionsComplete)),</span><br><span class="line">JoinSessionCompleteDelegate(FOnJoinSessionCompleteDelegate::CreateUObject(this, &amp;ThisClass::OnJoinSessionComplete))</span><br></pre></td></tr></table></figure><p>将发现会话的委托添加到委托列表，创建一个寻找会话的条件，就可以开始寻找会话了。之后使用本地玩家的<code>NetID</code>向 OSS 发起搜索请求。<strong>此过程也是异步的</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMenuSystemCharacter::JoinGameSession</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!OnlineSessionInterface.<span class="built_in">IsValid</span>()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OnlineSessionInterface-&gt;<span class="built_in">AddOnFindSessionsCompleteDelegate_Handle</span>(FindSessionsCompleteDelegate);</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找会话</span></span><br><span class="line">SessionSearch = <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FOnlineSessionSearch</span>());</span><br><span class="line">SessionSearch-&gt;MaxSearchResults = <span class="number">10000</span>; <span class="comment">//最多查找多少个房间</span></span><br><span class="line">SessionSearch-&gt;bIsLanQuery = <span class="literal">false</span>; <span class="comment">//是否为局域网查找</span></span><br><span class="line">SessionSearch-&gt;QuerySettings.<span class="built_in">Set</span>(SEARCH_PRESENCE, <span class="literal">true</span>, EOnlineComparisonOp::Equals); <span class="comment">//查找支持好友加入/展示的房间</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ULocalPlayer* LocalPlayer = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetFirstLocalPlayerFromController</span>();</span><br><span class="line">OnlineSessionInterface-&gt;<span class="built_in">FindSessions</span>(*LocalPlayer-&gt;<span class="built_in">GetPreferredUniqueNetId</span>(), SessionSearch.<span class="built_in">ToSharedRef</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>寻找会话完成后，会调用寻找会话委托绑定的回调函数。在回调函数中，我们需要对寻找到的结果进行一些筛选。当找到符合要求的会话后，就需要加入这个会话了。将加入会话的委托加入委托列表，就可以通过NetID加入会话了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMenuSystemCharacter::OnFindSessionsComplete</span><span class="params">(<span class="type">bool</span> bWasSuccessful)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!OnlineSessionInterface.<span class="built_in">IsValid</span>()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> result : SessionSearch-&gt;SearchResults) &#123;</span><br><span class="line">FString Id = result.<span class="built_in">GetSessionIdStr</span>(); <span class="comment">//获得会话ID</span></span><br><span class="line">FString User = result.Session.OwningUserName; <span class="comment">//获得会话拥有者</span></span><br><span class="line">FString MatchType;</span><br><span class="line">result.Session.SessionSettings.<span class="built_in">Get</span>(<span class="built_in">FName</span>(<span class="string">&quot;MatchType&quot;</span>), MatchType); <span class="comment">//获取比赛类型</span></span><br><span class="line"><span class="keyword">if</span>(GEngine) &#123;</span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(</span><br><span class="line"><span class="number">-1</span>,</span><br><span class="line"><span class="number">15.f</span>,</span><br><span class="line">FColor::Cyan,</span><br><span class="line">FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Id: %s, User: %s&quot;</span>), *Id, *User)</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查比赛类型是否是FreeForAll</span></span><br><span class="line"><span class="keyword">if</span> (MatchType == <span class="built_in">FString</span>(<span class="string">&quot;FreeForAll&quot;</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (GEngine) &#123;</span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(</span><br><span class="line"><span class="number">-1</span>,</span><br><span class="line"><span class="number">15.f</span>,</span><br><span class="line">FColor::Cyan,</span><br><span class="line">FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Joing Match Type: %s&quot;</span>), *MatchType)</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OnlineSessionInterface-&gt;<span class="built_in">AddOnJoinSessionCompleteDelegate_Handle</span>(JoinSessionCompleteDelegate);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ULocalPlayer* localPlayer = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetFirstLocalPlayerFromController</span>();</span><br><span class="line">OnlineSessionInterface-&gt;<span class="built_in">JoinSession</span>(*localPlayer-&gt;<span class="built_in">GetPreferredUniqueNetId</span>(), NAME_GameSession, Result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加入会话后，会调用加入会话的回调函数。因为加入会话并不会将客户端自动传送至主机地图，在这里要使用<code>ClientTravel</code>方法将玩家传送到主机所在的地图。其中的地址是通过会话接口解析会话得到的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMenuSystemCharacter::OnJoinSessionComplete</span><span class="params">(FName SessionName, EOnJoinSessionCompleteResult::Type Result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!OnlineSessionInterface.<span class="built_in">IsValid</span>()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">FString Address;</span><br><span class="line"><span class="keyword">if</span> (OnlineSessionInterface-&gt;<span class="built_in">GetResolvedConnectString</span>(NAME_GameSession, Address)) &#123;</span><br><span class="line"><span class="keyword">if</span> (GEngine) &#123;</span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(</span><br><span class="line"><span class="number">-1</span>,</span><br><span class="line"><span class="number">15.f</span>,</span><br><span class="line">FColor::Yellow,</span><br><span class="line">FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Connext string: %s&quot;</span>), *Address)</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">APlayerController* PlayerController = <span class="built_in">GetGameInstance</span>()-&gt;<span class="built_in">GetFirstLocalPlayerController</span>();</span><br><span class="line"><span class="keyword">if</span> (PlayerController) &#123;</span><br><span class="line">PlayerController-&gt;<span class="built_in">ClientTravel</span>(Address, ETravelType::TRAVEL_Absolute);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(</span><br><span class="line"><span class="number">-1</span>,</span><br><span class="line"><span class="number">15.f</span>,</span><br><span class="line">FColor::Yellow,</span><br><span class="line">FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Address Not Find&quot;</span>))</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个简单的联机逻辑就这样实现了。里面有很多逻辑不够严密的地方，并且选项都是写死的，但是用作测试已经足够了。</p><p>在进行测试时，需要两台电脑，分别登录两个不同的Steam账号，并且下载地点设为同一个地方。启动游戏，一遍按<code>1</code>调用创建会话，另一边按<code>2</code>加入会话。成功！</p><h2 id="3-插件制作"><a href="#3-插件制作" class="headerlink" title="3.插件制作"></a>3.插件制作</h2><p>终于到了这篇文章的重点。我想制作一个插件，使得无论何时我想制作一个多人联机项目，只要安装制作好的插件就可以通过调用它的一些接口，轻松实现联机功能。</p><h3 id="3-1-配置"><a href="#3-1-配置" class="headerlink" title="3.1 配置"></a>3.1 配置</h3><p>创建一个空白插件。</p><p><img src="/undefined/f18ea7eb/image-20250706224649885.png" alt="image-20250706224649885"></p><p>我们需要声明这个插件需要依赖的插件。本插件依赖于官方插件<code>OnlineSubsystem</code>和<code>OnlineSubsystemSteam</code>，因此需要在插件的<code>.uplugin</code>文件中加上下面的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;Plugins&quot;: [</span><br><span class="line">&#123;</span><br><span class="line">&quot;Name&quot;: &quot;OnlineSubsystem&quot;,</span><br><span class="line">&quot;Enabled&quot;: true</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;Name&quot;: &quot;OnlineSubsystemSteam&quot;,</span><br><span class="line">&quot;Enabled&quot;: true</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>它告诉 UE 编译器 <strong>在启用本插件时自动启用这两个插件</strong>，避免了手动逐一勾选的麻烦。</p><p>并且在插件的构建文件中加上：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PublicDependencyModuleNames.AddRange(</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">string</span>[]</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;Core&quot;</span>,</span><br><span class="line"><span class="string">&quot;OnlineSubsystem&quot;</span>,</span><br><span class="line"><span class="string">&quot;OnlineSubsystemSteam&quot;</span></span><br><span class="line"><span class="comment">// ... add other public dependencies that you statically link with here ...</span></span><br><span class="line">&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这是告诉 <code>Unreal Build Tool（UBT）</code>：<strong>本插件在编译时需要链接 <code>OnlineSubsystem</code> 和 Steam 的 C++ 模块</strong>，否则在代码中引用 <code>IOnlineSession</code>、<code>FOnlineSessionSettings</code> 等类会编译失败。</p><h3 id="3-2-创建自己的类"><a href="#3-2-创建自己的类" class="headerlink" title="3.2 创建自己的类"></a>3.2 创建自己的类</h3><p><strong>这里我画了一个图，用于方便看懂插件中的四大部分之间是如何交互的</strong>。之后的所有内容都遵循这个流程，因为具体功能实现方式和上面其实差不多，所以只做简单讲解。</p><p><img src="/undefined/f18ea7eb/image-20250709232702573.png" alt="image-20250709232702573"></p><p>插件的实现主要依靠实现一个自己的类：<code>MultiplayerSessionsSubsystem</code>类，它继承自<strong>游戏实例子系统类</strong>(<code>UGameInstanceSubsystem</code>)。<code>UGameInstanceSubsystem</code> 是 Unreal Engine 提供的一种<strong>全局生命周期子系统</strong>，它在游戏启动后就存在，并<strong>贯穿整个游戏生命周期，不会因为关卡切换而销毁</strong>。<code>MultiplayerSessionsSubsystem</code>类是插件的核心，主要提供了一些对于会话的操作的接口以及相应操作的委托，只要使用这些接口和委托就可以快速实现联机。</p><p>首先需要获取在线会话接口并进行初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerSessionsSubsystem.h</span></span><br><span class="line">OnlineSessionPtr SessionInterface;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MultiplayerSessionsSubsystem.cpp</span></span><br><span class="line">IOnlineSubsystem* Subsystem = IOnlineSubsystem::<span class="built_in">Get</span>();</span><br><span class="line"><span class="keyword">if</span> (Subsystem) &#123;</span><br><span class="line">SessionInterface = Subsystem-&gt;<span class="built_in">GetSessionInterface</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的类中将会提供创建、寻找、加入、销毁、开始会话的五个接口，而这些接口实现其功能的方式则主要依赖于这个在线会话接口。现在来声明这些接口，并声明这些功能对应的委托及回调函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">UMultiplayerSessionsSubsystem</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 外部接口：供 UI 或其他模块调用的多人联机会话控制函数</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateSession</span><span class="params">(int32 NumPublicConnections, FString MatchType)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FindSessions</span><span class="params">(<span class="type">int</span> MaxSearchResults)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">JoinSessions</span><span class="params">(<span class="type">const</span> FOnlineSessionSearchResult&amp; SessionResult)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroySession</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StartSession</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 回调函数：会被 OnlineSubsystem 在异步操作完成后自动调用</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnCreateSessionComplete</span><span class="params">(FName SessionName, <span class="type">bool</span> bWasSuccessful)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnFindSessionsComplete</span><span class="params">(<span class="type">bool</span> bWasSuccessful)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnJoinSessionComplete</span><span class="params">(FName SessionName, EOnJoinSessionCompleteResult::Type Result)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnDestroySessionComplete</span><span class="params">(FName SessionName, <span class="type">bool</span> bWasSuccessful)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnStartSessionComplete</span><span class="params">(FName SessionName, <span class="type">bool</span> bWasSuccessful)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">IOnlineSessionPtr SessionInterface;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 委托声明+绑定：将回调函数挂载到OnlineSubsystem的事件通知中</span></span><br><span class="line"><span class="comment">// 每个委托都有对应的DelegateHandle用于解绑（防止重复绑定）</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">FOnCreateSessionCompleteDelegate CreateSessionCompleteDelegate;</span><br><span class="line">FDelegateHandle CreateSessionCompleteDelegateHandle;</span><br><span class="line">FOnFindSessionsCompleteDelegate FindSessionsCompleteDelegate;</span><br><span class="line">FDelegateHandle FindSessionsCompleteDelegateHandle;</span><br><span class="line">FOnJoinSessionCompleteDelegate JoinSessionCompleteDelegate;</span><br><span class="line">FDelegateHandle JoinSessionCompleteDelegateHandle;</span><br><span class="line">FOnDestroySessionCompleteDelegate DestroySessionCompleteDelegate;</span><br><span class="line">FDelegateHandle DestroySessionCompleteDelegateHandle;</span><br><span class="line">FOnStartSessionCompleteDelegate StartSessionCompleteDelegate;</span><br><span class="line">FDelegateHandle StartSessionCompleteDelegateHandle;</span><br></pre></td></tr></table></figure><p>将委托和回调函数进行绑定：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CreateSessionCompleteDelegate</span>(FOnCreateSessionCompleteDelegate::<span class="built_in">CreateUObject</span>(<span class="keyword">this</span>,&amp;ThisClass::OnCreateSessionComplete)),</span><br><span class="line"><span class="built_in">FindSessionsCompleteDelegate</span>(FOnFindSessionsCompleteDelegate::<span class="built_in">CreateUObject</span>(<span class="keyword">this</span>, &amp;ThisClass::OnFindSessionsComplete)),</span><br><span class="line"><span class="built_in">JoinSessionCompleteDelegate</span>(FOnJoinSessionCompleteDelegate::<span class="built_in">CreateUObject</span>(<span class="keyword">this</span>, &amp;ThisClass::OnJoinSessionComplete)),</span><br><span class="line"><span class="built_in">DestroySessionCompleteDelegate</span>(FOnDestroySessionCompleteDelegate::<span class="built_in">CreateUObject</span>(<span class="keyword">this</span>, &amp;ThisClass::OnDestroySessionComplete)),</span><br><span class="line"><span class="built_in">StartSessionCompleteDelegate</span>(FOnStartSessionCompleteDelegate::<span class="built_in">CreateUObject</span>(<span class="keyword">this</span>, &amp;ThisClass::OnStartSessionComplete))</span><br></pre></td></tr></table></figure><p>这里在声明委托的同时也声明了其对应的<strong>句柄</strong>，这是为了在需要时能“解绑”委托回调函数，避免重复绑定或内存泄漏。当我们将委托添加到对应的委托列表后，它是不会自动移除的。<strong>如果重复多次进行这一操作，同一个函数会被绑定多次，将会在回调时被多次调用</strong>（重复执行）。因此，为了后续解绑，需要保留绑定操作返回的<strong>句柄 <code>FDelegateHandle</code></strong>。</p><p>我们还将创建一个菜单类，这个类继承自<code>UserWidget</code>类，会通过调用<code>MultiplayerSessionsSubsystem</code>类的接口将对会话的操作简化成最简单的两个步骤：按下<code>Host</code>按钮和按下<code>Join</code>按钮。这样一来，使用插件时既可以在安装插件后直接使用最简单的联机功能，也可以通过提供的接口实现更多功能。</p><p>菜单类的构建文件中需要添加以下内容：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;UMG&quot;</span>,</span><br><span class="line"><span class="string">&quot;Slate&quot;</span>,</span><br><span class="line"><span class="string">&quot;SlateCore&quot;</span></span><br></pre></td></tr></table></figure><p>在菜单类中，先定义一个初始化菜单的函数，将菜单添加到视图上，并将输入模式设为仅UI，将光标显示出来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMenu::MenuSetup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">AddToViewport</span>();</span><br><span class="line"><span class="built_in">SetVisibility</span>(ESlateVisibility::Visible);</span><br><span class="line"><span class="comment">//SetFocus();</span></span><br><span class="line">bIsFocusable = <span class="literal">true</span>; <span class="comment">//按理说这一步在新版本的UE中被弃用了，应该被替换成上面的SetFocus函数，并且我最开始也是这么做的，但是后面莫名其妙又可以用这个方法了，并且还是有效的</span></span><br><span class="line"></span><br><span class="line">UWorld* World = <span class="built_in">GetWorld</span>();</span><br><span class="line"><span class="keyword">if</span> (World) &#123;</span><br><span class="line">APlayerController* PlayerController = World-&gt;<span class="built_in">GetFirstPlayerController</span>();</span><br><span class="line"><span class="keyword">if</span> (PlayerController) &#123;</span><br><span class="line">FInputModeUIOnly InputModeData;</span><br><span class="line">InputModeData.<span class="built_in">SetWidgetToFocus</span>(<span class="built_in">TakeWidget</span>());</span><br><span class="line">InputModeData.<span class="built_in">SetLockMouseToViewportBehavior</span>(EMouseLockMode::DoNotLock);</span><br><span class="line">PlayerController-&gt;<span class="built_in">SetInputMode</span>(InputModeData);</span><br><span class="line">PlayerController-&gt;<span class="built_in">SetShowMouseCursor</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>菜单的创建属于基础内容，直接快进。</p><p><img src="/undefined/f18ea7eb/image-20250707220712885.png" alt="image-20250707220712885"></p><p>在菜单类中对这两个按钮进行绑定，方法是使用元数据<code>meta=(BindWidget)</code>。声明这两个按钮的回调函数，并声明一个多人会话子系统的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(meta = (BindWidget))</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UButton</span>* HostButton;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(meta = (BindWidget))</span><br><span class="line">UButton* JoinButton;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HostButtonClicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">JoinButtonClicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理所有在线会话功能的子系统</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UMultiplayerSessionsSubsystem</span>* MultiplayerSessionsSubsystem;</span><br></pre></td></tr></table></figure><p>在<code>MenuSetup</code>函数中初始化子系统，并在UI初始化时将按钮点击的委托和回调函数进行绑定。注意，<strong>绑定的逻辑要放在<code>Initialize</code>函数中，而不是构造函数中，因为在构造函数调用时还无法访问蓝图中的控件，而<code>Initialize</code>函数会在控件全部加载完成后调用</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MenuSetup函数</span></span><br><span class="line">UGameInstance* GameInstance = <span class="built_in">GetGameInstance</span>();</span><br><span class="line"><span class="keyword">if</span> (GameInstance) &#123;</span><br><span class="line">MultiplayerSessionsSubsystem = GameInstance-&gt;<span class="built_in">GetSubsystem</span>&lt;UMultiplayerSessionsSubsystem&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UMenu::Initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!Super::<span class="built_in">Initialize</span>()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (HostButton) &#123;</span><br><span class="line">HostButton-&gt;OnClicked.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;ThisClass::HostButtonClicked);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (JoinButton) &#123;</span><br><span class="line">JoinButton-&gt;OnClicked.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;ThisClass::JoinButtonClicked);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMenu::HostButtonClicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (GEngine) &#123;</span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(</span><br><span class="line"><span class="number">-1</span>,</span><br><span class="line"><span class="number">15.f</span>,</span><br><span class="line">FColor::Yellow,</span><br><span class="line"><span class="built_in">FString</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Host Button Clicked&quot;</span>))</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (MultiplayerSessionsSubsystem) &#123;</span><br><span class="line">MultiplayerSessionsSubsystem-&gt;<span class="built_in">CreateSession</span>(<span class="number">4</span>, <span class="built_in">FString</span>(<span class="string">&quot;FreeForAll&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMenu::JoinButtonClicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (GEngine) &#123;</span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(</span><br><span class="line"><span class="number">-1</span>,</span><br><span class="line"><span class="number">15.f</span>,</span><br><span class="line">FColor::Yellow,</span><br><span class="line"><span class="built_in">FString</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Join Button Clicked&quot;</span>))</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-创建会话"><a href="#3-3-创建会话" class="headerlink" title="3.3 创建会话"></a>3.3 创建会话</h3><p>回到<code>MultiplayerSessionsSubsystem</code>类，现在要实现创建会话的功能了。在创建会话的函数中，将创建会话的委托加入委托列表，并保存句柄方便后续的解绑。然后创建一个在线会话的设置，使用这个设置来通过接口创建会话。如果创建失败，需要将委托解绑。</p><p>在创建会话时，如果有已经存在的会话需要将其销毁，但是这个过程需要时间，如果在调用销毁函数后离开创建会话，很容易因为当前会话还未销毁完毕而创建失败。解决方法是创建了三个变量，表示当前有没有正在销毁的会话，以及要创建的会话的信息，然后在销毁会话完成后的回调函数中进行创建。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerSessionsSubsystem.h</span></span><br><span class="line"><span class="type">bool</span> bCreateSessionOnDestroy = <span class="literal">false</span>;</span><br><span class="line">int32 LastNumPublicConnections;</span><br><span class="line">FString LastMatchType;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMultiplayerSessionsSubsystem::CreateSession</span><span class="params">(int32 NumPublicConnections, FString MatchType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!SessionInterface.<span class="built_in">IsValid</span>()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果有已经存在的会话，将其销毁</span></span><br><span class="line"><span class="keyword">auto</span> ExistingSession = SessionInterface-&gt;<span class="built_in">GetNamedSession</span>(NAME_GameSession);</span><br><span class="line"><span class="keyword">if</span> (ExistingSession) &#123;</span><br><span class="line">bCreateSessionOnDestroy = <span class="literal">true</span>;</span><br><span class="line">LastNumPublicConnections = NumPublicConnections;</span><br><span class="line">LastMatchType = MatchType;</span><br><span class="line"></span><br><span class="line"><span class="built_in">DestroySession</span>();<span class="comment">//这个函数会在之后实现，创建会话在摧毁会话的回调函数中进行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将委托添加到列表，进行会话设置，创建会话。保存委托的句柄使我们之后可以从委托列表中将其移除。</span></span><br><span class="line">CreateSessionCompleteDelegateHandle = SessionInterface-&gt;<span class="built_in">AddOnCreateSessionCompleteDelegate_Handle</span>(CreateSessionCompleteDelegate);</span><br><span class="line"></span><br><span class="line">LastSessionSettings = <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FOnlineSessionSettings</span>());</span><br><span class="line">LastSessionSettings-&gt;bIsLANMatch = IOnlineSubsystem::<span class="built_in">Get</span>()-&gt;<span class="built_in">GetSubsystemName</span>() == <span class="string">&quot;NULL&quot;</span>; <span class="comment">//是否为局域网匹配</span></span><br><span class="line">LastSessionSettings-&gt;NumPublicConnections = NumPublicConnections; <span class="comment">//最大联机数量</span></span><br><span class="line">LastSessionSettings-&gt;bAllowJoinInProgress = <span class="literal">true</span>; <span class="comment">//是否允许中途加入</span></span><br><span class="line">LastSessionSettings-&gt;bAllowJoinViaPresence = <span class="literal">true</span>; <span class="comment">//是否允许通过 Steam 好友加入</span></span><br><span class="line">LastSessionSettings-&gt;bShouldAdvertise = <span class="literal">true</span>; <span class="comment">//是否将房间暴露出去</span></span><br><span class="line">LastSessionSettings-&gt;bUsesPresence = <span class="literal">true</span>; <span class="comment">//是否使用“在线状态系统”</span></span><br><span class="line">LastSessionSettings-&gt;bUseLobbiesIfAvailable = <span class="literal">true</span>; <span class="comment">//是否使用 Steam Lobby 功能（新版UE需要启用这个功能才能创建会话）</span></span><br><span class="line">LastSessionSettings-&gt;<span class="built_in">Set</span>(<span class="built_in">FName</span>(<span class="string">&quot;MatchType&quot;</span>), MatchType, EOnlineDataAdvertisementType::ViaOnlineServiceAndPing);</span><br><span class="line">LastSessionSettings-&gt;BuildUniqueId = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ULocalPlayer* LocalPlayer = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetFirstLocalPlayerFromController</span>();</span><br><span class="line"><span class="keyword">if</span> (!SessionInterface-&gt;<span class="built_in">CreateSession</span>(*LocalPlayer-&gt;<span class="built_in">GetPreferredUniqueNetId</span>(), NAME_GameSession, *LastSessionSettings)) &#123;</span><br><span class="line">SessionInterface-&gt;<span class="built_in">ClearOnCreateSessionCompleteDelegate_Handle</span>(CreateSessionCompleteDelegateHandle);</span><br><span class="line"></span><br><span class="line"><span class="comment">//广播我们的自定义委托</span></span><br><span class="line">MultiplayerOnCreateSessionComplete.<span class="built_in">Broadcast</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在菜单类中声明三个变量，用来指定创建会话时的一些信息。在MenuSetup函数中接收这三个参数，为创建会话做好准备。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MenuSetup</span><span class="params">(int32 NumberOfPublicConnections = <span class="number">4</span>, FString TypeOfMatch = FString(TEXT(<span class="string">&quot;FreeForAll&quot;</span>)), FString LobbyPath = FString(TEXT(<span class="string">&quot;/Game/ThirdPerson/Maps/Lobby&quot;</span>)))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//最大连接数，匹配类型，大厅路径</span></span><br><span class="line">int32 NumPublicConnections&#123; <span class="number">4</span> &#125;;</span><br><span class="line">FString MatchType&#123; <span class="built_in">TEXT</span>(<span class="string">&quot;FreeForAll&quot;</span>) &#125;;</span><br><span class="line">FString PathToLobby&#123; <span class="built_in">TEXT</span>(<span class="string">&quot;&quot;</span>) &#125;;</span><br></pre></td></tr></table></figure><p>按下<code>Host</code>按钮后，我们要做的就是调用<code>MultiplayerSessionsSubsystem</code>的<code>CreateSession</code>接口，将上面声明的变量传递过去用于创建会话。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (MultiplayerSessionsSubsystem) &#123;</span><br><span class="line">MultiplayerSessionsSubsystem-&gt;<span class="built_in">CreateSession</span>(NumPublicConnections, MatchType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前已经实现了<code>Menu</code>类对<code>MultiplayerSessionsSubsystem</code>类的单向通信（点击<code>Host</code>按钮后通过<code>MultiplayerSessionsSubsystem</code>类创建会话），但是还没有实现<code>MultiplayerSessionsSubsystem</code>类对<code>Menu</code>类的通信。这里实现双向通信的方式仍然是委托。我们在<code>MultiplayerSessionsSubsystem</code>类中声明一组委托，用于绑定<code>Menu</code>类的回调函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerSessionsSubsystem.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 为菜单类声明我们自定义的委托，用于菜单类绑定</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam</span>(FMultiplayerOnCreateSessionComplete, <span class="type">bool</span>, bWasSuccessful);</span><br><span class="line"><span class="built_in">DECLARE_MULTICAST_DELEGATE_TwoParams</span>(FMultiplayerOnFindSessionsComplete, <span class="type">const</span> TArray &lt;FOnlineSessionSearchResult&gt;&amp; SessionResults, <span class="type">bool</span> bWasSuccessful);</span><br><span class="line"><span class="built_in">DECLARE_MULTICAST_DELEGATE_OneParam</span>(FMultiplayerOnJoinSessionComplete, EOnJoinSessionCompleteResult::Type Result);</span><br><span class="line"><span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam</span>(FMultiplayerOnDestroySessionComplete, <span class="type">bool</span>, bWasSuccessful);</span><br><span class="line"><span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam</span>(FMultiplayerOnStartSessionComplete, <span class="type">bool</span>, bWasSuccessful);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 我们自己自定义的委托，菜单类的回调函数可以绑定这个委托</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">FMultiplayerOnCreateSessionComplete MultiplayerOnCreateSessionComplete;</span><br><span class="line">FMultiplayerOnFindSessionsComplete MultiplayerOnFindSessionsComplete;</span><br><span class="line">FMultiplayerOnJoinSessionComplete MultiplayerOnJoinSessionComplete;</span><br><span class="line">FMultiplayerOnDestroySessionComplete MultiplayerOnDestroySessionComplete;</span><br><span class="line">FMultiplayerOnStartSessionComplete MultiplayerOnStartSessionComplete;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Menu.h</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 绑定到MultiplayerSessionsSubsystem类的自定义委托的回调函数</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnCreateSession</span><span class="params">(<span class="type">bool</span> bWasSuccessful)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnFindSessions</span><span class="params">(<span class="type">const</span> TArray &lt;FOnlineSessionSearchResult&gt;&amp; SessionResults, <span class="type">bool</span> bWasSuccessful)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnJoinSession</span><span class="params">(EOnJoinSessionCompleteResult::Type Result)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnDestroySession</span><span class="params">(<span class="type">bool</span> bWasSuccessful)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnStartSession</span><span class="params">(<span class="type">bool</span> bWasSuccessful)</span></span>;</span><br></pre></td></tr></table></figure><p>可以看到，这些回调函数中有的声明了<code>UFUNCTION</code>，有的没有。这是因为在声明委托时，有的声明为了动态多播委托，而<strong>动态多播委托必须绑定<code>UFUNCTION</code>，参数中的类也必须是<code>UCLASS</code>或者<code>USTRUCT</code></strong>。然而<strong>在发现会话的委托和加入会话的委托中，我们想要传递的参数并不是<code>UCLASS</code>或者<code>USTRUCT</code>，所以无法使用动态多播，只能声明为多播，因此绑定的函数也不能声明为<code>UFUNCTION</code></strong>。</p><blockquote><p><code>DECLARE_DYNAMIC_MULTICAST_DELEGATE</code>（动态多播委托）与 <code>DECLARE_MULTICAST_DELEGATE</code>（普通多播）之间的主要差别在于<strong>是否依赖反射系统（Reflection）并可被蓝图/序列化访问</strong>：</p><ul><li><p><strong>动态（Dynamic）多播委托</strong>：可以在蓝图中绑定/触发（可标为 <code>UPROPERTY</code>），需要绑定的回调函数用 <code>UFUNCTION</code> 声明，并且参数类型必须是反射系统可识别的类型（<code>UCLASS</code>、<code>USTRUCT</code>、基础类型等）。优点是可序列化、能与蓝图交互；缺点是运行时开销略大（使用 <code>FScriptDelegate</code>），不能承载任意 C++ 类型参数。</p></li><li><p><strong>普通（非动态）多播委托</strong>：纯 C++，允许任意 C++ 参数类型（例如 <code>FOnlineSessionSearchResult</code>），性能更好，但不能直接在蓝图绑定或序列化。</p></li></ul><pre><code>如果委托需要暴露给 UMG / Blueprint（比如在蓝图里直接绑定），使用动态多播；如果是纯 C++ 的高频回调或参数类型不被反射支持，推荐使用普通多播。</code></pre></blockquote><p>在菜单建立的函数中，将回调函数和<code>MultiplayerSessionsSubsystem</code>类中自定义的委托进行绑定。<strong>根据委托是否是动态的，绑定方式也有所区别。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定回调函数</span></span><br><span class="line"><span class="keyword">if</span> (MultiplayerSessionsSubsystem) &#123;</span><br><span class="line">MultiplayerSessionsSubsystem-&gt;MultiplayerOnCreateSessionComplete.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;ThisClass::OnCreateSession);</span><br><span class="line">MultiplayerSessionsSubsystem-&gt;MultiplayerOnFindSessionsComplete.<span class="built_in">AddUObject</span>(<span class="keyword">this</span>, &amp;ThisClass::OnFindSessions);</span><br><span class="line">MultiplayerSessionsSubsystem-&gt;MultiplayerOnJoinSessionComplete.<span class="built_in">AddUObject</span>(<span class="keyword">this</span>, &amp;ThisClass::OnJoinSession);</span><br><span class="line">MultiplayerSessionsSubsystem-&gt;MultiplayerOnDestroySessionComplete.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;ThisClass::OnDestroySession);</span><br><span class="line">MultiplayerSessionsSubsystem-&gt;MultiplayerOnStartSessionComplete.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;ThisClass::OnStartSession);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，<code>MultiplayerSessionsSubsystem</code>类就可以与<code>Menu</code>类进行通话了。在<code>MultiplayerSessionsSubsystem</code>类中创建会话时，如果创建失败，需要广播自定义委托并传入参数<code>false</code>，这样菜单就知道：创建会话失败了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!SessionInterface-&gt;<span class="built_in">CreateSession</span>(*LocalPlayer-&gt;<span class="built_in">GetPreferredUniqueNetId</span>(), NAME_GameSession, *LastSessionSettings)) &#123;</span><br><span class="line">SessionInterface-&gt;<span class="built_in">ClearOnCreateSessionCompleteDelegate_Handle</span>(CreateSessionCompleteDelegateHandle);</span><br><span class="line"></span><br><span class="line"><span class="comment">//广播我们的自定义委托</span></span><br><span class="line">MultiplayerOnCreateSessionComplete.<span class="built_in">Broadcast</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有失败，<code>MultiplayerSessionsSubsystem</code>类需要在创建会话的回调函数中广播委托，告诉菜单会话有没有创建成功。<strong>在这之前还要先解绑创建会话的委托</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMultiplayerSessionsSubsystem::OnCreateSessionComplete</span><span class="params">(FName SessionName, <span class="type">bool</span> bWasSuccessful)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (SessionInterface) &#123;</span><br><span class="line">SessionInterface-&gt;<span class="built_in">ClearOnCreateSessionCompleteDelegate_Handle</span>(CreateSessionCompleteDelegateHandle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MultiplayerOnCreateSessionComplete.<span class="built_in">Broadcast</span>(bWasSuccessful);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>Menu</code>类中的发现会话的函数中，我们接收到了<code>MultiplayerSessionsSubsystem</code>类传来的信息。如果创建成功了，就传送到大厅并设为监听服务器。传送完成后，还需要清除菜单并使玩家能够控制菜单。这部分逻辑放在<code>MenuTearDown</code>函数中实现，这个函数在<code>NativeDestruct</code>函数中被调用，而<code>NativaDestrcut</code>函数会在离开地图时被自动调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMenu::OnCreateSession</span><span class="params">(<span class="type">bool</span> bWasSuccessful)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bWasSuccessful) &#123;</span><br><span class="line"><span class="keyword">if</span> (GEngine) &#123;</span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(</span><br><span class="line"><span class="number">-1</span>,</span><br><span class="line"><span class="number">15.f</span>,</span><br><span class="line">FColor::Yellow,</span><br><span class="line"><span class="built_in">FString</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Session created successfully!&quot;</span>))</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UWorld* World = <span class="built_in">GetWorld</span>();</span><br><span class="line"><span class="keyword">if</span> (World) &#123;</span><br><span class="line">World-&gt;<span class="built_in">ServerTravel</span>(PathToLobby);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (GEngine) &#123;</span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(</span><br><span class="line"><span class="number">-1</span>,</span><br><span class="line"><span class="number">15.f</span>,</span><br><span class="line">FColor::Red,</span><br><span class="line"><span class="built_in">FString</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Failed to create session!&quot;</span>))</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMenu::NativeDestruct</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">MenuTearDown</span>();</span><br><span class="line">Super::<span class="built_in">NativeDestruct</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMenu::MenuTearDown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">RemoveFromParent</span>();</span><br><span class="line">UWorld* World = <span class="built_in">GetWorld</span>();</span><br><span class="line"><span class="keyword">if</span> (World) &#123;</span><br><span class="line">APlayerController* PlayerController = World-&gt;<span class="built_in">GetFirstPlayerController</span>();</span><br><span class="line"><span class="keyword">if</span> (PlayerController) &#123;</span><br><span class="line">FInputModeGameOnly InputModeData;</span><br><span class="line">PlayerController-&gt;<span class="built_in">SetInputMode</span>(InputModeData);</span><br><span class="line">PlayerController-&gt;<span class="built_in">SetShowMouseCursor</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-加入会话"><a href="#3-4-加入会话" class="headerlink" title="3.4 加入会话"></a>3.4 加入会话</h3><p>创建会话后，需要实现加入会话的功能。当<code>Join</code>按钮被按下后，回调函数中会执行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (MultiplayerSessionsSubsystem) &#123;</span><br><span class="line">MultiplayerSessionsSubsystem-&gt;<span class="built_in">FindSessions</span>(<span class="number">10000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现会话的实现如下，和之前的逻辑差不多，直接放代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMultiplayerSessionsSubsystem::FindSessions</span><span class="params">(<span class="type">int</span> MaxSearchResults)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!SessionInterface.<span class="built_in">IsValid</span>()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FindSessionsCompleteDelegateHandle = SessionInterface-&gt;<span class="built_in">AddOnFindSessionsCompleteDelegate_Handle</span>(FindSessionsCompleteDelegate); <span class="comment">//保存句柄</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//会话搜索设置</span></span><br><span class="line">LastSessionSearch = <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FOnlineSessionSearch</span>());</span><br><span class="line">LastSessionSearch-&gt;MaxSearchResults = MaxSearchResults;</span><br><span class="line">LastSessionSearch-&gt;bIsLanQuery = IOnlineSubsystem::<span class="built_in">Get</span>()-&gt;<span class="built_in">GetSubsystemName</span>() == <span class="string">&quot;NULL&quot;</span>;</span><br><span class="line">LastSessionSearch-&gt;QuerySettings.<span class="built_in">Set</span>(SEARCH_PRESENCE, <span class="literal">true</span>, EOnlineComparisonOp::Equals);</span><br><span class="line"></span><br><span class="line"><span class="comment">//搜索会话。如果搜索失败，委托解绑并向菜单广播创建失败</span></span><br><span class="line"><span class="type">const</span> ULocalPlayer* LocalPlayer = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetFirstLocalPlayerFromController</span>();</span><br><span class="line"><span class="keyword">if</span> (!SessionInterface-&gt;<span class="built_in">FindSessions</span>(*LocalPlayer-&gt;<span class="built_in">GetPreferredUniqueNetId</span>(), LastSessionSearch.<span class="built_in">ToSharedRef</span>())) &#123;</span><br><span class="line">SessionInterface-&gt;<span class="built_in">ClearOnFindSessionsCompleteDelegate_Handle</span>(FindSessionsCompleteDelegateHandle);</span><br><span class="line"></span><br><span class="line">MultiplayerOnFindSessionsComplete.<span class="built_in">Broadcast</span>(<span class="built_in">TArray</span>&lt;FOnlineSessionSearchResult&gt;(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有失败，会执行发现会话的回调函数，如果没有发现会话，直接返回，否则将搜索结果作为参数进行广播，调用菜单类的发现会话的回调函数。注意新版UE5在这里要对搜索结果手动将<code>bUseLobbiesIfAvailable</code>设为true，因为不知道什么时候会自动变成false。如果这里不改回来，将无法加入会话。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMultiplayerSessionsSubsystem::OnFindSessionsComplete</span><span class="params">(<span class="type">bool</span> bWasSuccessful)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (SessionInterface) &#123;</span><br><span class="line">SessionInterface-&gt;<span class="built_in">ClearOnFindSessionsCompleteDelegate_Handle</span>(FindSessionsCompleteDelegateHandle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果没有找到会话，返回失败</span></span><br><span class="line"><span class="keyword">if</span> (LastSessionSearch-&gt;SearchResults.<span class="built_in">Num</span>() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">MultiplayerOnFindSessionsComplete.<span class="built_in">Broadcast</span>(<span class="built_in">TArray</span>&lt;FOnlineSessionSearchResult&gt;(), <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (GEngine) &#123;</span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(</span><br><span class="line"><span class="number">-1</span>,</span><br><span class="line"><span class="number">1.f</span>,</span><br><span class="line">FColor::Red,</span><br><span class="line"><span class="built_in">FString</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Session not found!&quot;</span>))</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; Result : LastSessionSearch-&gt;SearchResults)</span><br><span class="line">&#123;</span><br><span class="line">Result.Session.SessionSettings.bUseLobbiesIfAvailable = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MultiplayerOnFindSessionsComplete.<span class="built_in">Broadcast</span>(LastSessionSearch-&gt;SearchResults, bWasSuccessful);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>菜单类的回调函数，如果找到匹配的会话，直接通过接口加入会话：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMenu::OnFindSessions</span><span class="params">(<span class="type">const</span> TArray&lt;FOnlineSessionSearchResult&gt;&amp; SessionResults, <span class="type">bool</span> bWasSuccessful)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!MultiplayerSessionsSubsystem) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历搜索结果，如果找到了匹配的会话，直接通过接口加入会话</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; Result : SessionResults) &#123;</span><br><span class="line">FString SettingsValue;</span><br><span class="line">Result.Session.SessionSettings.<span class="built_in">Get</span>(<span class="built_in">FName</span>(<span class="string">&quot;MatchType&quot;</span>), SettingsValue);</span><br><span class="line"><span class="keyword">if</span> (SettingsValue == MatchType) &#123;</span><br><span class="line"></span><br><span class="line">MultiplayerSessionsSubsystem-&gt;<span class="built_in">JoinSessions</span>(Result);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加入会话的函数实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMultiplayerSessionsSubsystem::JoinSessions</span><span class="params">(<span class="type">const</span> FOnlineSessionSearchResult&amp; SessionResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!SessionInterface.<span class="built_in">IsValid</span>()) &#123;</span><br><span class="line">MultiplayerOnJoinSessionComplete.<span class="built_in">Broadcast</span>(EOnJoinSessionCompleteResult::UnknownError);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存句柄</span></span><br><span class="line">JoinSessionCompleteDelegateHandle = SessionInterface-&gt;<span class="built_in">AddOnJoinSessionCompleteDelegate_Handle</span>(JoinSessionCompleteDelegate);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过在线会话接口加入会话，如果失败就委托解绑，广播加入会话失败</span></span><br><span class="line"><span class="type">const</span> ULocalPlayer* LocalPlayer = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetFirstLocalPlayerFromController</span>();</span><br><span class="line"><span class="keyword">if</span> (!SessionInterface-&gt;<span class="built_in">JoinSession</span>(*LocalPlayer-&gt;<span class="built_in">GetPreferredUniqueNetId</span>(), NAME_GameSession, SessionResult)) &#123;</span><br><span class="line">SessionInterface-&gt;<span class="built_in">ClearOnJoinSessionCompleteDelegate_Handle</span>(JoinSessionCompleteDelegateHandle);</span><br><span class="line">MultiplayerOnJoinSessionComplete.<span class="built_in">Broadcast</span>(EOnJoinSessionCompleteResult::UnknownError);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在回调函数中向菜单类广播结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMultiplayerSessionsSubsystem::OnJoinSessionComplete</span><span class="params">(FName SessionName, EOnJoinSessionCompleteResult::Type Result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!SessionInterface) &#123;</span><br><span class="line">SessionInterface-&gt;<span class="built_in">ClearOnJoinSessionCompleteDelegate_Handle</span>(JoinSessionCompleteDelegateHandle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MultiplayerOnJoinSessionComplete.<span class="built_in">Broadcast</span>(Result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在菜单类的回调函数中调用<code>ClientTravel</code>将客户端传送到主机。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMenu::OnJoinSession</span><span class="params">(EOnJoinSessionCompleteResult::Type Result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">IOnlineSubsystem* Subsystem = IOnlineSubsystem::<span class="built_in">Get</span>();</span><br><span class="line"><span class="keyword">if</span> (Subsystem) &#123;</span><br><span class="line">IOnlineSessionPtr SessionInterface = Subsystem-&gt;<span class="built_in">GetSessionInterface</span>();</span><br><span class="line"><span class="keyword">if</span> (SessionInterface.<span class="built_in">IsValid</span>()) &#123;</span><br><span class="line">FString Address;</span><br><span class="line">SessionInterface-&gt;<span class="built_in">GetResolvedConnectString</span>(NAME_GameSession, Address);</span><br><span class="line"><span class="keyword">if</span> (Address == <span class="built_in">FString</span>()) &#123;</span><br><span class="line"><span class="keyword">if</span> (GEngine) &#123;</span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(</span><br><span class="line"><span class="number">-1</span>,</span><br><span class="line"><span class="number">15.f</span>,</span><br><span class="line">FColor::Red,</span><br><span class="line"><span class="built_in">FString</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Address not found!&quot;</span>))</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">APlayerController* PlayerController = <span class="built_in">GetGameInstance</span>()-&gt;<span class="built_in">GetFirstLocalPlayerController</span>();</span><br><span class="line"><span class="keyword">if</span> (PlayerController) &#123;</span><br><span class="line">PlayerController-&gt;<span class="built_in">ClientTravel</span>(Address, ETravelType::TRAVEL_Absolute);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样从创建会话到加入会话的功能就全部完成了。</p><h3 id="3-5-销毁会话"><a href="#3-5-销毁会话" class="headerlink" title="3.5 销毁会话"></a>3.5 销毁会话</h3><p>解绑委托后直接使用在线会话接口销毁会话即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMultiplayerSessionsSubsystem::DestroySession</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!SessionInterface.<span class="built_in">IsValid</span>()) &#123;</span><br><span class="line">MultiplayerOnDestroySessionComplete.<span class="built_in">Broadcast</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DestroySessionCompleteDelegateHandle = SessionInterface-&gt;<span class="built_in">AddOnDestroySessionCompleteDelegate_Handle</span>(DestroySessionCompleteDelegate);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!SessionInterface-&gt;<span class="built_in">DestroySession</span>(NAME_GameSession)) &#123;</span><br><span class="line">SessionInterface-&gt;<span class="built_in">ClearOnDestroySessionCompleteDelegate_Handle</span>(DestroySessionCompleteDelegateHandle);</span><br><span class="line">MultiplayerOnDestroySessionComplete.<span class="built_in">Broadcast</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在回调函数中将<code>bCreateSessionOnDestroy</code>设为false，表示当前没有要销毁的会话，然后通过成员变量保存的信息创建会话。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMultiplayerSessionsSubsystem::OnDestroySessionComplete</span><span class="params">(FName SessionName, <span class="type">bool</span> bWasSuccessful)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (SessionInterface) &#123;</span><br><span class="line">SessionInterface-&gt;<span class="built_in">ClearOnDestroySessionCompleteDelegate_Handle</span>(DestroySessionCompleteDelegateHandle);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bWasSuccessful &amp;&amp; bCreateSessionOnDestroy) &#123;</span><br><span class="line">bCreateSessionOnDestroy = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">CreateSession</span>(LastNumPublicConnections, LastMatchType);</span><br><span class="line">&#125;</span><br><span class="line">MultiplayerOnDestroySessionComplete.<span class="built_in">Broadcast</span>(bWasSuccessful);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-收尾"><a href="#3-6-收尾" class="headerlink" title="3.6 收尾"></a>3.6 收尾</h3><p>菜单中有一个瑕疵：<code>Host</code>按钮和<code>Join</code>按钮可以被反复按下，而在加入会话和搜寻会话的过程中，我们是不希望按钮被按下的，这是我们要限制按钮的功能。主要是通过向按钮的<code>SetIsEnabled</code>函数中传入<code>true</code>和<code>false</code>来控制按钮的可用性。</p><p>当按下创建会话按钮后需要将按钮设为不可用，直到回调函数中返回“创建会话失败”再设为可用，表示可以重新尝试创建会话了。</p><p>按下加入会话按钮后同样将按钮设为不可用，当回调函数中返回“加入会话失败”再设为可用，表示可以重新尝试加入会话。</p><p>当修补了这个小瑕疵后，插件的功能就完成的差不多了。当安装插件后，可以直接通过菜单的两个按钮实现联机，也可以通过调用<code>MultiplayerSessionsSubsystem</code>来实现更多功能。</p><h2 id="4-完整代码"><a href="#4-完整代码" class="headerlink" title="4.完整代码"></a>4.完整代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MenuSystemCharacter.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Character.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Logging/LogMacros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Interfaces/OnlineSessionInterface.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MenuSystemCharacter.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">USpringArmComponent</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UCameraComponent</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UInputMappingContext</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UInputAction</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FInputActionValue</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">DECLARE_LOG_CATEGORY_EXTERN</span>(LogTemplateCharacter, Log, All);</span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>(config=Game)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AMenuSystemCharacter</span> : <span class="keyword">public</span> ACharacter</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Camera boom positioning the camera behind the character */</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = <span class="string">&quot;true&quot;</span>))</span><br><span class="line">USpringArmComponent* CameraBoom;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Follow camera */</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = <span class="string">&quot;true&quot;</span>))</span><br><span class="line">UCameraComponent* FollowCamera;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** MappingContext */</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = Input, meta = (AllowPrivateAccess = <span class="string">&quot;true&quot;</span>))</span><br><span class="line">UInputMappingContext* DefaultMappingContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Jump Input Action */</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = Input, meta = (AllowPrivateAccess = <span class="string">&quot;true&quot;</span>))</span><br><span class="line">UInputAction* JumpAction;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Move Input Action */</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = Input, meta = (AllowPrivateAccess = <span class="string">&quot;true&quot;</span>))</span><br><span class="line">UInputAction* MoveAction;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Look Input Action */</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = Input, meta = (AllowPrivateAccess = <span class="string">&quot;true&quot;</span>))</span><br><span class="line">UInputAction* LookAction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">AMenuSystemCharacter</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Called for movement input */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">const</span> FInputActionValue&amp; Value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Called for looking input */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Look</span><span class="params">(<span class="type">const</span> FInputActionValue&amp; Value)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">NotifyControllerChanged</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetupPlayerInputComponent</span><span class="params">(<span class="keyword">class</span> UInputComponent* PlayerInputComponent)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/** Returns CameraBoom subobject **/</span></span><br><span class="line"><span class="function">FORCEINLINE <span class="keyword">class</span> USpringArmComponent* <span class="title">GetCameraBoom</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> CameraBoom; &#125;</span><br><span class="line"><span class="comment">/** Returns FollowCamera subobject **/</span></span><br><span class="line"><span class="function">FORCEINLINE <span class="keyword">class</span> UCameraComponent* <span class="title">GetFollowCamera</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> FollowCamera; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//在线会话接口的指针</span></span><br><span class="line">IOnlineSessionPtr OnlineSessionInterface;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateGameSession</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">JoinGameSession</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Delegate fired when a session create request has completed</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @param SessionName the name of the session this callback is for</span></span><br><span class="line"><span class="comment">* @param bWasSuccessful true if the async action completed without error, false if there was an error</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnCreateSessionComplete</span><span class="params">(FName SessionName, <span class="type">bool</span> bWasSussful)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnFindSessionsComplete</span><span class="params">(<span class="type">bool</span> bWasSuccessful)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnJoinSessionComplete</span><span class="params">(FName SessionName, EOnJoinSessionCompleteResult::Type Result)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">FOnCreateSessionCompleteDelegate CreateSessionCompleteDelegate;</span><br><span class="line">FOnFindSessionsCompleteDelegate FindSessionsCompleteDelegate;</span><br><span class="line">TSharedPtr&lt;FOnlineSessionSearch&gt; SessionSearch;</span><br><span class="line">FOnJoinSessionCompleteDelegate JoinSessionCompleteDelegate;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MenuSystemCharacter.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MenuSystemCharacter.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Engine/LocalPlayer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Camera/CameraComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Components/CapsuleComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/CharacterMovementComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/SpringArmComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Controller.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EnhancedInputComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EnhancedInputSubsystems.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;InputActionValue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OnlineSubsystem.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OnlineSessionSettings.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Online/OnlineSessionNames.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">DEFINE_LOG_CATEGORY</span>(LogTemplateCharacter);</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// AMenuSystemCharacter</span></span><br><span class="line"></span><br><span class="line">AMenuSystemCharacter::<span class="built_in">AMenuSystemCharacter</span>() :</span><br><span class="line"><span class="built_in">CreateSessionCompleteDelegate</span>(FOnCreateSessionCompleteDelegate::<span class="built_in">CreateUObject</span>(<span class="keyword">this</span>, &amp;ThisClass::OnCreateSessionComplete)),</span><br><span class="line"><span class="built_in">FindSessionsCompleteDelegate</span>(FOnFindSessionsCompleteDelegate::<span class="built_in">CreateUObject</span>(<span class="keyword">this</span>, &amp;ThisClass::OnFindSessionsComplete)),</span><br><span class="line"><span class="built_in">JoinSessionCompleteDelegate</span>(FOnJoinSessionCompleteDelegate::<span class="built_in">CreateUObject</span>(<span class="keyword">this</span>, &amp;ThisClass::OnJoinSessionComplete))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Set size for collision capsule</span></span><br><span class="line"><span class="built_in">GetCapsuleComponent</span>()-&gt;<span class="built_in">InitCapsuleSize</span>(<span class="number">42.f</span>, <span class="number">96.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Don&#x27;t rotate when the controller rotates. Let that just affect the camera.</span></span><br><span class="line">bUseControllerRotationPitch = <span class="literal">false</span>;</span><br><span class="line">bUseControllerRotationYaw = <span class="literal">false</span>;</span><br><span class="line">bUseControllerRotationRoll = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure character movement</span></span><br><span class="line"><span class="built_in">GetCharacterMovement</span>()-&gt;bOrientRotationToMovement = <span class="literal">true</span>; <span class="comment">// Character moves in the direction of input...</span></span><br><span class="line"><span class="built_in">GetCharacterMovement</span>()-&gt;RotationRate = <span class="built_in">FRotator</span>(<span class="number">0.0f</span>, <span class="number">500.0f</span>, <span class="number">0.0f</span>); <span class="comment">// ...at this rotation rate</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Note: For faster iteration times these variables, and many more, can be tweaked in the Character Blueprint</span></span><br><span class="line"><span class="comment">// instead of recompiling to adjust them</span></span><br><span class="line"><span class="built_in">GetCharacterMovement</span>()-&gt;JumpZVelocity = <span class="number">700.f</span>;</span><br><span class="line"><span class="built_in">GetCharacterMovement</span>()-&gt;AirControl = <span class="number">0.35f</span>;</span><br><span class="line"><span class="built_in">GetCharacterMovement</span>()-&gt;MaxWalkSpeed = <span class="number">500.f</span>;</span><br><span class="line"><span class="built_in">GetCharacterMovement</span>()-&gt;MinAnalogWalkSpeed = <span class="number">20.f</span>;</span><br><span class="line"><span class="built_in">GetCharacterMovement</span>()-&gt;BrakingDecelerationWalking = <span class="number">2000.f</span>;</span><br><span class="line"><span class="built_in">GetCharacterMovement</span>()-&gt;BrakingDecelerationFalling = <span class="number">1500.0f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a camera boom (pulls in towards the player if there is a collision)</span></span><br><span class="line">CameraBoom = <span class="built_in">CreateDefaultSubobject</span>&lt;USpringArmComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;CameraBoom&quot;</span>));</span><br><span class="line">CameraBoom-&gt;<span class="built_in">SetupAttachment</span>(RootComponent);</span><br><span class="line">CameraBoom-&gt;TargetArmLength = <span class="number">400.0f</span>; <span class="comment">// The camera follows at this distance behind the character</span></span><br><span class="line">CameraBoom-&gt;bUsePawnControlRotation = <span class="literal">true</span>; <span class="comment">// Rotate the arm based on the controller</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a follow camera</span></span><br><span class="line">FollowCamera = <span class="built_in">CreateDefaultSubobject</span>&lt;UCameraComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;FollowCamera&quot;</span>));</span><br><span class="line">FollowCamera-&gt;<span class="built_in">SetupAttachment</span>(CameraBoom, USpringArmComponent::SocketName); <span class="comment">// Attach the camera to the end of the boom and let the boom adjust to match the controller orientation</span></span><br><span class="line">FollowCamera-&gt;bUsePawnControlRotation = <span class="literal">false</span>; <span class="comment">// Camera does not rotate relative to arm</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Note: The skeletal mesh and anim blueprint references on the Mesh component (inherited from Character) </span></span><br><span class="line"><span class="comment">// are set in the derived blueprint asset named ThirdPersonCharacter (to avoid direct content references in C++)</span></span><br><span class="line"></span><br><span class="line">IOnlineSubsystem* OnlineSubsystem = IOnlineSubsystem::<span class="built_in">Get</span>();</span><br><span class="line"><span class="keyword">if</span> (OnlineSubsystem) &#123;</span><br><span class="line">OnlineSessionInterface = OnlineSubsystem-&gt;<span class="built_in">GetSessionInterface</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*if (GEngine) &#123;</span></span><br><span class="line"><span class="comment">GEngine-&gt;AddOnScreenDebugMessage(</span></span><br><span class="line"><span class="comment">-1,</span></span><br><span class="line"><span class="comment">15.f,</span></span><br><span class="line"><span class="comment">FColor::Blue,</span></span><br><span class="line"><span class="comment">FString::Printf(TEXT(&quot;Found subsystem %s&quot;), *OnlineSubsystem-&gt;GetSubsystemName().ToString())</span></span><br><span class="line"><span class="comment">);</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Input</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMenuSystemCharacter::NotifyControllerChanged</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">NotifyControllerChanged</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add Input Mapping Context</span></span><br><span class="line"><span class="keyword">if</span> (APlayerController* PlayerController = <span class="built_in">Cast</span>&lt;APlayerController&gt;(Controller))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::<span class="built_in">GetSubsystem</span>&lt;UEnhancedInputLocalPlayerSubsystem&gt;(PlayerController-&gt;<span class="built_in">GetLocalPlayer</span>()))</span><br><span class="line">&#123;</span><br><span class="line">Subsystem-&gt;<span class="built_in">AddMappingContext</span>(DefaultMappingContext, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMenuSystemCharacter::SetupPlayerInputComponent</span><span class="params">(UInputComponent* PlayerInputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Set up action bindings</span></span><br><span class="line"><span class="keyword">if</span> (UEnhancedInputComponent* EnhancedInputComponent = <span class="built_in">Cast</span>&lt;UEnhancedInputComponent&gt;(PlayerInputComponent)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Jumping</span></span><br><span class="line">EnhancedInputComponent-&gt;<span class="built_in">BindAction</span>(JumpAction, ETriggerEvent::Started, <span class="keyword">this</span>, &amp;ACharacter::Jump);</span><br><span class="line">EnhancedInputComponent-&gt;<span class="built_in">BindAction</span>(JumpAction, ETriggerEvent::Completed, <span class="keyword">this</span>, &amp;ACharacter::StopJumping);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Moving</span></span><br><span class="line">EnhancedInputComponent-&gt;<span class="built_in">BindAction</span>(MoveAction, ETriggerEvent::Triggered, <span class="keyword">this</span>, &amp;AMenuSystemCharacter::Move);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Looking</span></span><br><span class="line">EnhancedInputComponent-&gt;<span class="built_in">BindAction</span>(LookAction, ETriggerEvent::Triggered, <span class="keyword">this</span>, &amp;AMenuSystemCharacter::Look);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogTemplateCharacter, Error, <span class="built_in">TEXT</span>(<span class="string">&quot;&#x27;%s&#x27; Failed to find an Enhanced Input component! This template is built to use the Enhanced Input system. If you intend to use the legacy system, then you will need to update this C++ file.&quot;</span>), *<span class="built_in">GetNameSafe</span>(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建会话</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMenuSystemCharacter::CreateGameSession</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//按“1”调用函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//检查指针是否有效</span></span><br><span class="line"><span class="keyword">if</span> (!OnlineSessionInterface.<span class="built_in">IsValid</span>()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查当前是否存在会话，如果有，将其销毁</span></span><br><span class="line"><span class="keyword">auto</span> ExistingSession = OnlineSessionInterface-&gt;<span class="built_in">GetNamedSession</span>(NAME_GameSession);</span><br><span class="line"><span class="keyword">if</span> (ExistingSession) &#123;</span><br><span class="line">OnlineSessionInterface-&gt;<span class="built_in">DestroySession</span>(NAME_GameSession);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将委托添加到列表，进行会话设置，创建会话</span></span><br><span class="line">OnlineSessionInterface-&gt;<span class="built_in">AddOnCreateSessionCompleteDelegate_Handle</span>(CreateSessionCompleteDelegate);</span><br><span class="line"></span><br><span class="line">TSharedPtr&lt;FOnlineSessionSettings&gt; SessionSettings = <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FOnlineSessionSettings</span>());</span><br><span class="line">SessionSettings-&gt;bIsLANMatch = <span class="literal">false</span>; <span class="comment">//是否为局域网匹配</span></span><br><span class="line">SessionSettings-&gt;NumPublicConnections = <span class="number">4</span>; <span class="comment">//最大联机数量</span></span><br><span class="line">SessionSettings-&gt;bAllowJoinInProgress = <span class="literal">true</span>; <span class="comment">//是否允许中途加入</span></span><br><span class="line">SessionSettings-&gt;bAllowJoinViaPresence = <span class="literal">true</span>; <span class="comment">//是否允许通过 Steam 好友加入</span></span><br><span class="line">SessionSettings-&gt;bShouldAdvertise = <span class="literal">true</span>; <span class="comment">//是否将房间暴露出去</span></span><br><span class="line">SessionSettings-&gt;bUsesPresence = <span class="literal">true</span>; <span class="comment">//是否使用“在线状态系统”</span></span><br><span class="line">SessionSettings-&gt;bUseLobbiesIfAvailable = <span class="literal">true</span>; <span class="comment">//是否使用 Steam Lobby 功能</span></span><br><span class="line">SessionSettings-&gt;<span class="built_in">Set</span>(<span class="built_in">FName</span>(<span class="string">&quot;MatchType&quot;</span>), <span class="built_in">FString</span>(<span class="string">&quot;FreeForAll&quot;</span>), EOnlineDataAdvertisementType::ViaOnlineServiceAndPing);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ULocalPlayer* localPlayer = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetFirstLocalPlayerFromController</span>();</span><br><span class="line">OnlineSessionInterface-&gt;<span class="built_in">CreateSession</span>(*localPlayer-&gt;<span class="built_in">GetPreferredUniqueNetId</span>(), NAME_GameSession, *SessionSettings);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加入会话</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMenuSystemCharacter::JoinGameSession</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!OnlineSessionInterface.<span class="built_in">IsValid</span>()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OnlineSessionInterface-&gt;<span class="built_in">AddOnFindSessionsCompleteDelegate_Handle</span>(FindSessionsCompleteDelegate);</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找会话</span></span><br><span class="line">SessionSearch = <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FOnlineSessionSearch</span>());</span><br><span class="line">SessionSearch-&gt;MaxSearchResults = <span class="number">10000</span>; <span class="comment">//最多查找多少个房间</span></span><br><span class="line">SessionSearch-&gt;bIsLanQuery = <span class="literal">false</span>; <span class="comment">//是否为局域网查找</span></span><br><span class="line">SessionSearch-&gt;QuerySettings.<span class="built_in">Set</span>(SEARCH_PRESENCE, <span class="literal">true</span>, EOnlineComparisonOp::Equals); <span class="comment">//查找支持好友加入/展示的房间</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ULocalPlayer* LocalPlayer = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetFirstLocalPlayerFromController</span>();</span><br><span class="line">OnlineSessionInterface-&gt;<span class="built_in">FindSessions</span>(*LocalPlayer-&gt;<span class="built_in">GetPreferredUniqueNetId</span>(), SessionSearch.<span class="built_in">ToSharedRef</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建会话的回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMenuSystemCharacter::OnCreateSessionComplete</span><span class="params">(FName SessionName, <span class="type">bool</span> bWasSussful)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bWasSussful) &#123;</span><br><span class="line"><span class="keyword">if</span> (GEngine) &#123;</span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(</span><br><span class="line"><span class="number">-1</span>,</span><br><span class="line"><span class="number">15.f</span>,</span><br><span class="line">FColor::Blue,</span><br><span class="line">FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Created session: %s&quot;</span>),*SessionName.<span class="built_in">ToString</span>())</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UWorld* world = <span class="built_in">GetWorld</span>();</span><br><span class="line"><span class="keyword">if</span> (world) &#123;</span><br><span class="line">world-&gt;<span class="built_in">ServerTravel</span>(<span class="built_in">FString</span>(<span class="string">&quot;/Game/ThirdPerson/Maps/Lobby?listen&quot;</span>)); <span class="comment">//打开大厅地图并设为服务器</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (GEngine) &#123;</span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(</span><br><span class="line"><span class="number">-1</span>,</span><br><span class="line"><span class="number">15.f</span>,</span><br><span class="line">FColor::Red,</span><br><span class="line"><span class="built_in">FString</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Failed to create session!&quot;</span>))</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发现会话的回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMenuSystemCharacter::OnFindSessionsComplete</span><span class="params">(<span class="type">bool</span> bWasSuccessful)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!OnlineSessionInterface.<span class="built_in">IsValid</span>()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> Result : SessionSearch-&gt;SearchResults) &#123;</span><br><span class="line">FString Id = Result.<span class="built_in">GetSessionIdStr</span>(); <span class="comment">//获得会话ID</span></span><br><span class="line">FString User = Result.Session.OwningUserName; <span class="comment">//获得会话拥有者</span></span><br><span class="line">FString MatchType;</span><br><span class="line">Result.Session.SessionSettings.<span class="built_in">Get</span>(<span class="built_in">FName</span>(<span class="string">&quot;MatchType&quot;</span>), MatchType); <span class="comment">//获取比赛类型</span></span><br><span class="line"><span class="keyword">if</span>(GEngine) &#123;</span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(</span><br><span class="line"><span class="number">-1</span>,</span><br><span class="line"><span class="number">15.f</span>,</span><br><span class="line">FColor::Cyan,</span><br><span class="line">FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Id: %s, User: %s&quot;</span>), *Id, *User)</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查比赛类型是否是FreeForAll</span></span><br><span class="line"><span class="keyword">if</span> (MatchType == <span class="built_in">FString</span>(<span class="string">&quot;FreeForAll&quot;</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (GEngine) &#123;</span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(</span><br><span class="line"><span class="number">-1</span>,</span><br><span class="line"><span class="number">15.f</span>,</span><br><span class="line">FColor::Cyan,</span><br><span class="line">FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Joing Match Type: %s&quot;</span>), *MatchType)</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OnlineSessionInterface-&gt;<span class="built_in">AddOnJoinSessionCompleteDelegate_Handle</span>(JoinSessionCompleteDelegate);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ULocalPlayer* localPlayer = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetFirstLocalPlayerFromController</span>();</span><br><span class="line">OnlineSessionInterface-&gt;<span class="built_in">JoinSession</span>(*localPlayer-&gt;<span class="built_in">GetPreferredUniqueNetId</span>(), NAME_GameSession, Result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加入会话的回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMenuSystemCharacter::OnJoinSessionComplete</span><span class="params">(FName SessionName, EOnJoinSessionCompleteResult::Type Result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!OnlineSessionInterface.<span class="built_in">IsValid</span>()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">FString Address;</span><br><span class="line"><span class="keyword">if</span> (OnlineSessionInterface-&gt;<span class="built_in">GetResolvedConnectString</span>(NAME_GameSession, Address)) &#123;</span><br><span class="line"><span class="keyword">if</span> (GEngine) &#123;</span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(</span><br><span class="line"><span class="number">-1</span>,</span><br><span class="line"><span class="number">15.f</span>,</span><br><span class="line">FColor::Yellow,</span><br><span class="line">FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Connext string: %s&quot;</span>), *Address)</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">APlayerController* PlayerController = <span class="built_in">GetGameInstance</span>()-&gt;<span class="built_in">GetFirstLocalPlayerController</span>();</span><br><span class="line"><span class="keyword">if</span> (PlayerController) &#123;</span><br><span class="line">PlayerController-&gt;<span class="built_in">ClientTravel</span>(Address, ETravelType::TRAVEL_Absolute);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(</span><br><span class="line"><span class="number">-1</span>,</span><br><span class="line"><span class="number">15.f</span>,</span><br><span class="line">FColor::Yellow,</span><br><span class="line">FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Address Not Find&quot;</span>))</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMenuSystemCharacter::Move</span><span class="params">(<span class="type">const</span> FInputActionValue&amp; Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// input is a Vector2D</span></span><br><span class="line">FVector2D MovementVector = Value.<span class="built_in">Get</span>&lt;FVector2D&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Controller != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// find out which way is forward</span></span><br><span class="line"><span class="type">const</span> FRotator Rotation = Controller-&gt;<span class="built_in">GetControlRotation</span>();</span><br><span class="line"><span class="function"><span class="type">const</span> FRotator <span class="title">YawRotation</span><span class="params">(<span class="number">0</span>, Rotation.Yaw, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get forward vector</span></span><br><span class="line"><span class="type">const</span> FVector ForwardDirection = <span class="built_in">FRotationMatrix</span>(YawRotation).<span class="built_in">GetUnitAxis</span>(EAxis::X);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get right vector </span></span><br><span class="line"><span class="type">const</span> FVector RightDirection = <span class="built_in">FRotationMatrix</span>(YawRotation).<span class="built_in">GetUnitAxis</span>(EAxis::Y);</span><br><span class="line"></span><br><span class="line"><span class="comment">// add movement </span></span><br><span class="line"><span class="built_in">AddMovementInput</span>(ForwardDirection, MovementVector.Y);</span><br><span class="line"><span class="built_in">AddMovementInput</span>(RightDirection, MovementVector.X);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMenuSystemCharacter::Look</span><span class="params">(<span class="type">const</span> FInputActionValue&amp; Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// input is a Vector2D</span></span><br><span class="line">FVector2D LookAxisVector = Value.<span class="built_in">Get</span>&lt;FVector2D&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Controller != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// add yaw and pitch input to controller</span></span><br><span class="line"><span class="built_in">AddControllerYawInput</span>(LookAxisVector.X);</span><br><span class="line"><span class="built_in">AddControllerPitchInput</span>(LookAxisVector.Y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerSessionsSubsystem.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Subsystems/GameInstanceSubsystem.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Interfaces/OnlineSessionInterface.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MultiplayerSessionsSubsystem.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 为菜单类声明我们自定义的委托，用于菜单类绑定</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam</span>(FMultiplayerOnCreateSessionComplete, <span class="type">bool</span>, bWasSuccessful);</span><br><span class="line"><span class="built_in">DECLARE_MULTICAST_DELEGATE_TwoParams</span>(FMultiplayerOnFindSessionsComplete, <span class="type">const</span> TArray &lt;FOnlineSessionSearchResult&gt;&amp; SessionResults, <span class="type">bool</span> bWasSuccessful);</span><br><span class="line"><span class="built_in">DECLARE_MULTICAST_DELEGATE_OneParam</span>(FMultiplayerOnJoinSessionComplete, EOnJoinSessionCompleteResult::Type Result);</span><br><span class="line"><span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam</span>(FMultiplayerOnDestroySessionComplete, <span class="type">bool</span>, bWasSuccessful);</span><br><span class="line"><span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam</span>(FMultiplayerOnStartSessionComplete, <span class="type">bool</span>, bWasSuccessful);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MULTIPLAYERSESSIONS_API</span> UMultiplayerSessionsSubsystem : <span class="keyword">public</span> UGameInstanceSubsystem</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">UMultiplayerSessionsSubsystem</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 外部接口：供 UI 或其他模块调用的多人联机会话控制函数</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateSession</span><span class="params">(int32 NumPublicConnections, FString MatchType)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FindSessions</span><span class="params">(<span class="type">int</span> MaxSearchResults)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">JoinSessions</span><span class="params">(<span class="type">const</span> FOnlineSessionSearchResult&amp; SessionResult)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroySession</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StartSession</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 我们自己自定义的委托，菜单类的回调函数可以绑定这个委托</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">FMultiplayerOnCreateSessionComplete MultiplayerOnCreateSessionComplete;</span><br><span class="line">FMultiplayerOnFindSessionsComplete MultiplayerOnFindSessionsComplete;</span><br><span class="line">FMultiplayerOnJoinSessionComplete MultiplayerOnJoinSessionComplete;</span><br><span class="line">FMultiplayerOnDestroySessionComplete MultiplayerOnDestroySessionComplete;</span><br><span class="line">FMultiplayerOnStartSessionComplete MultiplayerOnStartSessionComplete;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 回调函数：会被 OnlineSubsystem 在异步操作完成后自动调用</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnCreateSessionComplete</span><span class="params">(FName SessionName, <span class="type">bool</span> bWasSuccessful)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnFindSessionsComplete</span><span class="params">(<span class="type">bool</span> bWasSuccessful)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnJoinSessionComplete</span><span class="params">(FName SessionName, EOnJoinSessionCompleteResult::Type Result)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnDestroySessionComplete</span><span class="params">(FName SessionName, <span class="type">bool</span> bWasSuccessful)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnStartSessionComplete</span><span class="params">(FName SessionName, <span class="type">bool</span> bWasSuccessful)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">IOnlineSessionPtr SessionInterface;</span><br><span class="line">TSharedPtr&lt;FOnlineSessionSettings&gt; LastSessionSettings;</span><br><span class="line">TSharedPtr&lt;FOnlineSessionSearch&gt; LastSessionSearch;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 委托声明+绑定：将回调函数挂载到OnlineSubsystem的事件通知中</span></span><br><span class="line"><span class="comment">// 每个委托都有对应的DelegateHandle用于解绑（防止重复绑定）</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">FOnCreateSessionCompleteDelegate CreateSessionCompleteDelegate;</span><br><span class="line">FDelegateHandle CreateSessionCompleteDelegateHandle;</span><br><span class="line">FOnFindSessionsCompleteDelegate FindSessionsCompleteDelegate;</span><br><span class="line">FDelegateHandle FindSessionsCompleteDelegateHandle;</span><br><span class="line">FOnJoinSessionCompleteDelegate JoinSessionCompleteDelegate;</span><br><span class="line">FDelegateHandle JoinSessionCompleteDelegateHandle;</span><br><span class="line">FOnDestroySessionCompleteDelegate DestroySessionCompleteDelegate;</span><br><span class="line">FDelegateHandle DestroySessionCompleteDelegateHandle;</span><br><span class="line">FOnStartSessionCompleteDelegate StartSessionCompleteDelegate;</span><br><span class="line">FDelegateHandle StartSessionCompleteDelegateHandle;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> bCreateSessionOnDestroy = <span class="literal">false</span>;</span><br><span class="line">int32 LastNumPublicConnections;</span><br><span class="line">FString LastMatchType;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiplayerSessionsSubsystem.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MultiplayerSessionsSubsystem.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OnlineSubsystem.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OnlineSessionSettings.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Online/OnlineSessionNames.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">UMultiplayerSessionsSubsystem::<span class="built_in">UMultiplayerSessionsSubsystem</span>():</span><br><span class="line"><span class="built_in">CreateSessionCompleteDelegate</span>(FOnCreateSessionCompleteDelegate::<span class="built_in">CreateUObject</span>(<span class="keyword">this</span>,&amp;ThisClass::OnCreateSessionComplete)),</span><br><span class="line"><span class="built_in">FindSessionsCompleteDelegate</span>(FOnFindSessionsCompleteDelegate::<span class="built_in">CreateUObject</span>(<span class="keyword">this</span>, &amp;ThisClass::OnFindSessionsComplete)),</span><br><span class="line"><span class="built_in">JoinSessionCompleteDelegate</span>(FOnJoinSessionCompleteDelegate::<span class="built_in">CreateUObject</span>(<span class="keyword">this</span>, &amp;ThisClass::OnJoinSessionComplete)),</span><br><span class="line"><span class="built_in">DestroySessionCompleteDelegate</span>(FOnDestroySessionCompleteDelegate::<span class="built_in">CreateUObject</span>(<span class="keyword">this</span>, &amp;ThisClass::OnDestroySessionComplete)),</span><br><span class="line"><span class="built_in">StartSessionCompleteDelegate</span>(FOnStartSessionCompleteDelegate::<span class="built_in">CreateUObject</span>(<span class="keyword">this</span>, &amp;ThisClass::OnStartSessionComplete))</span><br><span class="line">&#123;</span><br><span class="line">IOnlineSubsystem* Subsystem = IOnlineSubsystem::<span class="built_in">Get</span>();</span><br><span class="line"><span class="keyword">if</span> (Subsystem) &#123;</span><br><span class="line">SessionInterface = Subsystem-&gt;<span class="built_in">GetSessionInterface</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMultiplayerSessionsSubsystem::CreateSession</span><span class="params">(int32 NumPublicConnections, FString MatchType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!SessionInterface.<span class="built_in">IsValid</span>()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果有已经存在的会话，将其销毁</span></span><br><span class="line"><span class="keyword">auto</span> ExistingSession = SessionInterface-&gt;<span class="built_in">GetNamedSession</span>(NAME_GameSession);</span><br><span class="line"><span class="keyword">if</span> (ExistingSession) &#123;</span><br><span class="line">bCreateSessionOnDestroy = <span class="literal">true</span>;</span><br><span class="line">LastNumPublicConnections = NumPublicConnections;</span><br><span class="line">LastMatchType = MatchType;</span><br><span class="line"></span><br><span class="line"><span class="built_in">DestroySession</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将委托添加到列表，进行会话设置，创建会话。保存委托的句柄使我们之后可以从委托列表中将其移除。</span></span><br><span class="line">CreateSessionCompleteDelegateHandle = SessionInterface-&gt;<span class="built_in">AddOnCreateSessionCompleteDelegate_Handle</span>(CreateSessionCompleteDelegate);</span><br><span class="line"></span><br><span class="line">LastSessionSettings = <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FOnlineSessionSettings</span>());</span><br><span class="line">LastSessionSettings-&gt;bIsLANMatch = IOnlineSubsystem::<span class="built_in">Get</span>()-&gt;<span class="built_in">GetSubsystemName</span>() == <span class="string">&quot;NULL&quot;</span>; <span class="comment">//是否为局域网匹配</span></span><br><span class="line">LastSessionSettings-&gt;NumPublicConnections = NumPublicConnections; <span class="comment">//最大联机数量</span></span><br><span class="line">LastSessionSettings-&gt;bAllowJoinInProgress = <span class="literal">true</span>; <span class="comment">//是否允许中途加入</span></span><br><span class="line">LastSessionSettings-&gt;bAllowJoinViaPresence = <span class="literal">true</span>; <span class="comment">//是否允许通过 Steam 好友加入</span></span><br><span class="line">LastSessionSettings-&gt;bShouldAdvertise = <span class="literal">true</span>; <span class="comment">//是否将房间暴露出去</span></span><br><span class="line">LastSessionSettings-&gt;bUsesPresence = <span class="literal">true</span>; <span class="comment">//是否使用“在线状态系统”</span></span><br><span class="line">LastSessionSettings-&gt;bUseLobbiesIfAvailable = <span class="literal">true</span>; <span class="comment">//是否使用 Steam Lobby 功能（新版UE需要启用这个功能才能创建会话）</span></span><br><span class="line">LastSessionSettings-&gt;<span class="built_in">Set</span>(<span class="built_in">FName</span>(<span class="string">&quot;MatchType&quot;</span>), MatchType, EOnlineDataAdvertisementType::ViaOnlineServiceAndPing);</span><br><span class="line">LastSessionSettings-&gt;BuildUniqueId = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ULocalPlayer* LocalPlayer = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetFirstLocalPlayerFromController</span>();</span><br><span class="line"><span class="keyword">if</span> (!SessionInterface-&gt;<span class="built_in">CreateSession</span>(*LocalPlayer-&gt;<span class="built_in">GetPreferredUniqueNetId</span>(), NAME_GameSession, *LastSessionSettings)) &#123;</span><br><span class="line">SessionInterface-&gt;<span class="built_in">ClearOnCreateSessionCompleteDelegate_Handle</span>(CreateSessionCompleteDelegateHandle);</span><br><span class="line"></span><br><span class="line"><span class="comment">//广播我们的自定义委托</span></span><br><span class="line">MultiplayerOnCreateSessionComplete.<span class="built_in">Broadcast</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMultiplayerSessionsSubsystem::FindSessions</span><span class="params">(<span class="type">int</span> MaxSearchResults)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!SessionInterface.<span class="built_in">IsValid</span>()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FindSessionsCompleteDelegateHandle = SessionInterface-&gt;<span class="built_in">AddOnFindSessionsCompleteDelegate_Handle</span>(FindSessionsCompleteDelegate); <span class="comment">//保存句柄</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//会话搜索设置</span></span><br><span class="line">LastSessionSearch = <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FOnlineSessionSearch</span>());</span><br><span class="line">LastSessionSearch-&gt;MaxSearchResults = MaxSearchResults;</span><br><span class="line">LastSessionSearch-&gt;bIsLanQuery = IOnlineSubsystem::<span class="built_in">Get</span>()-&gt;<span class="built_in">GetSubsystemName</span>() == <span class="string">&quot;NULL&quot;</span>;</span><br><span class="line">LastSessionSearch-&gt;QuerySettings.<span class="built_in">Set</span>(SEARCH_PRESENCE, <span class="literal">true</span>, EOnlineComparisonOp::Equals);</span><br><span class="line"></span><br><span class="line"><span class="comment">//搜索会话。如果搜索失败，委托解绑并向菜单广播创建失败</span></span><br><span class="line"><span class="type">const</span> ULocalPlayer* LocalPlayer = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetFirstLocalPlayerFromController</span>();</span><br><span class="line"><span class="keyword">if</span> (!SessionInterface-&gt;<span class="built_in">FindSessions</span>(*LocalPlayer-&gt;<span class="built_in">GetPreferredUniqueNetId</span>(), LastSessionSearch.<span class="built_in">ToSharedRef</span>())) &#123;</span><br><span class="line">SessionInterface-&gt;<span class="built_in">ClearOnFindSessionsCompleteDelegate_Handle</span>(FindSessionsCompleteDelegateHandle);</span><br><span class="line"></span><br><span class="line">MultiplayerOnFindSessionsComplete.<span class="built_in">Broadcast</span>(<span class="built_in">TArray</span>&lt;FOnlineSessionSearchResult&gt;(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMultiplayerSessionsSubsystem::JoinSessions</span><span class="params">(<span class="type">const</span> FOnlineSessionSearchResult&amp; SessionResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!SessionInterface.<span class="built_in">IsValid</span>()) &#123;</span><br><span class="line">MultiplayerOnJoinSessionComplete.<span class="built_in">Broadcast</span>(EOnJoinSessionCompleteResult::UnknownError);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存句柄</span></span><br><span class="line">JoinSessionCompleteDelegateHandle = SessionInterface-&gt;<span class="built_in">AddOnJoinSessionCompleteDelegate_Handle</span>(JoinSessionCompleteDelegate);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过在线会话接口加入会话，如果失败就委托解绑，广播加入会话失败</span></span><br><span class="line"><span class="type">const</span> ULocalPlayer* LocalPlayer = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetFirstLocalPlayerFromController</span>();</span><br><span class="line"><span class="keyword">if</span> (!SessionInterface-&gt;<span class="built_in">JoinSession</span>(*LocalPlayer-&gt;<span class="built_in">GetPreferredUniqueNetId</span>(), NAME_GameSession, SessionResult)) &#123;</span><br><span class="line">SessionInterface-&gt;<span class="built_in">ClearOnJoinSessionCompleteDelegate_Handle</span>(JoinSessionCompleteDelegateHandle);</span><br><span class="line">MultiplayerOnJoinSessionComplete.<span class="built_in">Broadcast</span>(EOnJoinSessionCompleteResult::UnknownError);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMultiplayerSessionsSubsystem::DestroySession</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!SessionInterface.<span class="built_in">IsValid</span>()) &#123;</span><br><span class="line">MultiplayerOnDestroySessionComplete.<span class="built_in">Broadcast</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DestroySessionCompleteDelegateHandle = SessionInterface-&gt;<span class="built_in">AddOnDestroySessionCompleteDelegate_Handle</span>(DestroySessionCompleteDelegate);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!SessionInterface-&gt;<span class="built_in">DestroySession</span>(NAME_GameSession)) &#123;</span><br><span class="line">SessionInterface-&gt;<span class="built_in">ClearOnDestroySessionCompleteDelegate_Handle</span>(DestroySessionCompleteDelegateHandle);</span><br><span class="line">MultiplayerOnDestroySessionComplete.<span class="built_in">Broadcast</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMultiplayerSessionsSubsystem::StartSession</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMultiplayerSessionsSubsystem::OnCreateSessionComplete</span><span class="params">(FName SessionName, <span class="type">bool</span> bWasSuccessful)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (SessionInterface) &#123;</span><br><span class="line">SessionInterface-&gt;<span class="built_in">ClearOnCreateSessionCompleteDelegate_Handle</span>(CreateSessionCompleteDelegateHandle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MultiplayerOnCreateSessionComplete.<span class="built_in">Broadcast</span>(bWasSuccessful);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMultiplayerSessionsSubsystem::OnFindSessionsComplete</span><span class="params">(<span class="type">bool</span> bWasSuccessful)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (SessionInterface) &#123;</span><br><span class="line">SessionInterface-&gt;<span class="built_in">ClearOnFindSessionsCompleteDelegate_Handle</span>(FindSessionsCompleteDelegateHandle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果没有找到会话，返回失败</span></span><br><span class="line"><span class="keyword">if</span> (LastSessionSearch-&gt;SearchResults.<span class="built_in">Num</span>() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">MultiplayerOnFindSessionsComplete.<span class="built_in">Broadcast</span>(<span class="built_in">TArray</span>&lt;FOnlineSessionSearchResult&gt;(), <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (GEngine) &#123;</span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(</span><br><span class="line"><span class="number">-1</span>,</span><br><span class="line"><span class="number">1.f</span>,</span><br><span class="line">FColor::Red,</span><br><span class="line"><span class="built_in">FString</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Session not found!&quot;</span>))</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; Result : LastSessionSearch-&gt;SearchResults)</span><br><span class="line">&#123;</span><br><span class="line">Result.Session.SessionSettings.bUseLobbiesIfAvailable = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MultiplayerOnFindSessionsComplete.<span class="built_in">Broadcast</span>(LastSessionSearch-&gt;SearchResults, bWasSuccessful);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMultiplayerSessionsSubsystem::OnJoinSessionComplete</span><span class="params">(FName SessionName, EOnJoinSessionCompleteResult::Type Result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!SessionInterface) &#123;</span><br><span class="line">SessionInterface-&gt;<span class="built_in">ClearOnJoinSessionCompleteDelegate_Handle</span>(JoinSessionCompleteDelegateHandle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MultiplayerOnJoinSessionComplete.<span class="built_in">Broadcast</span>(Result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMultiplayerSessionsSubsystem::OnDestroySessionComplete</span><span class="params">(FName SessionName, <span class="type">bool</span> bWasSuccessful)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (SessionInterface) &#123;</span><br><span class="line">SessionInterface-&gt;<span class="built_in">ClearOnDestroySessionCompleteDelegate_Handle</span>(DestroySessionCompleteDelegateHandle);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bWasSuccessful &amp;&amp; bCreateSessionOnDestroy) &#123;</span><br><span class="line">bCreateSessionOnDestroy = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">CreateSession</span>(LastNumPublicConnections, LastMatchType);</span><br><span class="line">&#125;</span><br><span class="line">MultiplayerOnDestroySessionComplete.<span class="built_in">Broadcast</span>(bWasSuccessful);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMultiplayerSessionsSubsystem::OnStartSessionComplete</span><span class="params">(FName SessionName, <span class="type">bool</span> bWasSuccessful)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Menu.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Blueprint/UserWidget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Interfaces/OnlineSessionInterface.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Menu.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MULTIPLAYERSESSIONS_API</span> UMenu : <span class="keyword">public</span> UUserWidget</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MenuSetup</span><span class="params">(int32 NumberOfPublicConnections = <span class="number">4</span>, FString TypeOfMatch = FString(TEXT(<span class="string">&quot;FreeForAll&quot;</span>)), FString LobbyPath = FString(TEXT(<span class="string">&quot;/Game/ThirdPerson/Maps/Lobby&quot;</span>)))</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">Initialize</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">NativeDestruct</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 绑定到MultiplayerSessionsSubsystem类的自定义委托的回调函数</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnCreateSession</span><span class="params">(<span class="type">bool</span> bWasSuccessful)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnFindSessions</span><span class="params">(<span class="type">const</span> TArray &lt;FOnlineSessionSearchResult&gt;&amp; SessionResults, <span class="type">bool</span> bWasSuccessful)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnJoinSession</span><span class="params">(EOnJoinSessionCompleteResult::Type Result)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnDestroySession</span><span class="params">(<span class="type">bool</span> bWasSuccessful)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnStartSession</span><span class="params">(<span class="type">bool</span> bWasSuccessful)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">UPROPERTY</span>(meta = (BindWidget))</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UButton</span>* HostButton;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(meta = (BindWidget))</span><br><span class="line">UButton* JoinButton;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HostButtonClicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">JoinButtonClicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除菜单</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MenuTearDown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理所有在线会话功能的子系统</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UMultiplayerSessionsSubsystem</span>* MultiplayerSessionsSubsystem;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大连接数，匹配类型，大厅路径</span></span><br><span class="line">int32 NumPublicConnections&#123; <span class="number">4</span> &#125;;</span><br><span class="line">FString MatchType&#123; <span class="built_in">TEXT</span>(<span class="string">&quot;FreeForAll&quot;</span>) &#125;;</span><br><span class="line">FString PathToLobby&#123; <span class="built_in">TEXT</span>(<span class="string">&quot;&quot;</span>) &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Menu.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Menu.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Components/Button.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MultiplayerSessionsSubsystem.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OnlineSessionSettings.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OnlineSubsystem.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMenu::MenuSetup</span><span class="params">(int32 NumberOfPublicConnections, FString TypeOfMatch, FString LobbyPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PathToLobby = FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;%s?listen&quot;</span>), *LobbyPath);</span><br><span class="line">NumPublicConnections = NumberOfPublicConnections;</span><br><span class="line">MatchType = TypeOfMatch;</span><br><span class="line"><span class="built_in">AddToViewport</span>();</span><br><span class="line"><span class="built_in">SetVisibility</span>(ESlateVisibility::Visible);</span><br><span class="line"><span class="comment">//SetFocus();</span></span><br><span class="line">bIsFocusable = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">UWorld* World = <span class="built_in">GetWorld</span>();</span><br><span class="line"><span class="keyword">if</span> (World) &#123;</span><br><span class="line">APlayerController* PlayerController = World-&gt;<span class="built_in">GetFirstPlayerController</span>();</span><br><span class="line"><span class="keyword">if</span> (PlayerController) &#123;</span><br><span class="line">FInputModeUIOnly InputModeData;</span><br><span class="line">InputModeData.<span class="built_in">SetWidgetToFocus</span>(<span class="built_in">TakeWidget</span>());</span><br><span class="line">InputModeData.<span class="built_in">SetLockMouseToViewportBehavior</span>(EMouseLockMode::DoNotLock);</span><br><span class="line">PlayerController-&gt;<span class="built_in">SetInputMode</span>(InputModeData);</span><br><span class="line">PlayerController-&gt;<span class="built_in">SetShowMouseCursor</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UGameInstance* GameInstance = <span class="built_in">GetGameInstance</span>();</span><br><span class="line"><span class="keyword">if</span> (GameInstance) &#123;</span><br><span class="line">MultiplayerSessionsSubsystem = GameInstance-&gt;<span class="built_in">GetSubsystem</span>&lt;UMultiplayerSessionsSubsystem&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定回调函数</span></span><br><span class="line"><span class="keyword">if</span> (MultiplayerSessionsSubsystem) &#123;</span><br><span class="line">MultiplayerSessionsSubsystem-&gt;MultiplayerOnCreateSessionComplete.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;ThisClass::OnCreateSession);</span><br><span class="line">MultiplayerSessionsSubsystem-&gt;MultiplayerOnFindSessionsComplete.<span class="built_in">AddUObject</span>(<span class="keyword">this</span>, &amp;ThisClass::OnFindSessions);</span><br><span class="line">MultiplayerSessionsSubsystem-&gt;MultiplayerOnJoinSessionComplete.<span class="built_in">AddUObject</span>(<span class="keyword">this</span>, &amp;ThisClass::OnJoinSession);</span><br><span class="line">MultiplayerSessionsSubsystem-&gt;MultiplayerOnDestroySessionComplete.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;ThisClass::OnDestroySession);</span><br><span class="line">MultiplayerSessionsSubsystem-&gt;MultiplayerOnStartSessionComplete.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;ThisClass::OnStartSession);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UMenu::Initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!Super::<span class="built_in">Initialize</span>()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (HostButton) &#123;</span><br><span class="line">HostButton-&gt;OnClicked.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;ThisClass::HostButtonClicked);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (JoinButton) &#123;</span><br><span class="line">JoinButton-&gt;OnClicked.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;ThisClass::JoinButtonClicked);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMenu::NativeDestruct</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">MenuTearDown</span>();</span><br><span class="line">Super::<span class="built_in">NativeDestruct</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMenu::OnCreateSession</span><span class="params">(<span class="type">bool</span> bWasSuccessful)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bWasSuccessful) &#123;</span><br><span class="line"><span class="keyword">if</span> (GEngine) &#123;</span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(</span><br><span class="line"><span class="number">-1</span>,</span><br><span class="line"><span class="number">15.f</span>,</span><br><span class="line">FColor::Yellow,</span><br><span class="line"><span class="built_in">FString</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Session created successfully!&quot;</span>))</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UWorld* World = <span class="built_in">GetWorld</span>();</span><br><span class="line"><span class="keyword">if</span> (World) &#123;</span><br><span class="line">World-&gt;<span class="built_in">ServerTravel</span>(PathToLobby);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (GEngine) &#123;</span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(</span><br><span class="line"><span class="number">-1</span>,</span><br><span class="line"><span class="number">15.f</span>,</span><br><span class="line">FColor::Red,</span><br><span class="line"><span class="built_in">FString</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Failed to create session!&quot;</span>))</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">HostButton-&gt;<span class="built_in">SetIsEnabled</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMenu::OnFindSessions</span><span class="params">(<span class="type">const</span> TArray&lt;FOnlineSessionSearchResult&gt;&amp; SessionResults, <span class="type">bool</span> bWasSuccessful)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!MultiplayerSessionsSubsystem) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历搜索结果，如果找到了匹配的会话，直接通过接口加入会话</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; Result : SessionResults) &#123;</span><br><span class="line">FString SettingsValue;</span><br><span class="line">Result.Session.SessionSettings.<span class="built_in">Get</span>(<span class="built_in">FName</span>(<span class="string">&quot;MatchType&quot;</span>), SettingsValue);</span><br><span class="line"><span class="keyword">if</span> (SettingsValue == MatchType) &#123;</span><br><span class="line"></span><br><span class="line">MultiplayerSessionsSubsystem-&gt;<span class="built_in">JoinSessions</span>(Result);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!bWasSuccessful || SessionResults.<span class="built_in">Num</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">JoinButton-&gt;<span class="built_in">SetIsEnabled</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMenu::OnJoinSession</span><span class="params">(EOnJoinSessionCompleteResult::Type Result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">IOnlineSubsystem* Subsystem = IOnlineSubsystem::<span class="built_in">Get</span>();</span><br><span class="line"><span class="keyword">if</span> (Subsystem) &#123;</span><br><span class="line">IOnlineSessionPtr SessionInterface = Subsystem-&gt;<span class="built_in">GetSessionInterface</span>();</span><br><span class="line"><span class="keyword">if</span> (SessionInterface.<span class="built_in">IsValid</span>()) &#123;</span><br><span class="line">FString Address;</span><br><span class="line">SessionInterface-&gt;<span class="built_in">GetResolvedConnectString</span>(NAME_GameSession, Address);</span><br><span class="line"><span class="keyword">if</span> (Address == <span class="built_in">FString</span>()) &#123;</span><br><span class="line"><span class="keyword">if</span> (GEngine) &#123;</span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(</span><br><span class="line"><span class="number">-1</span>,</span><br><span class="line"><span class="number">15.f</span>,</span><br><span class="line">FColor::Red,</span><br><span class="line"><span class="built_in">FString</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Address not found!&quot;</span>))</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">APlayerController* PlayerController = <span class="built_in">GetGameInstance</span>()-&gt;<span class="built_in">GetFirstLocalPlayerController</span>();</span><br><span class="line"><span class="keyword">if</span> (PlayerController) &#123;</span><br><span class="line">PlayerController-&gt;<span class="built_in">ClientTravel</span>(Address, ETravelType::TRAVEL_Absolute);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Result != EOnJoinSessionCompleteResult::Success) &#123;</span><br><span class="line">JoinButton-&gt;<span class="built_in">SetIsEnabled</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMenu::OnDestroySession</span><span class="params">(<span class="type">bool</span> bWasSuccessful)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMenu::OnStartSession</span><span class="params">(<span class="type">bool</span> bWasSuccessful)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMenu::HostButtonClicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*if (GEngine) &#123;</span></span><br><span class="line"><span class="comment">GEngine-&gt;AddOnScreenDebugMessage(</span></span><br><span class="line"><span class="comment">-1,</span></span><br><span class="line"><span class="comment">15.f,</span></span><br><span class="line"><span class="comment">FColor::Yellow,</span></span><br><span class="line"><span class="comment">FString(TEXT(&quot;Host Button Clicked&quot;))</span></span><br><span class="line"><span class="comment">)；</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line">HostButton-&gt;<span class="built_in">SetIsEnabled</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (MultiplayerSessionsSubsystem) &#123;</span><br><span class="line">MultiplayerSessionsSubsystem-&gt;<span class="built_in">CreateSession</span>(NumPublicConnections, MatchType);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMenu::JoinButtonClicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*if (GEngine) &#123;</span></span><br><span class="line"><span class="comment">GEngine-&gt;AddOnScreenDebugMessage(</span></span><br><span class="line"><span class="comment">-1,</span></span><br><span class="line"><span class="comment">15.f,</span></span><br><span class="line"><span class="comment">FColor::Yellow,</span></span><br><span class="line"><span class="comment">FString(TEXT(&quot;Join Button Clicked&quot;))</span></span><br><span class="line"><span class="comment">);</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line">JoinButton-&gt;<span class="built_in">SetIsEnabled</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (MultiplayerSessionsSubsystem) &#123;</span><br><span class="line">MultiplayerSessionsSubsystem-&gt;<span class="built_in">FindSessions</span>(<span class="number">10000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (GEngine) &#123;</span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(</span><br><span class="line"><span class="number">-1</span>,</span><br><span class="line"><span class="number">15.f</span>,</span><br><span class="line">FColor::Yellow,</span><br><span class="line"><span class="built_in">FString</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;MultiplayerSessionsSubsystem not found!&quot;</span>))</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMenu::MenuTearDown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">RemoveFromParent</span>();</span><br><span class="line">UWorld* World = <span class="built_in">GetWorld</span>();</span><br><span class="line"><span class="keyword">if</span> (World) &#123;</span><br><span class="line">APlayerController* PlayerController = World-&gt;<span class="built_in">GetFirstPlayerController</span>();</span><br><span class="line"><span class="keyword">if</span> (PlayerController) &#123;</span><br><span class="line">FInputModeGameOnly InputModeData;</span><br><span class="line">PlayerController-&gt;<span class="built_in">SetInputMode</span>(InputModeData);</span><br><span class="line">PlayerController-&gt;<span class="built_in">SetShowMouseCursor</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【UE5】GAS学习记录 —— 入门</title>
      <link href="/undefined/9d1c9e1.html"/>
      <url>/undefined/9d1c9e1.html</url>
      
        <content type="html"><![CDATA[<h1 id="【UE5】GAS学习记录-——-入门"><a href="#【UE5】GAS学习记录-——-入门" class="headerlink" title="【UE5】GAS学习记录 —— 入门"></a>【UE5】GAS学习记录 —— 入门</h1><blockquote><p>视频教程：<a href="https://www.bilibili.com/video/BV1Jx4y1Z7ig/，根据自己的理解和想法进行了一定优化和更改。">https://www.bilibili.com/video/BV1Jx4y1Z7ig/，根据自己的理解和想法进行了一定优化和更改。</a></p><p>本文主要聚焦于GAS框架下内容的学习记录，项目中其它内容，如敌人AI、动画、UI等不进行详细描述。</p></blockquote><h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1.基础知识"></a>1.基础知识</h2><p>目前UE引擎已经支持直接为Actor添加能力系统组件，比以前方便了很多。通过GAS系统，我们可以用更加合理和方便的方法去实现角色的各种能力（攻击，技能等）以及属性（生命，魔法等），包括各种技能的消耗、冷却、使用条件等。</p><p>想要使用GAS组件，需要先开启Gameplay Abilities插件。</p><p><img src="/undefined/9d1c9e1/image-20250526144722909.png" alt="image-20250526144722909"></p><h2 id="2-普攻"><a href="#2-普攻" class="headerlink" title="2.普攻"></a>2.普攻</h2><p>这里将普攻视作一个技能实现来对GAS系统进行初步的了解。</p><h3 id="2-1-创建技能"><a href="#2-1-创建技能" class="headerlink" title="2.1 创建技能"></a>2.1 创建技能</h3><p>首先要做的，就是创建Gameplay技能蓝图“普攻”。</p><p><img src="/undefined/9d1c9e1/image-20250521175253219.png" alt="image-20250521175253219"></p><p>因为普攻是玩家角色和敌人角色都有的能力，所以将其调用在角色基类中实现。在BeginPlay函数中将普攻技能给予角色，并且创建一个普攻函数，当调用这个函数时就激活普攻技能。</p><p><img src="/undefined/9d1c9e1/image-20250521175535399.png" alt="image-20250521175535399"></p><p>这里将激活能力写成了一个函数，具体逻辑如下：根据函数传入的参数来访问GameplayTagContainer数组（角色的一个成员变量）的对应索引，得到了GameplayTagContainer，通过能力系统的Try Activate Abilities by Tag节点来激活相应的能力。</p><p><img src="/undefined/9d1c9e1/image-20250521180719968.png" alt="image-20250521180719968"></p><p>通过Tag访问能力是一个重要的特性，我们可以为技能蓝图设定标签，标签是全局可见的，接下来就可以在任何地方通过标签来指定想要使用或修改的能力。</p><p><img src="/undefined/9d1c9e1/image-20250521181347914.png" alt="image-20250521181347914"></p><p>比如我们将角色的GameplayTagContainer数组加上一个Ability.Melee的值，之后通过这个标签来激活技能。</p><p><img src="/undefined/9d1c9e1/image-20250521181526215.png" alt="image-20250521181526215"></p><p>普攻技能的逻辑如下图：普攻的动画蒙太奇中有两个片段，激活技能时随机播放一个。</p><p><img src="/undefined/9d1c9e1/image-20250521175635109.png" alt="image-20250521175635109"></p><p>上图中有一个提交技能冷却的部分，接下来讲解技能的冷却是如何实现的。</p><p>技能蓝图中有许多这个技能的属性，冷却就包含在其中，它和其它许多技能属性一样，是通过技能效果来实现的。</p><p><img src="/undefined/9d1c9e1/image-20250521180109925.png" alt="image-20250521180109925"></p><p>创建GameplayEffect，命名为GE_Melee_CD，为其添加持续时间，并添加用标签阻止能力的效果。</p><p><img src="/undefined/9d1c9e1/image-20250521180509255.png" alt="image-20250521180509255"></p><p>这样一来，技能就有了0.5秒的CD。</p><h3 id="2-2-实现普攻逻辑"><a href="#2-2-实现普攻逻辑" class="headerlink" title="2.2 实现普攻逻辑"></a>2.2 实现普攻逻辑</h3><p>这里通过胶囊体检测来实现普攻的检测。</p><p>为角色添加胶囊体，将其附着在角色的武器插槽上，并调整大小为武器大小。</p><p><img src="/undefined/9d1c9e1/image-20250521181918810.png" alt="image-20250521181918810"></p><p>因为我们只需要胶囊体在角色攻击时进行检测，所以默认情况下将碰撞全部设置为忽略。</p><p><img src="/undefined/9d1c9e1/image-20250521182235658.png" alt="image-20250521182235658"></p><p>在动画蒙太奇中想进行检测的部分添加通知AttackStart和AttackEnd。</p><p><img src="/undefined/9d1c9e1/image-20250521182321125.png" alt="image-20250521182321125"></p><p>在攻击开始后设置碰撞检测，攻击结束后改为忽略碰撞。</p><p><img src="/undefined/9d1c9e1/image-20250521182342962.png" alt="image-20250521182342962"></p><p>检测到碰撞后先检测是不是自己（防止自己打到自己）或者和自己相同类的角色（防止敌人之间互相攻击，如果想要敌人之间误伤就不需要判断），如果都不是，就对敌人造成伤害。</p><p><img src="/undefined/9d1c9e1/image-20250521182114483.png" alt="image-20250521182114483"></p><p>造成伤害这部分也是通过GAS来实现的，下一部分将进行讲解。</p><h3 id="2-3-角色属性"><a href="#2-3-角色属性" class="headerlink" title="2.3 角色属性"></a>2.3 角色属性</h3><p>除了实现各种技能外，GAS也可以方便地实现角色属性的计算，包括计算防御后的伤害等。</p><p>首先创建一个属性集类，在里面定义一系列属性。</p><p><img src="/undefined/9d1c9e1/image-20250521184333875.png" alt="image-20250521184333875"></p><p>注意这里使用了辅助宏，可以为每个属性自动生成初始化方法，并用数据表来初始化这些数据。</p><p>创建一个数据表来初始化这些数据。</p><p><img src="/undefined/9d1c9e1/image-20250521184720719.png" alt="image-20250521184720719"></p><p>在角色的能力系统组件中就可以用这个数据表来进行角色属性的初始化。</p><p><img src="/undefined/9d1c9e1/image-20250521184923697.png" alt="image-20250521184923697"></p><p>接下来创建一个普攻的GameplayEffect，在普攻检测处对攻击对象应用这个技能效果即可</p><p><img src="/undefined/9d1c9e1/image-20250521185754171.png" alt="image-20250521185754171"></p><p><img src="/undefined/9d1c9e1/image-20250521185841216.png" alt="image-20250521185841216"></p><p>这里可能存在伤害溢出的问题，可以使用辅助宏提供的函数来解决。</p><p><img src="/undefined/9d1c9e1/image-20250521191940816.png" alt="image-20250521191940816"></p><h3 id="2-4-伤害配表"><a href="#2-4-伤害配表" class="headerlink" title="2.4 伤害配表"></a>2.4 伤害配表</h3><p>战斗策划可以通过csv表的方式快速填写数值</p><p><img src="/undefined/9d1c9e1/image-20250522145813594.png" alt="image-20250522145813594"></p><p>导入表格</p><p><img src="/undefined/9d1c9e1/image-20250522150043277.png" alt="image-20250522150043277"></p><p>就可以在伤害的技能效果里直接应用了</p><p><img src="/undefined/9d1c9e1/image-20250522150356042.png" alt="image-20250522150356042"></p><p>如果原表发生修改，可以直接通过重新导入来更新数据表</p><p><img src="/undefined/9d1c9e1/image-20250522150457421.png" alt="image-20250522150457421"></p><p>这样，在应用伤害效果处就可以指定不同的等级来造成不同的伤害了</p><p><img src="/undefined/9d1c9e1/image-20250522150558134.png" alt="image-20250522150558134"></p><h2 id="3-生命条和技能信息结构体"><a href="#3-生命条和技能信息结构体" class="headerlink" title="3.生命条和技能信息结构体"></a>3.生命条和技能信息结构体</h2><h3 id="3-1-生命条（委托机制）"><a href="#3-1-生命条（委托机制）" class="headerlink" title="3.1 生命条（委托机制）"></a>3.1 生命条（委托机制）</h3><p>游戏中需要显示敌人或玩家角色的生命条，而获取生命变动属性的方法是委托。</p><p>首先定义一个OnHealthAttributeChanged函数，参数是FOnAttributeChangeData。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当HP属性变化时触发的回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnHealthAttributeChanged</span><span class="params">(<span class="type">const</span> FOnAttributeChangeData&amp; Data)</span></span>;</span><br></pre></td></tr></table></figure><p>获取到角色的能力系统组件，将这个函数绑定到能力系统组件下的属性值变化的委托，这样当角色的生命值发生变化时会自动调用OnHealthAttributeChanged函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ABaseCharacter::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line">TObjectPtr&lt;UAbilitySystemComponent&gt; MyAbilityStystemComponent = <span class="keyword">this</span>-&gt;<span class="built_in">FindComponentByClass</span>&lt;UAbilitySystemComponent&gt;();</span><br><span class="line"><span class="keyword">if</span> (MyAbilityStystemComponent) &#123;</span><br><span class="line"><span class="comment">//将OnHealthAttributeChanged函数绑定到属性值变化的委托</span></span><br><span class="line">MyAbilityStystemComponent-&gt;<span class="built_in">GetGameplayAttributeValueChangeDelegate</span>(UBaseAttributeSet::<span class="built_in">GetHPAttribute</span>()).<span class="built_in">AddUObject</span>(<span class="keyword">this</span>, &amp;ABaseCharacter::OnHealthAttributeChanged);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在BaseCharacter中定义一个多态多播委托（一个参数）,并声明相应的事件HPChangeEvent。当OnHealthAttributeChanged函数函数被调用时，广播这个事件，所有绑定了这个事件的函数都会被调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明动态多播委托，用于广播生命值变化事件（参数为新生命值）</span></span><br><span class="line"><span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam</span>(FOnHealthChangeEvent, <span class="type">float</span>, NewValue);</span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GAS_API</span> ABaseCharacter : <span class="keyword">public</span> ACharacter</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">...</span><br><span class="line"><span class="comment">//声明HP值变化的事件</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintAssignable, Category = <span class="string">&quot;Ability&quot;</span>)</span><br><span class="line">FOnHealthChangeEvent HPChangeEvent;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnHealthAttributeChanged</span><span class="params">(<span class="type">const</span> FOnAttributeChangeData&amp; Data)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void ABaseCharacter::OnHealthAttributeChanged(const FOnAttributeChangeData&amp; Data)</span><br><span class="line">&#123;</span><br><span class="line">// 当HP变化时，广播事件（参数为新值）</span><br><span class="line">HPChangeEvent.Broadcast(Data.NewValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，当HP值变化时，会自动调用绑定了HPChangeEvent事件的函数，用于实现血量变化相关的功能，如设置敌人和玩家的血条等。</p><p><img src="/undefined/9d1c9e1/image-20250524171249486.png" alt="image-20250524171249486"></p><p><img src="/undefined/9d1c9e1/image-20250524171334718.png" alt="image-20250524171334718"></p><h3 id="3-2-构建技能信息结构体"><a href="#3-2-构建技能信息结构体" class="headerlink" title="3.2 构建技能信息结构体"></a>3.2 构建技能信息结构体</h3><p>有时候我们需要获取技能的各种信息（CD，消耗等）来进行一些处理，因此需要构建一个技能信息结构体来存储这些信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//枚举，技能消耗的类型</span></span><br><span class="line"><span class="built_in">UENUM</span>(BlueprintType)</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">ECostType</span> :uint8</span><br><span class="line">&#123;</span><br><span class="line">HP,</span><br><span class="line">SP,</span><br><span class="line">MP</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//技能信息的结构体</span></span><br><span class="line"><span class="built_in">USTRUCT</span>(BlueprintType)</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FGameplayAbilityInfo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category = <span class="string">&quot;AbilityInfo&quot;</span>)</span><br><span class="line"><span class="type">float</span> CD; <span class="comment">//技能CD</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category = <span class="string">&quot;AbilityInfo&quot;</span>)</span><br><span class="line">ECostType CostType; <span class="comment">//消耗类型</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category = <span class="string">&quot;AbilityInfo&quot;</span>)</span><br><span class="line"><span class="type">float</span> CostValue; <span class="comment">//消耗值</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category = <span class="string">&quot;AbilityInfo&quot;</span>)</span><br><span class="line">UMaterialInstance* IconMaterial; <span class="comment">//图标材质</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category = <span class="string">&quot;AbilityInfo&quot;</span>)</span><br><span class="line">TSubclassOf&lt;UBaseGameplayAbility&gt; AbilityClass; <span class="comment">//技能类</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">FGameplayAbilityInfo</span>(); <span class="comment">//默认构造函数</span></span><br><span class="line"><span class="built_in">FGameplayAbilityInfo</span>(<span class="type">float</span> CD, ECostType CostType, <span class="type">float</span> CostValue, UMaterialInstance* IconMaterial, TSubclassOf&lt;UBaseGameplayAbility&gt; AbilityClass); <span class="comment">//带参构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GAS_API</span> UBaseGameplayAbility : <span class="keyword">public</span> UGameplayAbility</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//图片材质在编辑器中直接指定</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category = <span class="string">&quot;AbilityInfo&quot;</span>)</span><br><span class="line">UMaterialInstance* IconMaterial;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口函数，用于获取技能信息</span></span><br><span class="line"><span class="function">FGameplayAbilityInfo <span class="title">GetAbilityInfo</span><span class="params">(<span class="type">int</span> level)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中的技能图标材质是主UI中用到的图标材质。</p><p>构造函数和接口函数定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">FGameplayAbilityInfo::<span class="built_in">FGameplayAbilityInfo</span>():<span class="built_in">CD</span>(<span class="number">0</span>),<span class="built_in">CostType</span>(ECostType::MP),<span class="built_in">CostValue</span>(<span class="number">0</span>),<span class="built_in">IconMaterial</span>(<span class="literal">nullptr</span>),<span class="built_in">AbilityClass</span>(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FGameplayAbilityInfo::<span class="built_in">FGameplayAbilityInfo</span>(<span class="type">float</span> CD, ECostType CostType, <span class="type">float</span> CostValue, UMaterialInstance* IconMaterial, TSubclassOf&lt;UBaseGameplayAbility&gt; AbilityClass):</span><br><span class="line"><span class="built_in">CD</span>(CD), <span class="built_in">CostType</span>(CostType), <span class="built_in">CostValue</span>(CostValue), <span class="built_in">IconMaterial</span>(IconMaterial), <span class="built_in">AbilityClass</span>(AbilityClass)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FGameplayAbilityInfo <span class="title">UBaseGameplayAbility::GetAbilityInfo</span><span class="params">(<span class="type">int</span> level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//获得冷却技能效果</span></span><br><span class="line">UGameplayEffect* CDEffect = <span class="built_in">GetCooldownGameplayEffect</span>();</span><br><span class="line"><span class="comment">//获得消耗技能效果</span></span><br><span class="line">UGameplayEffect* CostEffect = <span class="built_in">GetCostGameplayEffect</span>();</span><br><span class="line"><span class="type">float</span> CD = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> CostValue = <span class="number">0</span>;</span><br><span class="line">ECostType CostType = ECostType::MP;</span><br><span class="line"><span class="keyword">if</span> (CDEffect &amp;&amp; CostEffect) &#123;</span><br><span class="line"><span class="comment">//通过冷却技能效果获得技能CD</span></span><br><span class="line">CDEffect-&gt;DurationMagnitude.<span class="built_in">GetStaticMagnitudeIfPossible</span>(level, CD);</span><br><span class="line"><span class="comment">//通过消耗技能效果获得技能消耗</span></span><br><span class="line"><span class="keyword">if</span> (CostEffect-&gt;Modifiers.<span class="built_in">Num</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//获得消耗技能效果的第一个修饰器</span></span><br><span class="line">FGameplayModifierInfo CostEffectModifierInfo = CostEffect-&gt;Modifiers[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//获得消耗值</span></span><br><span class="line">CostEffectModifierInfo.ModifierMagnitude.<span class="built_in">GetStaticMagnitudeIfPossible</span>(level, CostValue);</span><br><span class="line"><span class="comment">//通过获得的消耗类型名称来确定结构体中的消耗类型</span></span><br><span class="line">FString CostTypeName = CostEffectModifierInfo.Attribute.AttributeName;</span><br><span class="line"><span class="keyword">if</span> (CostTypeName == <span class="string">&quot;HP&quot;</span>) &#123;</span><br><span class="line">CostType = ECostType::HP;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (CostTypeName == <span class="string">&quot;MP&quot;</span>) &#123;</span><br><span class="line">CostType = ECostType::MP;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (CostTypeName == <span class="string">&quot;SP&quot;</span>) &#123;</span><br><span class="line">CostType = ECostType::SP;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回技能信息结构体</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">FGameplayAbilityInfo</span>(CD, CostType, CostValue, IconMaterial, <span class="built_in">GetClass</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">FGameplayAbilityInfo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在角色类中定义获取技能信息的接口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FGameplayAbilityInfo <span class="title">ABaseCharacter::GameplayAbilityInfo</span><span class="params">(TSubclassOf&lt;UBaseGameplayAbility&gt; AbilityClass, <span class="type">int</span> level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">UAbilitySystemComponent* MyAbilitySystemComponent = <span class="keyword">this</span>-&gt;<span class="built_in">FindComponentByClass</span>&lt;UAbilitySystemComponent&gt;(); <span class="comment">//获取能力系统组件</span></span><br><span class="line">UBaseGameplayAbility* AbilityInstance = AbilityClass-&gt;<span class="built_in">GetDefaultObject</span>&lt;UBaseGameplayAbility&gt;(); <span class="comment">//获取技能实例</span></span><br><span class="line"><span class="keyword">if</span> (MyAbilitySystemComponent &amp;&amp; AbilityInstance) &#123;</span><br><span class="line"><span class="comment">//通过角色能力类中的接口获取技能信息</span></span><br><span class="line"><span class="keyword">return</span> AbilityInstance-&gt;<span class="built_in">GetAbilityInfo</span>(level);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">FGameplayAbilityInfo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使所有的技能都继承自BaseGameplayAbility类，这样就可以直接通过角色来获取技能信息了。</p><h2 id="4-技能1-回血（制作技能的基本流程）"><a href="#4-技能1-回血（制作技能的基本流程）" class="headerlink" title="4.技能1 回血（制作技能的基本流程）"></a>4.技能1 回血（制作技能的基本流程）</h2><p>在完成了上面一系列基础框架的搭建后，制作（简单的）技能就是一件简单的事了。这里用回血这个最简单的技能来过一遍制作技能的流程。</p><p>首先创建回血技能，<strong>创建后要设定其Tag，它是GAS系统中用于各处通信的十分重要且方便的方法</strong>。</p><p><img src="/undefined/9d1c9e1/image-20250525162157021.png" alt="image-20250525162157021"></p><p>绑定操作键。这里用1键来触发技能，调用角色的ActivateAbility函数。</p><p><img src="/undefined/9d1c9e1/image-20250525003743789.png" alt="image-20250525003743789"></p><p>ActivateAbility函数的逻辑在实现普攻的时候有介绍。需要注意，在实现普攻技能时是在基类调用的这个函数，其中的GameplayTagContainer数组只有一个默认值Ability.Melee，而回血技能是玩家独有的能力，因此在调用继承而来的ActivateAbility函数之前要先赋予玩家技能并将Ability.HPRegen Tag添加到玩家角色类继承而来的GameplayTagContainer数组中。</p><p><img src="/undefined/9d1c9e1/image-20250525004212859.png" alt="image-20250525004212859"></p><p>玩家角色有一个技能类的数组，BeginPlay函数中会遍历这个数组并根据技能类将数组中的技能都赋予玩家。</p><p><img src="/undefined/9d1c9e1/image-20250525004336651.png" alt="image-20250525004336651"></p><p>在赋予玩家技能的同时会执行UI的初始化，大致功能为初始化UI中技能插槽所需要的CD、技能图标等信息，这里不具体展示。</p><p>作为一个简单的技能，回血技能有三个效果：</p><p><strong>回血效果</strong>。恢复玩家的生命值。通过一个修饰符实现。</p><p><img src="/undefined/9d1c9e1/image-20250525005203364.png" alt="image-20250525005203364"></p><p><strong>消耗效果</strong>。这个技能会消耗MP。通过一个修饰符实现。</p><p><img src="/undefined/9d1c9e1/image-20250525005253692.png" alt="image-20250525005253692"></p><p><strong>冷却效果</strong>。这个技能有一定的冷却时间。通过一个组件实现。</p><p><img src="/undefined/9d1c9e1/image-20250525005422423.png" alt="image-20250525005422423"></p><p>与此同时，这个技能会有一个特效。可以通过Gameplay提示通知来实现。</p><p><img src="/undefined/9d1c9e1/image-20250525005623324.png" alt="image-20250525005623324"></p><p>在消耗MP的Gameplay效果处可以加上这个提示通知，当修改器成功时就会显示特效了。</p><p><img src="/undefined/9d1c9e1/image-20250525005659223.png" alt="image-20250525005659223"></p><p>最后时技能主体的实现。通过CommitAbility节点提交选定的消耗效果和冷却效果，然后对技能拥有者应用回血效果，播放动画蒙太奇，调用UI进入CD的函数，之后技能结束。</p><p><img src="/undefined/9d1c9e1/image-20250525005826141.png" alt="image-20250525005826141"></p><h2 id="5-技能2-冲刺（通过事件触发技能效果）"><a href="#5-技能2-冲刺（通过事件触发技能效果）" class="headerlink" title="5.技能2 冲刺（通过事件触发技能效果）"></a>5.技能2 冲刺（通过事件触发技能效果）</h2><p>首先依旧是上面的流程，绑定输入，添加技能到玩家的技能类数组和GameplayTagContainer数组，创建技能蓝图，消耗效果和冷却效果。</p><p>冲刺技能的效果是进行冲刺，并对路径上的敌人造成伤害、击飞和眩晕效果。因此玩家需要一个球体触发器来检测击中的敌人。在游戏开始时可以将触发器对Pawn的碰撞响应设置为忽略。</p><p><img src="/undefined/9d1c9e1/image-20250525155300862.png" alt="image-20250525155300862"></p><p>技能对于玩家角色本身的基本逻辑包括将角色的地面摩擦力设为0、将玩家胶囊体对Pawn的碰撞设为忽略（使玩家冲刺时可以穿过敌人）、清空存储碰撞到的敌人的数组、将球体触发器对Pawn的碰撞响应设置为重叠、对玩家施加一个向前的冲击力、播放动画蒙太奇。</p><p><img src="/undefined/9d1c9e1/image-20250525155629568.png" alt="image-20250525155629568"></p><p>球体碰撞检测的逻辑如下，大致为当检测到Actor后尝试转换为敌人，转换成功后检查是否在敌人数组中（防止对同一个敌人重复触发），然后对检测到的敌人执行相应的逻辑。</p><p><img src="/undefined/9d1c9e1/image-20250525160237539.png" alt="image-20250525160237539"></p><p>需要注意的是，这里可以直接对检测到的敌人进行应用伤害效果、击飞、眩晕的效果，但是<strong>技能效果的实现最好都在技能蓝图中去完成，从而防止GAS框架的解耦</strong>。这里实现将对检测到的敌人执行一些操作的功能转移到技能蓝图中的方法是GameplayEnent。当检测到敌人后，我们向玩家发送一个Gameplay事件，包含事件的Tag和一个负载，负载包括了事件的发起者和目标Actor等信息。</p><p>在播放蓝图的同时，技能蓝图中会开始监听带有这个Tag的事件。当接收到事件后就可以对负载中的敌人Actor进行相应的操作（伤害、击飞、眩晕）。</p><p><img src="/undefined/9d1c9e1/image-20250525161822646.png" alt="image-20250525161822646"></p><p>当蒙太奇播放完成后技能也就释放完成了，需要恢复玩家的地面摩擦力、将球体触发器对Pawn的碰撞检测设为忽略，最后结束碰撞。</p><p><img src="/undefined/9d1c9e1/image-20250525162308751.png" alt="image-20250525162308751"></p><h2 id="6-技能3-激光（持续性技能）"><a href="#6-技能3-激光（持续性技能）" class="headerlink" title="6.技能3 激光（持续性技能）"></a>6.技能3 激光（持续性技能）</h2><h3 id="6-1-技能实现"><a href="#6-1-技能实现" class="headerlink" title="6.1 技能实现"></a>6.1 技能实现</h3><p>作为一个持续技能，激光在可以持续对敌人造成伤害的同时也会持续消耗MP，当MP耗尽时需要取消技能。</p><p>创建技能的流程和之前相同，需要注意的是，这个技能的消耗效果是永久存在的，并且有生效周期。</p><p><img src="/undefined/9d1c9e1/image-20250525193410557.png" alt="image-20250525193410557"></p><p>在绑定输入操作时需要根据当前是否正在释放激光技能来决定是激活技能还是取消技能。这里取消技能是通过调用角色的事件实现的。</p><p><img src="/undefined/9d1c9e1/image-20250525193610672.png" alt="image-20250525193610672"></p><p>激活技能后将角色的ED_CancelLaser事件绑定到取消技能节点，然后提交技能消耗，这里没有提交技能冷却，因为通常这种技能都是当技能结束才开始计算CD的。接下来就是将bLasering的值设为true，并播放动画蒙太奇。</p><p><img src="/undefined/9d1c9e1/image-20250525194645354.png" alt="image-20250525194645354"></p><p>动画有一个抬手动作，因此播放动画蒙太奇后要延迟0.5秒，然后将角色的朝向锁定到摄像机朝向（玩家角色的成员函数），接下来生成激光Actor并附着到玩家上。</p><p><img src="/undefined/9d1c9e1/image-20250525195218375.png" alt="image-20250525195218375"></p><p>激光Actor是用来实现激光技能的一个Actor。它实现了激光外形的表现和攻击敌人的功能的实现。</p><p><img src="/undefined/9d1c9e1/image-20250525195731665.png" alt="image-20250525195731665"></p><p>激光在射到敌人或其它物体时会被挡住，这里在实现这个功能时用了一个取巧的方法：在激光Actor上附着一个摄像机臂，并开启碰撞测试，摄像机臂在碰到物体时会自动缩短，在摄像机臂的终点附着一个球形触发器，就可以通过触发器得到激光正在接触的物体；于此同时，在动画蓝图中获得球形触发器的位置并将激光骨骼网格体的End骨骼缩放到触发器位置，就可以实现激光在外形上的长度变化。</p><p><img src="/undefined/9d1c9e1/image-20250525200228460.png" alt="image-20250525200228460"></p><p><img src="/undefined/9d1c9e1/image-20250525200243010.png" alt="image-20250525200243010"></p><p>在激光Actor中设置每0.25秒调用LaserEffect事件，将获取到的击中的敌人数组转换为Target Data并作为负载，发送GameplayEvent。</p><p><img src="/undefined/9d1c9e1/image-20250525200405601.png" alt="image-20250525200405601"></p><p>当球形触发器接触到敌人时将其加入数组，不再重叠时将其移出数组。</p><p><img src="/undefined/9d1c9e1/image-20250525200914503.png" alt="image-20250525200914503"></p><p>继续技能蓝图的编写。接收到事件后判断能量（或者其它类型的消耗）是否足够，如果不够就直接取消技能，否则就对负载中的敌人数组应用技能效果，并遍历数组对每个敌人应用眩晕和击飞效果。</p><p><img src="/undefined/9d1c9e1/image-20250525201130269.png" alt="image-20250525201130269"></p><h3 id="6-2-技能之间的互相打断"><a href="#6-2-技能之间的互相打断" class="headerlink" title="6.2 技能之间的互相打断"></a>6.2 技能之间的互相打断</h3><p><strong>技能有可以被打断和不能被打断之分，这里可以通过标签来实现</strong>。将技能基类中“取消带标签的能力”标签设为所有技能的根标签，这样执行任意一个技能都会取消正在执行的技能。</p><p><img src="/undefined/9d1c9e1/image-20250525201615447.png" alt="image-20250525201615447"></p><p>对于不能被打断的技能，如冲刺技能，则可以将“激活阻止标签”设为所有技能的根标签，这样当前技能被激活时该标签下除了自身以外的其它技能都不会被激活。这个功能的优先级比“取消带标签的能力”功能的优先级高，通过这两个功能可以轻松设定技能之间的打断关系。</p><p><img src="/undefined/9d1c9e1/image-20250525201813517.png" alt="image-20250525201813517"></p><h2 id="7-技能4-爆裂（选取范围并确认）"><a href="#7-技能4-爆裂（选取范围并确认）" class="headerlink" title="7.技能4 爆裂（选取范围并确认）"></a>7.技能4 爆裂（选取范围并确认）</h2><p>这个技能的主要特点是：按下后会进行范围选取，可以按左键释放技能击飞范围里的敌人或者按右键。</p><p>先写一个类用于选取地面上的目标。</p><p>（这部分有点复杂，我也还在消化）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GAS_API</span> AGroundSelectTargetActor : <span class="keyword">public</span> AGameplayAbilityTargetActor</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//重写StartTargeting方法，初始化目标选择逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">StartTargeting</span><span class="params">(UGameplayAbility* Ability)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写ConfirmTargetingAndContinue方法，确定目标并广播结果</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ConfirmTargetingAndContinue</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, meta = (ExposeOnSpawn = <span class="string">&quot;true&quot;</span>), Category = <span class="string">&quot;GroundSelect&quot;</span>)</span><br><span class="line"><span class="type">float</span> SelectRadius;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取玩家的视角击中点</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;GroundSelect&quot;</span>)</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetPlayerLookAtPoint</span><span class="params">(FVector&amp; Out_LookPoint)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Abilities/GameplayAbility.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Abilities/GameplayAbilityTargetActor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Engine/OverlapResult.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GroundSelectTargetActor.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AGroundSelectTargetActor::StartTargeting</span><span class="params">(UGameplayAbility* Ability)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">StartTargeting</span>(Ability);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取玩家控制器</span></span><br><span class="line">PrimaryPC = <span class="built_in">Cast</span>&lt;APlayerController&gt;(Ability-&gt;<span class="built_in">GetOwningActorFromActorInfo</span>()-&gt;<span class="built_in">GetInstigatorController</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AGroundSelectTargetActor::ConfirmTargetingAndContinue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FVector LookPoint; <span class="comment">//用于存储玩家的视角击中点</span></span><br><span class="line"><span class="comment">//计算玩家的视角击中点</span></span><br><span class="line"><span class="built_in">GetPlayerLookAtPoint</span>(LookPoint); </span><br><span class="line">TArray&lt;FOverlapResult&gt; OverlapResults; <span class="comment">//存储与选择范围重叠的物体</span></span><br><span class="line">TArray&lt;TWeakObjectPtr&lt;AActor&gt;&gt; OverlapActors; <span class="comment">//存储重叠的敌人</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置碰撞查询参数</span></span><br><span class="line">FCollisionQueryParams QueryParms;</span><br><span class="line">QueryParms.bTraceComplex = <span class="literal">false</span>;</span><br><span class="line">QueryParms.bReturnPhysicalMaterial = <span class="literal">false</span>;</span><br><span class="line">APawn* SelfPawn = PrimaryPC-&gt;<span class="built_in">GetPawn</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果角色存在，将其添加到忽略列表</span></span><br><span class="line"><span class="keyword">if</span> (SelfPawn) &#123;</span><br><span class="line">QueryParms.<span class="built_in">AddIgnoredActor</span>(SelfPawn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行碰撞查询，查找与选择范围重叠的物体</span></span><br><span class="line"><span class="type">bool</span> QueryResult = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">OverlapMultiByObjectType</span>(OverlapResults, LookPoint, FQuat::Identity, <span class="built_in">FCollisionObjectQueryParams</span>(ECollisionChannel::ECC_Pawn), FCollisionShape::<span class="built_in">MakeSphere</span>(SelectRadius), QueryParms);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果查询成功，遍历查询结果，尝试将重叠物体转换为敌人角色，如果转换成功且敌人未被添加到OverlapActors，将敌人添加到OverlapActors</span></span><br><span class="line"><span class="keyword">if</span> (QueryResult)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; OverlapResults.<span class="built_in">Num</span>();i++) &#123;</span><br><span class="line">APawn* Enemy = <span class="built_in">Cast</span>&lt;APawn&gt;(OverlapResults[i].<span class="built_in">GetActor</span>());</span><br><span class="line"><span class="keyword">if</span> (Enemy &amp;&amp; !OverlapActors.<span class="built_in">Contains</span>(Enemy)) &#123;</span><br><span class="line">OverlapActors.<span class="built_in">Add</span>(Enemy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FGameplayAbilityTargetDataHandle TargetDataHandle; <span class="comment">//创建目标数据句柄</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建中心位置目标数据</span></span><br><span class="line">FGameplayAbilityTargetData_LocationInfo* CenterLoc = <span class="keyword">new</span> <span class="built_in">FGameplayAbilityTargetData_LocationInfo</span>(); </span><br><span class="line">CenterLoc-&gt;TargetLocation.LiteralTransform = <span class="built_in">FTransform</span>(LookPoint); </span><br><span class="line">CenterLoc-&gt;TargetLocation.LocationType = EGameplayAbilityTargetingLocationType::LiteralTransform;</span><br><span class="line"></span><br><span class="line">TargetDataHandle.<span class="built_in">Add</span>(CenterLoc); <span class="comment">//将中心位置目标数据添加到目标数据句柄</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果有重叠的敌人，创建敌人数组目标数据，将敌人数组目标数据添加到目标数据句柄</span></span><br><span class="line"><span class="keyword">if</span>(OverlapActors.<span class="built_in">Num</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">FGameplayAbilityTargetData_ActorArray* ActorArray = <span class="keyword">new</span> <span class="built_in">FGameplayAbilityTargetData_ActorArray</span>();</span><br><span class="line">ActorArray-&gt;<span class="built_in">SetActors</span>(OverlapActors);</span><br><span class="line">TargetDataHandle.<span class="built_in">Add</span>(ActorArray);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">check</span>(<span class="built_in">ShouldProduceTargetData</span>()); <span class="comment">//检查是否应该生成目标数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果允许确认目标，广播目标数据</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IsConfirmTargetingAllowed</span>()) &#123;</span><br><span class="line">TargetDataReadyDelegate.<span class="built_in">Broadcast</span>(TargetDataHandle);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AGroundSelectTargetActor::GetPlayerLookAtPoint</span><span class="params">(FVector&amp; Out_LookPoint)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//玩家的视角位置和旋转</span></span><br><span class="line">FVector ViewLoc;</span><br><span class="line">FRotator ViewRot;</span><br><span class="line"><span class="comment">//获取玩家的视角位置和旋转</span></span><br><span class="line">PrimaryPC-&gt;<span class="built_in">GetPlayerViewPoint</span>(ViewLoc, ViewRot);</span><br><span class="line"></span><br><span class="line">FHitResult HitResult; <span class="comment">//存储碰撞结果</span></span><br><span class="line"><span class="comment">//设置碰撞查询参数</span></span><br><span class="line">FCollisionQueryParams QueryParms; </span><br><span class="line">QueryParms.bTraceComplex = <span class="literal">true</span>;</span><br><span class="line">APawn* SelfPawn = PrimaryPC-&gt;<span class="built_in">GetPawn</span>(); <span class="comment">//获取玩家控制的角色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果角色存在，将其添加到忽略列表</span></span><br><span class="line"><span class="keyword">if</span> (SelfPawn) &#123;</span><br><span class="line">QueryParms.<span class="built_in">AddIgnoredActor</span>(SelfPawn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行射线检测，计算玩家的视角击中点</span></span><br><span class="line"><span class="type">bool</span> TraceResult = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">LineTraceSingleByChannel</span>(HitResult, ViewLoc, ViewLoc + ViewRot.<span class="built_in">Vector</span>() * <span class="number">5000.0f</span>, ECollisionChannel::ECC_Visibility, QueryParms);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果检测到碰撞，就获取碰撞点并返回检测结果</span></span><br><span class="line"><span class="keyword">if</span> (TraceResult) &#123;</span><br><span class="line">Out_LookPoint = HitResult.ImpactPoint;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TraceResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建技能，技能消耗，技能冷却等……</p><p>激活技能后判断消耗是否足够，如果不够就之间结束技能，否则进入选取范围状态。</p><p>技能结束后记得解除摄像机锁定并设正在选取状态的布尔值为false。</p><p><img src="/undefined/9d1c9e1/image-20250526100122842.png" alt="image-20250526100122842"></p><p>在角色控制器中设置右键取消目标，而左键需要判断bReadyToBlast变量是否为真，为真则确认目标，否则进行普攻。</p><p><img src="/undefined/9d1c9e1/image-20250526100523814.png" alt="image-20250526100523814"></p><p>玩家技能蓝图中会等待目标数据，如果接收到目标取消就结束技能，反之则释放技能。</p><p><img src="/undefined/9d1c9e1/image-20250526100916269.png" alt="image-20250526100916269"></p><p>得到的<strong>目标数据是可以和数组互相转化的</strong>，可以直接对目标数据应用技能效果并对数组中的每个敌人执行击飞和眩晕效果。</p><p><img src="/undefined/9d1c9e1/image-20250526101321870.png" alt="image-20250526101321870"></p><p>完成。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在阅读UE官方文档的时候了解到了这个强大的系统，于是决定停下来花一段时间去了解（虽然现在正是急着拓宽知识面的时间点），学习完入门知识后感觉确实收获颇丰，而且学习过程相当愉快。当我刚决定走向游戏开发这条路的那段时间里会时不时感到恐惧，会想：我真的可能掌握如此繁杂且庞大的知识，成为能独当一面的游戏程序吗？而现在，我已经知道，只要能坚持以这样的热情和毅力去学习，总有一天我也能站在曾经我只能仰望的山巅。</p><p>（虽然但是，秋招没实习怎么办啊）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【游戏不锐评】VA-11 Hall-A Cyberpunk Bartender Action —— 调制饮料，改变人生</title>
      <link href="/undefined/e2faed25.html"/>
      <url>/undefined/e2faed25.html</url>
      
        <content type="html"><![CDATA[<h1 id="【游戏不锐评】VA-11-Hall-A-Cyberpunk-Bartender-Action-——-调制饮料，改变人生"><a href="#【游戏不锐评】VA-11-Hall-A-Cyberpunk-Bartender-Action-——-调制饮料，改变人生" class="headerlink" title="【游戏不锐评】VA-11 Hall-A Cyberpunk Bartender Action —— 调制饮料，改变人生"></a>【游戏不锐评】VA-11 Hall-A Cyberpunk Bartender Action —— 调制饮料，改变人生</h1><p>10/10</p><p>这个游戏唯一的缺点就是太短了。如果可以，我想玩一辈子。</p><h2 id="欢迎来到VA-11-HALL-A"><a href="#欢迎来到VA-11-HALL-A" class="headerlink" title="欢迎来到VA-11 HALL-A"></a>欢迎来到VA-11 HALL-A</h2><p>本作的背景是某个平行世界的207X年。故事发生在罪恶之城Glitch City的贫民窟附近的一家濒临倒闭的酒吧：VA-11 HALL-A中。在这里，我们的主角调酒师Jill一边为各种账单发愁，一边在酒吧倒闭前尽职地进行工作。</p><p><img src="/undefined/e2faed25/20250130005640_1.jpg" alt="20250130005640_1" style="zoom:50%;"></p><p>说起调酒师，我其实并没有去过酒吧，但是从各种文学和影视作品中，调酒师经常给我一种神秘、沉默、总是在侧耳倾听（甚至不知道什么时候会掏出一把枪）的印象。然而在VA11这部作品中，Jill只是一个普通人，有自己的生活、社交和自己的情感。她也有数不清的烦（帐）恼（单），不好的回忆。然而，她也确实擅长倾听客人的心声，和客人分享烦恼或者喜悦，并且成功地和其中的一些客人建立了深切的友情。</p><p>通过制作者的精心设计，在7.5小时的游戏流程过后，Jill已经成为了我最喜欢的女主角之一。夸张点说，也许这款游戏真的拥有改变人生的魔力。</p><p><img src="/undefined/e2faed25/d9ea66e6be2755175a72fb7ffb903bb05c9d14d9280d5c3b5.jpg" alt="d9ea66e6be2755175a72fb7ffb903bb05c9d14d9280d5c3b5" style="zoom:50%;"></p><h2 id="调酒是工作，唠嗑是生活"><a href="#调酒是工作，唠嗑是生活" class="headerlink" title="调酒是工作，唠嗑是生活"></a>调酒是工作，唠嗑是生活</h2><p>回到游戏本身，VA11是一部扮演调酒师，一边给顾客调酒，一边和顾客聊天的游戏。虽然大部分人对VA11的印象是一部剧情游戏，但是在我看来，这种说法只有一部分正确。VA11的主要内容确实是各种人物之间的对话，以及他们发生的故事，但是它的玩法也占了相当大的比重。这里我指的不是玩法本身带来的乐趣，因为只是按照菜单调酒确实没什么意思。然而，制作者将这种玩法完美地融入了剧情之中，使得其成为这款游戏中不可缺少的一部分。如果单纯将VA11制作成一部视觉小说，那它绝对无法达到现在的高度。</p><p>例如，当Miki（一位人造人偶像）向你点了一杯苦味饮料时，你点开苦味饮料的列表，上面有几种饮料供你选择。事实上，无论你选择哪个都不会影响结果，但是当你已经融入游戏时，你会不由自主地考虑她会更喜欢哪一种饮料，在这种情况下，你当然会避开那些火辣、男性化的酒，努力为客人提供最好的服务。这种体验会使玩家更能沉浸在游戏世界中。并且，这种行为也会为你带来回报。有时顾客会陷入消极之中，而如果你能记住他们喜欢的饮料并在正确的时间提供给他们，你就获得和他们加深关系的机会。</p><p>再比如，在游戏中的某一天下班时，我们会邀请老板到家中闲聊，在这个过程中，我们拥有一个按钮，可以让Jill开啤酒、喝啤酒。虽然这个按钮听上去有点傻，并且相当简陋，但是当我按照对话的节奏控制Jill喝啤酒时，我仿佛感觉我自己进入了游戏中，一边喝着啤酒，一边说着漫无边际的话语。这种感觉很难用语言去形容，但是我确实体会到了已经很久都没有在游戏中感受到过的沉浸感。</p><p>另一个令人感到惊艳的设计是点唱机。在每次开工前，我们需要在点唱机中填满十二首音乐（都是没有歌词的纯音乐。从游戏性考虑，这些音乐就是游戏过程中的bgm，当然不能有歌词，而这刚好也契合了剧情，因为Jill提到过她喜欢听没有歌词的音乐，歌词会让她在工作中分心，并且有可能会带来负面情绪），这不仅能让玩家可以自由地选择游玩过程中的自己喜欢的bgm，同时也是另一个提升沉浸感的手段。我通常喜欢在第一首音乐处选择《welcome to valhalla》，象征着工作的开始。而根据顾客谈论的内容，我会手动切换到符合场景的bgm来让顾客感到更加舒适（虽然根本就没有这种设定）。</p><p><img src="/undefined/e2faed25/20250129235725_2.jpg" alt="20250129235725_2" style="zoom:50%;"></p><h2 id="塑造角色的秘诀"><a href="#塑造角色的秘诀" class="headerlink" title="塑造角色的秘诀"></a>塑造角色的秘诀</h2><p>人们总是用“剧情神作”来描述那些优秀的剧情向游戏，这是一个笼统的称呼，因为剧情可以分为剧本、人物塑造、世界观塑造等，而“剧情神作”并不一定在所有方面都能做到完美。我认为，VA11的精髓在于其优秀的人物塑造，更进一步地说，是人物的真实感和生活感。上面介绍了各种游戏中能够提升沉浸感的手段，而这一切的基础都是建立在真实的人物塑造之上的，毕竟，谁会费心去记住一个没有任何真实感的角色喜欢什么酒呢？</p><p>这部作品的文字量并不是很多，并且几乎都是对话。正是通过这些用心程度相当之高的台词设计，制作者塑造出了一个个仿佛正活在某个世界上的角色。角色们的台词都相当自然，阅读时就像是在和真正的人在聊天一样，就算这些对话在现实生活中出现，也几乎没有违和感（如果忽略他们谈论的内容的话）。无论是特别的口癖，特殊的称呼，还是偶然间提起前几天谈话的内容，对于这些台词，我只想说：太有生活感了VA11。</p><p>游戏内容当然也不全是轻松愉快的闲聊，因为人的生活并不总是一成不变的，尤其是在Glitch City这座城市中。而当顾客遭遇了变故或者遇到某些烦恼时，Jill有时也会化身“人生导师”，想办法为顾客开导，偶尔还会说出一些相当有哲理的话。</p><p><img src="/undefined/e2faed25/20250121233656_2.jpg" alt="20250121233656_2" style="zoom:50%;"></p><p><img src="/undefined/e2faed25/20250121233700_1.jpg" alt="20250121233700_1" style="zoom:50%;"></p><p><img src="/undefined/e2faed25/20250121233726_1.jpg" alt="20250121233726_1" style="zoom:50%;"></p><p>正如某位顾客所说，Jill总是维持着“精明的调酒师”的形象，她似乎对一切都能淡然处之，并且无欲无求。然而任何对Jill有一些了解的人都不会赞同这种看法。作为本作的主角，制作者花费了大部分精力用来塑造Jill这个人物。在每天上班之前，游戏中有一个在房间中的环节，在这里，Jill会浏览新闻和论坛，并扮演自己养的猫Fore来分饰两角和自己自问自答，对新闻和论坛中的内容进行吐槽。这个环节对Jill起到了相当大的作用，我们可以通过她对各种内容的看法得知她的性格、爱好等。当我知道Jill甚至会为了买无线XX棒花光存款时，我的大脑停止思考了好几秒。而Jill曾为美少女战士动画着迷（其实现在也是）的属性也为其的性格增加了一些反差感，让人感觉更加真实（因为我在现实中还真见过不少这种人）。</p><p>短短7.5个小时的游戏时间里，这个游戏中的每一个角色都给我留下了鲜活的印象。比起某些galgame用动辄上两位数的时长塑造出的流水线女角色，VA11带给我的简直就是群像盛宴。随着AI技术的发展，许多人认为将AI接入游戏来生成随机的人物对话将成为使角色变得鲜活的最佳手段，但我目前还是认为，精心设计、拥有强大上下文关联的台词是AI无法逾越的高山。</p><p>再放张Jill美图</p><p><img src="/undefined/e2faed25/19fdf15a04b5941f92c5f9c12a9882e6c2ec7b8a153224cae.jpg" alt="19fdf15a04b5941f92c5f9c12a9882e6c2ec7b8a153224cae" style="zoom: 25%;"></p><h2 id="绝望的城，温情的人"><a href="#绝望的城，温情的人" class="headerlink" title="绝望的城，温情的人"></a>绝望的城，温情的人</h2><blockquote><p>这是不应存在的城市。由企业和黑帮主宰一切的避税天堂。在这里，所有人都被植入纳米机械，用于维持监控。白骑士监督每位市民，确保腐败政府的法律得到服从。</p><p>形形色色的暴行不过是这座城市日常生活的剪影。弱势群体的生活品质正在急剧下滑。对很多人而言，这是难以承受的重负。有些人选择投入自己的工作，家庭，或是研究之中。另一些人正在寻求逃离的方式。还有一些人……选择了放弃。</p><p>但也有人认为自己的答案就沉在酒杯的底部。</p></blockquote><p>作为赛博朋克题材的作品，本作的故事全都发生在一个典型的赛博朋克都市Glitch City中。腐败的政府，垄断的企业，义体改造，基因编辑，仿生人……这座城市下充满了赛博朋克世界观下的常见的元素。虽然我们无法直接在游戏中游览这座城市，但制作者仅通过各种对话就向我们展现了一座充满了罪恶与混乱的城市。</p><p>大部分赛博朋克题材的作品都着重于表达对赛博朋克世界观下极权的反抗，例如《赛博朋克2077》中的“让我们把这座城市烧成灰！” ，以及《幽灵行者》中一言不合直接将所有敌人砍成两截。与之相比，VA11似乎透漏出一股消极的意味，没有人挺身而出对抗政府，没有秘密集会传播思想，只有一群在这座城市过着自己生活的普通人。</p><p>然而，当完成一周目的游玩后，我感受到的却不是身处赛博朋克世界下无能为力，身不由己的绝望，而是乐观和豁然开朗。VA11中刻画的角色们并不是没有反抗，只是反抗的方式不同罢了。他们反抗的方式便是：即使生活在这样一个狗屎一样的世界上，也要认真生活，以及善待他人。Jill没有隐藏于手指间的单分子线，也没有瞪一眼就能让人脑袋开花的能力。她拥有的只有非凡的调酒技术，以及一颗真诚待人的心，而这足以为她和身边的人带来在Glitch City中继续生活下去的勇气。</p><p>VA11-HALL-A的顾客们在Glitch City这座城市中显得有些过于闪亮。他们会遇到各种问题，比如家庭问题，存在主义危机，甚至是受到生命威胁，他们也会抱怨，也会有痛苦和迷茫。但在这之后，他们会直面困难，并在Jill的帮助下度过难关。而当游戏接近尾声，Jill遭遇了生活中的巨大变故时，他们也反过来支撑着Jill，帮助她逐渐从阴影中走出，并最终解开心结。虽然最终世纪大和解的结局像是在包饺子，但是伴随着新年的钟声、对Lenore的悼念以及对未来生活的展望，这绝对是一盘充满各种滋味，让人回味无穷的饺子。</p><p>VA11在两个端点之间找到了一个绝妙的平衡点。先塑造出栩栩如生、令人喜爱的角色，再通过他们身上遭遇的不幸揭露这个城市乃至于这个世界的腐败，最后通过人物与他人的和解，最主要的是与自身的和解，来展现人物弧光并给予玩家希望。在大团圆结局的背后，VA11同样有着赛博朋克题材作品中必不可少批判和警示，以及丰富的设定。游戏中Lilim、缸中之脑、通过装置获得说话能力的狗等都是很有意思的设定，制作者对于一些经典问题，如意识上传、人工智能的自我意识等也展现了自己认真的思考。这些都是VA11中世界观塑造的加分项。</p><h2 id="故事结束了，但是他们的人生还在继续"><a href="#故事结束了，但是他们的人生还在继续" class="headerlink" title="故事结束了，但是他们的人生还在继续"></a>故事结束了，但是他们的人生还在继续</h2><blockquote><p>在距离城市主干道只有几步之遥的小路上，贫民区附件的某个地方，你可以找到这家BTC认证编号VA-11的酒吧的Hall A……</p><p>……但是全称过于拗口，因此我们称之为Valhalla。</p><p>这是钢筋混凝土荒漠中的小小绿洲。为疲惫不堪的灵魂带来慰藉的精神之泉。</p><p>我们的故事就将在这里展开。</p></blockquote><p>虽然最开始的评语有点开玩笑的意思，但是VA11的故事确实有点短，结尾也有些仓促。Jill才刚解开缠绕了自己几年的心结，将要迈向人生的新阶段，故事却在这一天戛然而止。当屏幕上开始播放后日谈的时候，我还是不敢相信：这就结束了？但当我看到那些被Jill帮助且帮助了Jill的角色们在这之后的幸福生活后，我还是释怀了。在Jill的顾客中，有的成为了她生活的一部分，也有的只是擦肩而过的。然而还有一种顾客，虽然他们不会常伴左右，但他们带来的影响是不可磨灭的，并在未来持续产生影响。而VA11对于我来说也是如此。游戏中的角色们都开启了新的生活，也许我并不能亲眼见证所有故事的结局，但我会永远记住这一小段时间的陪伴。</p><p>祝你们的未来一帆风顺，Jill，Dana，Gill，Gaby，Dorothy，Alma，Sei，Stella，Virgilio……</p><p>下个游戏见！</p><p><img src="/undefined/e2faed25/1b12cd068e07006a45255e9d83b38753970b2f031517cd586.jpg" alt="1b12cd068e07006a45255e9d83b38753970b2f031517cd586" style="zoom:80%;"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【GAME101】图形学学习记录——光线追踪</title>
      <link href="/undefined/7f87aff.html"/>
      <url>/undefined/7f87aff.html</url>
      
        <content type="html"><![CDATA[<h1 id="【GAME101】图形学学习记录——光线追踪"><a href="#【GAME101】图形学学习记录——光线追踪" class="headerlink" title="【GAME101】图形学学习记录——光线追踪"></a>【GAME101】图形学学习记录——光线追踪</h1><h2 id="阴影映射-Shadow-Mapping"><a href="#阴影映射-Shadow-Mapping" class="headerlink" title="阴影映射(Shadow Mapping)"></a>阴影映射(Shadow Mapping)</h2><p>在着色部分中，我们学习了如何表现出一个物体被光线照射时表现出的效果。但是着色无法解决一个问题：如何表现阴影。在光栅化的领域中，解决这一问题的方法是<strong>阴影映射</strong>。</p><p>阴影映射的重要思想是：<strong>如果一个点可以被我们看到，且它不在阴影里，那么这个点既可以被摄像机看到，也可以被光源看到。</strong>阴影映射只能处理点光源产生的阴影，并且结果非零即一。我们称之为<strong>硬阴影</strong>。</p><p><strong>第一步</strong>：在光源处放一个摄像机，看向我们想要渲染的场景，我们会得到一幅图。我们要做的是将这幅图上所有点的深度记录下来。</p><p><strong>第二步</strong>：在原本的摄像机处看向场景，对于任意一点，我们将其投影回它在上一步得到的图中的位置。将其和之前记录的深度进行比较，如果深度一致，说明这个点可以被光源看到。</p><p>阴影映射虽然能解决着色产生不了阴影的问题，但它有着极大的缺点，即只能生成硬阴影，这使得用这种方法产生的阴影在很多情况下并不真实。虽然现在已经有了一些关于这个问题的解决方法，但比较麻烦。</p><p>因为光栅化无法很好地解决软阴影和多个光源存在时的渲染等问题，光线追踪的技术应运而生。光线追踪的速度较慢，但质量非常高，因此常被应用于离线场景中（如动画制作）。</p><h2 id="基础光线追踪算法"><a href="#基础光线追踪算法" class="headerlink" title="基础光线追踪算法"></a>基础光线追踪算法</h2><h3 id="光线"><a href="#光线" class="headerlink" title="光线"></a>光线</h3><p>要了解光线追踪，我们首先要了解光线。一般来说，我们认为的光线有以下特点：</p><ul><li>光线沿直线传播</li><li>光线之间不会发生碰撞</li><li>光线从光源出发，到眼睛结束</li></ul><h3 id="光线投射"><a href="#光线投射" class="headerlink" title="光线投射"></a>光线投射</h3><p>对于上面第三点，有一个性质：<strong>光路的可逆性</strong>，即对于从光源到眼睛的一条光路，也可以认为是从眼睛发射出的感知光线投射到了光源，路径完全相同，只不过方向相反。光线追踪就利用了这个性质。</p><p>在光线追踪的场景里，我们假设眼睛是一个点。对于着色平面上的每一个像素，我们从眼睛处向其投射一道光线（后文简称为eye_ray），eye_ray第一个触碰到的点即为眼睛会看到的点。再将这个点投影向光源，即可根据能否到达光源判断这个点有没有被物体遮挡。当进行完这一过程后，我们已经得到了入射方向、观测方向、法线等信息，可以进行着色。如下图所示：</p><p><img src="/undefined/7f87aff/image-20241230220233799.png" alt="Ray Casting"></p><h3 id="递归的光线追踪-Whitted-Style-Ray-Tracing"><a href="#递归的光线追踪-Whitted-Style-Ray-Tracing" class="headerlink" title="递归的光线追踪(Whitted-Style Ray Tracing)"></a>递归的光线追踪(Whitted-Style Ray Tracing)</h3><p>在上述的过程中，光线仍然只反射了一次，而在现实生活中，光线是会反射很多次的。<strong>Whitted-Style Ray Tracing</strong>模拟了这一情形。</p><p>如下图所示，当光线照射到玻璃球上时，一部分光会发生折射，另一部分会发生发射，由此产生了多条光路，由此产生多个着色点。每个着色点着色的值都会被计算到成像平面的像素中。</p><p><img src="/undefined/7f87aff/image-20241230220757228.png" alt="Recursive Ray Tracing"></p><h3 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h3><p>虽然上面的过程十分清晰，但实际上有许多技术细节较难实现，主要是如何求eye_ray和物体表面的交点。</p><p>首先，我们要知道光线在数学上的定义。光线本质上是一条射线，它有一个起点o和一个方向d。对于光线上任意一个点，都可以用以下形式表示：</p><script type="math/tex; mode=display">r(t)=o+td\quad0\leq t<\infty</script><h4 id="隐式表示"><a href="#隐式表示" class="headerlink" title="隐式表示"></a>隐式表示</h4><p>以球体为例，球面的隐式表示为：</p><script type="math/tex; mode=display">(p-c)^2-R^2=0</script><p><img src="/undefined/7f87aff/image-20250101183346862.png" alt="sphere"></p><p>将两者联立，即可得到我们要找的交点p。</p><p>同理，对于任意图形的隐式表示，我们只需要将光线代入图形函数，即可求出交点位置：</p><script type="math/tex; mode=display">r(t)=o+td\quad 0\leq t<\infty \\p:f(p)=0 \\f(o+td)=0</script><p>当求出的t为正实数是，说明其有意义。</p><h4 id="显式表示"><a href="#显式表示" class="headerlink" title="显式表示"></a>显式表示</h4><p>对于显示表示，我们先考虑怎么实现光线与三角形求交。这个问题可以分成两部分：先求出光线和三角形所在平面的交点，再判断交点是否在三角形内。</p><p>我们可以用一个方向（法线）和一个平面上的点来定义任意一个平面，这样就可以轻松得到平面的显式表示。接下来的操作和之前相同。</p><script type="math/tex; mode=display">r(t)=0+td \quad 0\leq t<\infty \\p:(p-p\prime)\cdot N=o \\</script><p>联立解得：</p><script type="math/tex; mode=display">t=\frac {(p\prime -o)\cdot N}{d\cdot N}</script><p><img src="/undefined/7f87aff/image-20250101195520417.png" alt="image-20250101195520417"></p><p>判断点是否在三角形内的方法在之前的光栅化部分有所讲解，这里不再重复。</p><p><strong>以下是一种可以直接算出光线与三角形的交点并判断其是否在三角形内的算法：Moller Trumbore算法。</strong></p><p><img src="/undefined/7f87aff/image-20250101200341477.png" alt="Moller Trumbore"></p><p>在知道了怎么求光线和三角形的交点后，我们只需要求出光线和每一个三角形的交点，取最近的那个即是eye_ray和物体表面的交点。但是这样做的资源消耗太大了，有没有什么加速的方法呢？</p><h4 id="加速结构"><a href="#加速结构" class="headerlink" title="加速结构"></a>加速结构</h4><p><strong>包围盒(Bounding-Box)</strong>是指完全包裹住物体的一块体积。在这里，我们通常使用<strong>轴对齐包围盒(Axis-Aligned Bounding Box,AABB)</strong>，它是三组对面的交集，相当于划定了x、y、z的范围。</p><p><img src="/undefined/7f87aff/image-20250101202453704.png" alt="AABB"></p><p>一个重要思想：<strong>当光线不与包围盒相交时，它也一定不与物体相交。</strong></p><p>首先，我们来了解如何判定光线和包围盒是否相交。</p><p>先考虑二维的情况。对于光线和包围盒的两组对面，我们能求出光线进入对面的时间和离开对面的时间（即使得出的时间是负的）。这样我们就得到了两条线段，对这两条线段求交集即可得到光线进出包围盒的时间。如图所示：</p><p><img src="/undefined/7f87aff/image-20250101203633220.png" alt="2D"></p><p>三维空间内的做法类似。对于三组对面，我们分别求出三个光线进入对面的时间tmin和三个光线离开对面的时间tmax，取最大的tmin和最小的tmax，即为光线进入和离开包围盒的时间。如果进入的时间小于离开的时间，说明光线和包围盒有交点，反之说明没有交点。</p><p>接下来再考虑时间为负的情况。如果离开时间texit<0，说明包围盒在光线的“后面”，一定没有交点。如果t exit>=0且离开时间t enter&lt;0，说明光源在包围盒内，这时一定有交点。</0，说明包围盒在光线的“后面”，一定没有交点。如果t></p><p>总结一下，光线和包围盒有交点的条件为：</p><script type="math/tex; mode=display">t_{enter}<t_{exit}\&\&t_{exit}>=0</script><p>对于一个场景，我们找出它的一个包围盒，将包围盒均匀划分为一堆格子，并找出那些与物体表面相交的格子。当光线进入包围盒时，我们计算它将与哪些格子相交，当光线与那些和物体表面相交的格子相交时，光线就有可能和物体相交。这时，我们再做光线和物体的求交。这样大大降低了计算时的性能消耗，因为我们认为计算光线和盒子是否相交是非常快的。</p><p><img src="/undefined/7f87aff/image-20250102162426229.png" alt="grims"></p><p>以上方法只适用于场景中的物体比较均匀且密集的情况，如果场景较为空旷，光线会穿过许多空格子，造成性能浪费。</p><p><strong>空间划分(Spatial Partitions)</strong>是上面这种方法的改进。它的思想是在空旷的地方用一个大盒子包围，而物体密集的地方用一个个小的格子进行划分。下面是一些经典的空间划分方法：</p><p><img src="/undefined/7f87aff/image-20250102162727926.png" alt="Spatial Partitions"></p><p><img src="/undefined/7f87aff/image-20250102165315194.png" alt="KD-Tree"></p><p>KD-Tree有两个问题，一是三角形可能会同时在两个格子里，二是KD-Tree的建立并不简单直观。</p><p><strong>Object Partitions &amp; Bounding Volume Hierarchy(BVH)</strong></p><p>目前，这个结构得到了广泛的应用，因为塔它基本上解决了KD-Tree的物体。</p><p>这种结构的思想是按照物体进行划分。对于一些三角形，先求出它们的一个包围盒。将这些三角形按某种方法分成两部分，对这两部分三角形重新求包围盒，重复操作，直到满足一定的标准。</p><p><img src="/undefined/7f87aff/image-20250102172307429.png" alt="Object Partitions"></p><p>这样做的好处是每个三角形只会出现在一个包围盒里，但是包围盒之间也有可能产生重叠，在划分时应该尽可能减少这种重叠。</p><p>一种简单的划分方法是沿着最长的轴进行划分，并且每次都从之间的三角形处进行划分，这样建立的树较为平衡。有一种可以在O(n)时间内找到无序数列中第i大的数的算法，叫做快速选择。我们可以用这种方法快速找到最中间的三角形。</p><h2 id="辐射度量学-Radiometry"><a href="#辐射度量学-Radiometry" class="headerlink" title="辐射度量学(Radiometry)"></a>辐射度量学(Radiometry)</h2><p> 虽然我们之前花了大量的篇幅讲述如何模拟现实中的光照情况，但其仍然是做了许多简化的，例如我们将光简单地定义为一个点及光强，而在现实中显然不是这样。而通过辐射度量学，我们将精准地赋予光一系列物理量，把光及物体的表面和光如何作用等细节精确地表示出来。</p><h3 id="物理量"><a href="#物理量" class="headerlink" title="物理量"></a>物理量</h3><p>辐射度量学定义了光照的若干属性，如Radiant flux（光通量）,intensity（光强）,irradiance（辉度）,radiance（光亮度）。接下来将一一讲解。</p><h4 id="Radiant-Energy-and-Flux-Power"><a href="#Radiant-Energy-and-Flux-Power" class="headerlink" title="Radiant Energy and Flux(Power)"></a>Radiant Energy and Flux(Power)</h4><p>Radiant Energy表示的是光源辐射出来的能量，而Radiant flux是单位时间内的能量，即光通量，类似于功率。</p><script type="math/tex; mode=display">Q[J=Joule] \\\phi =\frac {dQ}{dt}\quad[W=Watt][lm=lumen]^*</script><h4 id="Radiant-Intensity-Irradiance-and-Radiance"><a href="#Radiant-Intensity-Irradiance-and-Radiance" class="headerlink" title="Radiant Intensity,Irradiance and Radiance"></a>Radiant Intensity,Irradiance and Radiance</h4><p><strong>Intensity</strong>定义了某个<strong>单位立体角内的光通量</strong>。所谓的立体角是二维角度在三维空间中的延伸。从一个球的球心向球面投影一块面积，面积除以球半径的平方就是对应立体角的大小。</p><script type="math/tex; mode=display">I(\omega)=\frac {d\phi}{d\omega}\quad[\frac \omega{sr}][\frac {lm}{sr}=cd=candela]</script><p><strong>Irradiance</strong>是指<strong>单位面积上的光通量</strong>。</p><script type="math/tex; mode=display">E(x)=\frac{d\phi(x)}{dA}\quad [\frac W{m^2}][\frac{lm}{m^2}=lux]</script><p>而<strong>Radiance</strong>定义了<strong>单位立体角和单位面积上的光通量</strong>，这意味着我们要对光通量做两次微分：</p><script type="math/tex; mode=display">L(p,\omega)=\frac{d^2\phi(p,\omega)}{d\omega dAcos\theta}\quad[\frac W{srm^2}][\frac{cd}{m^2}=\frac{lm}{srm^2}=nit]</script><p><img src="/undefined/7f87aff/image-20250103173408968.png" alt="Radiance"></p><p>Radiance和Irradiance之间的差异就是方向性。</p><h3 id="Bidirectional-Reflectance-Distribution-Function-BRDF"><a href="#Bidirectional-Reflectance-Distribution-Function-BRDF" class="headerlink" title="Bidirectional Reflectance Distribution Function(BRDF)"></a>Bidirectional Reflectance Distribution Function(BRDF)</h3><p>BRDF的意思是双向反射分布函数。这个函数真实地定义了反射的过程。它描述了有多少能量如果从某个方向进来，它会怎么向不同的方向分散。我们也可以理解成光线照射到某一个物体表面被吸收，物体表面再将能量发射出去。从这个角度，我们就可以用Radiance和Irradiance来理解反射。如图所示：</p><p><img src="/undefined/7f87aff/image-20250103185546708.png" alt="Reflection"></p><p>从一个单位立体角照射而来的Radiance被一小块单位面积dA吸收，得到了dA的Irradiance，而BRDF能告诉我们dA向各个方向单位立体角辐射的Radiance的大小。</p><p><img src="/undefined/7f87aff/image-20250103190008969.png" alt="BRDF"></p><script type="math/tex; mode=display">f_r(\omega_i\to\omega_r)=\frac{dL_r(\omega_r)}{dE_i(\omega_i)}=\frac{dL_r(\omega_r)}{L_i(\omega_i)cos\theta_id\omega_i}\quad[\frac1{sr}]</script><p>将每一个方向的入射光对出射光方向的贡献加起来，就可以得到出射光方向的光照效果。以下就是<strong>反射方程</strong>：</p><script type="math/tex; mode=display">L_r(p,\omega_r)=\int_{H^2}f_r(p,\omega_i\to\omega_r)L_i(p,\omega_i)cos\theta_id\omega_i</script><p>用更通用的方式重写这个方程，并考虑物体自身发光的情况，就得到了<strong>渲染方程</strong>：</p><script type="math/tex; mode=display">L_o(p.\omega_o)=L_e(p,\omega_o)+\int_{\Omega+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)(n\cdot \omega_i)d\omega_i</script><p>将光线传播写成算子形式，并进行展开，可以得到：</p><script type="math/tex; mode=display">L=E+KE+K^2E+K^3E+...</script><p>这中间的过程比较复杂，这里不做说明。我们需要知道的是，上面这个公式的意思是，全局光照由直接光照和间接光照相加得到，间接光照包括一次反射、两次反射、三次反射……。</p><h2 id="路径追踪"><a href="#路径追踪" class="headerlink" title="路径追踪"></a>路径追踪</h2><h3 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h3><p>在开始接下来的学习之前，我们先复习一些概率论的知识。</p><p>随机变量：</p><script type="math/tex; mode=display">X</script><p>随机变量服从于某种分布：</p><script type="math/tex; mode=display">X\sim p(x)</script><p>X可能的取值：</p><script type="math/tex; mode=display">x_i</script><p>X取xi概率：</p><script type="math/tex; mode=display">p_i</script><p>需要满足的要求：</p><script type="math/tex; mode=display">p_i\geq 0 \\\sum_{i=1}^np_i=1</script><p>期望：</p><script type="math/tex; mode=display">E[X]=\sum_{i=1}^nx_ip_x</script><p>在连续的情况下：</p><script type="math/tex; mode=display">p(x)\geq0 \quad and\quad\int p(x)dx=1 \\E[X]=\int xp(x)dx</script><p>概率密度函数(Probability Distribution Function,PDF)：</p><p><img src="/undefined/7f87aff/image-20250103225614329.png" alt="PDF"></p><p>随机变量是函数的情况：</p><script type="math/tex; mode=display">X\sim p(x) \\Y=f(X) \\E[Y]=E[f[X]]=\int f(x)p(x)dx</script><h3 id="蒙特卡洛积分"><a href="#蒙特卡洛积分" class="headerlink" title="蒙特卡洛积分"></a>蒙特卡洛积分</h3><p>蒙特卡洛积分是一种求复杂函数定积分的值的方法。它的思想是在积分范围内随机取一点并将以积分范围为底，随机点处的值为高的长方形的面积近似当作定积分的值。重复多次并求平均，结果会越来越精准。</p><script type="math/tex; mode=display">\int_a^bf(x)dx \\X_i\sim p(x) \\N_N=\frac1N\sum_{i=1}N\frac{f(X_i)}{p(X_i)}</script><h3 id="路径追踪的实现"><a href="#路径追踪的实现" class="headerlink" title="路径追踪的实现"></a>路径追踪的实现</h3><p>之前我们得到了渲染方程，而接下来的工作就是去解这个方程。而渲染方程中最重要的部分是一个定积分，我们将用蒙特卡洛方法去解这个定积分。</p><p>忽略物体自身发光的情况，渲染方程如下：</p><script type="math/tex; mode=display">L_o(p.\omega_o)=\int_{\Omega+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)(n\cdot \omega_i)d\omega_i</script><p><strong>首先我们只考虑直接光照。</strong>为了方便计算，我们假设对每个方向进行采样的概率相等。这样一来，我们就可以写出积分的蒙特卡洛形式：</p><script type="math/tex; mode=display">L_O(P,\Omega_o)=\int_{\Omega+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)(n\cdot\omega_i)d\omega_i\approx\frac1N\sum_{i=1}^N\frac{L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)(n\cdot\omega_i)}{p(\omega_i)} \\p(\omega_i)=\frac1{2\pi}</script><p>伪代码：</p><p><img src="/undefined/7f87aff/image-20250104165044537.png" alt="Path Tracing"></p><p><strong>接下来考虑包含间接光照的情况。</strong>对于着色点p，假设有一点q在受到光源照射后会反射给p，那么我们用直接光照的算法算出q点向四周辐射的能量，再将q点当作光源，就可以用相同的方法算出q点对于p点的贡献。伪代码：</p><p><img src="/undefined/7f87aff/image-20250104170016058.png" alt="Indirect"></p><p>虽然上面的想法很美好，但还有一个严重的问题：随着反射次数的提升，光线的数量会呈指数级增长，而这样的性能消耗是我们无法承受的。目前来说，路径追踪的做法是令n=1（这样显然会造成结果的不精确，解决方法会在之后细说），这样无论反射多少次，光线都不会增加。我们在每一个像素内取许多个采样点，对于每个采样点都连一条到达光源的路径，这在一定程度上和蒙特卡洛积分中取n个采样点的做法相同。这也是这个方法被称为路径追踪的原因。令n!=1的做法叫做分布式光线追踪。</p><p><img src="/undefined/7f87aff/image-20250104174103187.png" alt="Ray Generation"></p><p>另一个问题是，这个算法是一个递归的算法，但是它没有设置递归出口。这个问题的解决方法是<strong>“俄罗斯轮盘赌”</strong>。</p><p>我们都知道俄罗斯轮盘赌是一个概率问题，而在这里，它的思想是设置一个概率p，在每一次计算时，有p的概率会发射一条光线出去，得到的着色结果是Lo/p，而有(1-p)的概率不发射光线出去，得到的结果自然是0.这样做的好处是，最终得到的期望依旧是Lo。伪代码：</p><p><img src="/undefined/7f87aff/image-20250104175231862.png" alt="RR"></p><p>以上就是路径追踪的大致内容。</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>在进行蒙特卡洛采样时，如果用完全随机的方法，路径到达光源的几率较低，这样很多光线就被浪费了。如果我们能找到一个更好的采样方法，这个问题将会得到改善。</p><p>如果只在光源上进行采样，那么所有的光线都将到达光源，自然不会产生浪费。问题是蒙特卡洛积分要求采样位置和积分位置相同，因此我们要将渲染方程中对方位角的积分改写成对光源面积的积分，下面直接给出结果：</p><p><img src="/undefined/7f87aff/image-20250104181456138.png" alt="Sampling the Light"></p><p>这样，对于光源产生的光照，我们直接进行计算，而对于间接光照，我们仍使用俄罗斯轮盘赌的方法，伪代码如下：</p><p><img src="/undefined/7f87aff/image-20250104181716179.png" alt="final"></p><p>当然，还要注意光源被物体遮挡的情况。</p><p><img src="/undefined/7f87aff/image-20250104182026794.png" alt="shade"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【GAMES101]图形学学习记录——几何</title>
      <link href="/undefined/a5e850e2.html"/>
      <url>/undefined/a5e850e2.html</url>
      
        <content type="html"><![CDATA[<h1 id="【GAMES101】图形学学习记录——几何"><a href="#【GAMES101】图形学学习记录——几何" class="headerlink" title="【GAMES101】图形学学习记录——几何"></a>【GAMES101】图形学学习记录——几何</h1><p>在现实生活中，物体有各种各样的形状，在这一节中，我们将学习如何在图形学中表示这些不同的形状。</p><h2 id="隐式和显式几何表示"><a href="#隐式和显式几何表示" class="headerlink" title="隐式和显式几何表示"></a>隐式和显式几何表示</h2><h3 id="隐式几何表示"><a href="#隐式几何表示" class="headerlink" title="隐式几何表示"></a>隐式几何表示</h3><p>只包含构成几何形状的点满足的<strong>关系</strong>，不包含这些点的具体位置，通常为一个函数。例如一个球的隐式表示：</p><script type="math/tex; mode=display">x^2+y^2+z^2=1</script><p>通常用以下方式表示：</p><script type="math/tex; mode=display">f(x,y,z)=x^2+y^2+z^2-1=0</script><p>隐式表示很容易判断一个点在不在几何平面上，但很难找出几何平面上有哪些点。</p><h3 id="显式几何表示"><a href="#显式几何表示" class="headerlink" title="显式几何表示"></a>显式几何表示</h3><p>直接将几何形状上的所有的点都表示出来，或者通过参数映射的方法定义的表面。参数映射的解释如下：</p><p><img src="/undefined/a5e850e2/image-20241228181255365.png" alt="image-20241228181255365"></p><p>显式表示很容易判断哪些点在平面上，但很难判断一个点在平面上，平面内还是平面外。</p><h2 id="不同的隐式表示"><a href="#不同的隐式表示" class="headerlink" title="不同的隐式表示"></a>不同的隐式表示</h2><p>之前所说函数形式的隐式表示虽然能表示出一个几何图形，但我们很难直观地通过一个复杂的函数知道这个几何图形的形状。以下是一些其他的隐式表示方法。</p><ul><li><strong>CSG(Constructive Solid Geometry)</strong>：通过对基础的几何体做一些简单的布尔运算来表示复杂的几何体。如图所示：</li></ul><p><img src="/undefined/a5e850e2/image-20241228190253928.png" alt="CSG"></p><ul><li><strong>Distance Functions(距离函数)</strong>：对于任何一个几何图形，不直接描述它的表面，而是描述如何一个点到这个表面的最近距离。求出两个物体的距离函数，并进行融合，就可以得到新的物体。（怎么感觉更不直观了</li></ul><p><img src="/undefined/a5e850e2/image-20241228192735963.png" alt="Distance Functions"></p><h2 id="不同的显式表示"><a href="#不同的显式表示" class="headerlink" title="不同的显式表示"></a>不同的显式表示</h2><ul><li><p><strong>点云</strong>：不考虑物体是一个表面，而是表面上的一些点，当足够精细时就和平面相差无几。</p></li><li><p><strong>多边形面</strong>：大多数是三角形和四边形。用多边形的组合来描述几何图形。在图形学中的应用最为广泛。</p><p>  .obj文件：一种文本文件，分别记录了一堆点，一堆法线和一堆纹理坐标，再将它们组织起来来描述图形。</p></li></ul><h2 id="曲线-Curves"><a href="#曲线-Curves" class="headerlink" title="曲线(Curves)"></a>曲线(Curves)</h2><h3 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h3><p>用一系列控制点去定义某一个曲线。</p><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>假设在时间0-1内，时间0在起始点，时间1在结束点，我们要算出在任意时间0-1中任意时刻点在空间中的位置。对于n个控制点（n&gt;2），我们在每两个相邻的点之间连一条线段，并在这个线段上找到使其比例为t的点。当进行一轮这样的操作后，我们得到了n-1个点。重复以上操作，直到最终只剩下一个点，这个点就是时间t所在的点。当我们枚举时间t，得到的点连成的就是贝塞尔曲线。图解如下：</p><p><img src="/undefined/a5e850e2/image-20241228224711812.png" alt="贝塞尔曲线"></p><script type="math/tex; mode=display">b^n(t)=b_0^n(t)=\sum_{j=0}^nb_jB_j^n(t) \\B_i^n(t)=C_n^it^i(1-t)^{n-i} \\B_i^nt被称为伯恩斯坦多项式</script><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ul><li>贝塞尔曲线的起点是第一个控制点，终点是最后一个控制点。</li><li>起点处切线的方向一定为b2-b1，终点处的方向一定为bn-b(n-1)。</li><li>控制点经过仿射变换后，生成的贝塞尔曲线形状不会改变。</li><li>控制点得到的曲线一定在控制点形成的<strong>凸包</strong>内。</li></ul><h4 id="逐段控制的贝塞尔曲线"><a href="#逐段控制的贝塞尔曲线" class="headerlink" title="逐段控制的贝塞尔曲线"></a>逐段控制的贝塞尔曲线</h4><p>当控制点过多时，计算成本会增加，同时控制的效果会变差。因此，更高效的做法是逐段用少量控制点（通常是四个）来逐段控制曲线。</p><h3 id="B-splines（B样条）"><a href="#B-splines（B样条）" class="headerlink" title="B-splines（B样条）"></a>B-splines（B样条）</h3><p>样条是一种完全可控的曲线，而B样条是贝塞尔曲线的延伸，它具有局部性，在改动控制点时影响的范围有限。</p><h2 id="曲面"><a href="#曲面" class="headerlink" title="曲面"></a>曲面</h2><h3 id="贝塞尔曲面"><a href="#贝塞尔曲面" class="headerlink" title="贝塞尔曲面"></a>贝塞尔曲面</h3><p>贝塞尔曲面是由贝塞尔曲线得到的。原理和双线性插值基本相同，我们在两个方向上分别应用贝塞尔曲线即可。</p><h2 id="三角形的细分和简化"><a href="#三角形的细分和简化" class="headerlink" title="三角形的细分和简化"></a>三角形的细分和简化</h2><h3 id="三角形的细分"><a href="#三角形的细分" class="headerlink" title="三角形的细分"></a>三角形的细分</h3><p>有的时候，三角形数量不足会导致模型不够精细，这时候，我们希望能增加三角形的数量来提升模型的精细度。细分通常分为两步：将一个三角形分成多个三角形，之后调整这些三角形的位置使其符合模型。</p><h4 id="Loop细分-Loop-Subdivision"><a href="#Loop细分-Loop-Subdivision" class="headerlink" title="Loop细分(Loop Subdivision)"></a>Loop细分(Loop Subdivision)</h4><p>将三角形三边的中点连起来，就得到了四个小的三角形。以前的顶点称为旧的顶点，中点称为新的顶点。</p><p>对于新的顶点，如果它被两个三角形共享，则它的位置由这两个三角形的旧的顶点加权得出。和它在同一条线段上的两个顶点的权值是3/8，另外两个顶点的权值是1/8。如图所示：</p><p><img src="/undefined/a5e850e2/image-20241229160151471.png" alt="New Vertex"></p><p>对于旧的顶点，定义n为顶点的度，定义u为和n有关的数，当n=3时，u=3/16，否则u=3/(8n)。旧的顶点的位置有自己和周围的点加权得出，如图所示：</p><p><img src="/undefined/a5e850e2/image-20241229160945037.png" alt="Old Vertex"></p><h4 id="Catmull-Clark细分"><a href="#Catmull-Clark细分" class="headerlink" title="Catmull-Clark细分"></a>Catmull-Clark细分</h4><p>Loop细分只能对三角形做细分，而Catmull-Clark细分在一般的情况下也能进行操作。</p><p>定义非四边形为所有边数不为4的多边形，奇异点为度不等于4的点。对所有的边都取中点，所有的面也取中心点，将中点和中心点连起来就产生了更多的多边形。当进行这样一次操作后，奇异点的数量增加了非四边形的数量，所有非四边形都消失，并且之后不会再有奇异点的增加和非四边形的出现。效果如下：</p><p><img src="/undefined/a5e850e2/image-20241229162632162.png" alt="Catmull-Clark"></p><p>每个点位置的更新方式如下图所示：</p><p><img src="/undefined/a5e850e2/image-20241229163314152.png" alt="Catmull-Clark Vertex Update Rules"></p><h3 id="三角形的简化"><a href="#三角形的简化" class="headerlink" title="三角形的简化"></a>三角形的简化</h3><p>有的时候（例如当物体离摄像机很远的时候），物体的精细程度并不十分重要，在这种情况下，我们希望用更少的三角形来表示物体，以达到减少性能消耗的目的。</p><h4 id="边坍缩-Edge-Collapse"><a href="#边坍缩-Edge-Collapse" class="headerlink" title="边坍缩(Edge Collapse)"></a>边坍缩(Edge Collapse)</h4><p>想象有一条边，当我们捏住它的两个顶点并重叠到一起，这条边就不复存在了。这就是边坍缩的概念。但是对于一个物体来说，我们怎么知道哪些边不重要，可以进行坍缩，哪些不能呢？这里需要用到<strong>二次误差度量</strong>的概念。<strong>二次误差度量是指顶点到到和它相邻的所有平面的距离的平方和</strong>。</p><p>在进行边坍缩时，优先坍缩二次误差度量最小的边即可。但是，当我们对一条边进行坍缩后，和它相邻的边会受到影响，导致二次误差度量受到影响，这使得我们无法先计算所有边的二次误差度量，再依次进行坍缩。在这里，我们可以用最小堆的数据结构进行计算。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【GAMES101】图形学学习记录——着色</title>
      <link href="/undefined/61766197.html"/>
      <url>/undefined/61766197.html</url>
      
        <content type="html"><![CDATA[<h1 id="【GAMES101】图形学学习记录——着色-Shading"><a href="#【GAMES101】图形学学习记录——着色-Shading" class="headerlink" title="【GAMES101】图形学学习记录——着色(Shading)"></a>【GAMES101】图形学学习记录——着色(Shading)</h1><p>简而言之，着色就是为物体附上不同材质的过程。</p><h2 id="Blinn-Phong模型"><a href="#Blinn-Phong模型" class="headerlink" title="Blinn-Phong模型"></a>Blinn-Phong模型</h2><p>Blinn-Phong模型简单地展示了一个<strong>着色点</strong>在受到光线照射时会表现出什么颜色。</p><p>输入：<strong>观测方向v</strong>，<strong>平面法线n</strong>，<strong>光照方向l</strong>，<strong>表面参数</strong>（颜色，反光度等）。</p><p><img src="/undefined/61766197/image-20241227010440816.png" alt="Blinn-Phong"></p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>在Blinn-Phong模型中，物体在受到光照后展现出的效果由三个部分组成：<strong>漫反射</strong>，<strong>高光反射</strong>，<strong>环境光照</strong>。</p><h4 id="漫反射"><a href="#漫反射" class="headerlink" title="漫反射"></a>漫反射</h4><p>光线照射在物体表面时向四周反射的现象被称为漫反射。公式如下：</p><script type="math/tex; mode=display">L_d=k_d(I/r^2)max(\vec n·\vec l) \\k_d:漫反射系数(和材质对光线的吸收率有关) \\I:光源的光照强度 \\r:光源到着色点的距离 \\</script><h4 id="镜面反射"><a href="#镜面反射" class="headerlink" title="镜面反射"></a>镜面反射</h4><p>当我们处于特定的角度观察较为光滑的物体时，会看到物体表面会有明亮的高光，这就是镜面反射产生的效果。</p><p>特定的角度为当观察方向(v)和镜面反射的方向(r)足够接近时（范围由材质决定）。</p><p>计算v和r的距离较为麻烦，因此我们可以用<strong>半程向量(h)</strong>和平面法线(n)之间的距离来代替。</p><p><img src="/undefined/61766197/image-20241227150555453.png" alt="specular"></p><p>半程向量的计算公式以及高光反射的计算公式。</p><script type="math/tex; mode=display">\vec h=bisector(\vec v,\vec l) =\frac {\vec v+\vec l}{||\vec v+\vec l||} \\L_s=k_s(I/r^2)max(0,cos\alpha)^p \\=k_s(I/r^2)max(0,\vec n·\vec h)^p \\k_s:镜面反射系数 \\I:光源光照强度 \\r:光源到着色的的距离 \\p:用于增大余弦曲线的参数</script><p>值得注意的是p这个参数。在现实生活中能看到高光的范围是很小的，但是因为余弦函数的曲线变化较为缓慢，即使观察距离和镜面反射角度相差较大，余弦值也仍然较高。通过进行p次方运算（p通常取120-150），可以是余弦函数曲线快速下降，保证只有在较小范围内能看到高光。</p><h4 id="环境光照"><a href="#环境光照" class="headerlink" title="环境光照"></a>环境光照</h4><p>顾名思义，环境光照是指环境中的光线照射产生的效果。公式如下：</p><script type="math/tex; mode=display">L_a=k_aI_a \\k_a:环境光系数 \\I_a:环境光强度</script><h4 id="Blinn-Phong反射"><a href="#Blinn-Phong反射" class="headerlink" title="Blinn-Phong反射"></a>Blinn-Phong反射</h4><p>将以上三种反射相加就得到了Blinn-Phong模型中的反射结果。</p><script type="math/tex; mode=display">L=L_a+L_d+L_s</script><h2 id="着色频率"><a href="#着色频率" class="headerlink" title="着色频率"></a>着色频率</h2><p>当确定了着色方式后，着色频率是接下来需要考虑的重要一环。着色频率决定了资源消耗和着色效果。如果着色频率过高，最终的着色效果会很好，但需要消耗大量资源；如果着色频率过低，消耗的资源相对较小，但效果可能不尽如人意。以下是几种典型的着色频率。</p><ul><li><strong>flat shading</strong>:对于每一个平面，根据平面的法线进行着色。</li><li><strong>Gouraud shading</strong>:对平面的每个顶点根据顶点的法线进行着色，平面内部的着色由顶点着色结果插值得出。</li><li><strong>Phong shading</strong>:求出每个顶点的法线并进行着色，对内部的每个像素都进行插值。</li></ul><p>如果我们知道了每个平面的法线，我们要如何得到每个顶点的法线？一种简单的做法是将与这个顶点相邻的平面的法线求平均：</p><script type="math/tex; mode=display">N_v=\frac {\Sigma_iN_i}{||\Sigma_iN_i||}</script><h2 id="图形管线（实时渲染管线）"><a href="#图形管线（实时渲染管线）" class="headerlink" title="图形管线（实时渲染管线）"></a>图形管线（实时渲染管线）</h2><p><strong>图形管线(Graphics Pipeline)</strong>是指渲染时的一套固定流程。</p><p><img src="/undefined/61766197/image-20241227155457889.png" alt="Graphics Pipeline"></p><p>当输入一堆三维空间中的顶点后，经过顶点处理、三角形处理、光栅化、片元处理、帧缓冲操作后就得到了输出：一个图像（由一组像素组成）。</p><h2 id="纹理映射"><a href="#纹理映射" class="headerlink" title="纹理映射"></a>纹理映射</h2><p>之前提到，一个着色点呈现出的效果和它的参数有关，但是我们不可能依次给每个着色点设置我们想要的参数。<strong>纹理映射(Texture Mapping)</strong>可以将二维的材质图包裹在三维物体的表面。以下是实现方法。</p><p>我们知道，三维物体是由一个个三角形组成的，那么我们可以将这些三角形映射二维材质图上的三角形中。这样一来，在进行纹理映射时，我们只需要找出三维物体的三角形和二维材质图的三角形之间的关系即可。我们使用uv坐标来实现。</p><p><img src="/undefined/61766197/image-20241227161719703.png" alt="uv"></p><h2 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h2><p>之前我们提到过，可以利用<strong>插值</strong>的方法得到平面内部的一些值。当计算完三角形顶点的属性后，利用插值可以在三角形内部进行平滑的过渡。</p><p>插值的原理是三角形内部的每个点根据其在三角形中的位置都有一个重心坐标(α,β,γ)。对于三角形ABC来说：</p><script type="math/tex; mode=display">(x,y)=\alpha A+\beta B+\gamma C \\\alpha +\beta +\gamma =1</script><p>重心坐标的求法是面积比：</p><script type="math/tex; mode=display">\alpha=\frac{A_a}{A_a+A_b+A_c}=\frac{-(x-x_B)(y_C-y_B)+(y-y_B)(x_C-x_B)}{-(x_A-x_B)(y_C-y_B)+(y_A-y_B)(x_C-x_B)} \\\beta=\frac{A_b}{A_a+A_b+A_c}=\frac{-(x-x_C)(y_A-y_C)+(y-y_C)(x_A-x_C)}{-(x_B-x_C)(y_A-y_C)+(y_B-y_C)(x_A-x_C)} \\\gamma=\frac{A_c}{A_a+A_b+A_c}=1-\alpha-\beta</script><p>对于任意要插值的属性V，计算公式如下：</p><script type="math/tex; mode=display">V=\alpha V_A+\beta V_B+\gamma V_C</script><h2 id="纹理放大和纹理缩小"><a href="#纹理放大和纹理缩小" class="headerlink" title="纹理放大和纹理缩小"></a>纹理放大和纹理缩小</h2><p>在理想情况下，物体大小和纹理大小应该是相同且一一对应的，但是在实际情况中，物体在不同的距离看起来会变大或变小，导致纹理和物体不能完全匹配，我们需要用一些方法来解决这个问题。</p><h3 id="纹理放大"><a href="#纹理放大" class="headerlink" title="纹理放大"></a>纹理放大</h3><p>当物体过近时，纹理对于物体来说过小，物体上点可能不会被准确地映射到纹理上的点上，而是一些点之间。解决这个问题的方法是<strong>双线性插值</strong>。</p><p>首先我们需要了解什么是线性插值。对于两个点v0,v1之间的点x，它的插值为：</p><script type="math/tex; mode=display">lerp(x,v_0,v_1)=v0+x(v_1-v_0)</script><p>而双线性插值则是在二维平面上做插值。</p><p><img src="/undefined/61766197/image-20241227180002234.png" alt="lerp"></p><p>首先我们要先在x轴方向做两次插值，得到u0和u1的位置，再用这两个点做一次线性插值，即可得到双线性插值的结果，公式如下：</p><script type="math/tex; mode=display">lerp(x, v_0, v_1) = v_0 + x(v_1-v0) \\u_0 = lerp(s, u_{00}, u_{10}) \\u_1 = lerp(s, u_{01}, u_{11}) \\f (x, y) = lerp(t, u_0, u_1)</script><p>有一种精度更高的插值方法:Bicubic插值，对周围十六个点做插值。</p><h3 id="纹理缩小"><a href="#纹理缩小" class="headerlink" title="纹理缩小"></a>纹理缩小</h3><p>当物体距离过远时，一个像素映射到纹理上的区域过大，采样不足导致走样，这和之前光栅化部分说到的走样的原理是相同的。可以将像素划分为多个小像素，但开销过大。如果可以快速得到像素对应纹理上这一片区域的平均值，就可以在一定程度上解决这个问题。</p><p><strong>Mipmap</strong>：这是一种快速，不准确，只针对正方形区域的范围查询。首先我们对纹理进行预处理，产生多层纹理，每一层纹理的分辨率都为之前的一半，直到1x1。在进行纹理映射时，只需要选择最接近的纹理即可。</p><p><strong>各向异性过滤</strong>：不止是正方形，长宽可以不同比例。课程中没有具体描述实现过程。大致原理是对映射点周围方形8个或更多的像素进行取样，获得平均值平均后映射到像素点上。</p><h2 id="纹理的应用"><a href="#纹理的应用" class="headerlink" title="纹理的应用"></a>纹理的应用</h2><p>在现代的GPU中，我们可以将纹理理解成一块内存，我们可以在上面做各种操作（点查询、范围查询）。</p><h3 id="环境光照-1"><a href="#环境光照-1" class="headerlink" title="环境光照"></a>环境光照</h3><p>可以用纹理来映射任何环境中照射来的光（例如犹他茶壶）。通常假设环境光都是从无限远处照射而来。</p><p>我们可以把整个环境光都记录在一个球上，并像地球仪转换为世界地图一样将其展开。但是这样会导致球的上下两端展开后产生扭曲。一个解决方法是将球体替换成边长和球直径相同的正方体。</p><h3 id="影响着色结果"><a href="#影响着色结果" class="headerlink" title="影响着色结果"></a>影响着色结果</h3><p>之前，我们都用纹理来替代Blinn-Phong模型中的kd，来影响物体的颜色。其实，纹理也可以改变其他属性，例如凹凸贴图（法线贴图），我们可以用纹理记录物体每一个位置的相对高度（法线移动的距离和方向），来造成凹凸不平的效果。计算方法如下：</p><p><img src="/undefined/61766197/image-20241228171808315.png" alt="image-20241228171808315"></p><p>现在的做法：使用<strong>位移贴图</strong>，通过改变三角形的顶点位置来产生更逼真的效果。需要模型足够精细，三角形数量够多。</p><h3 id="三维纹理"><a href="#三维纹理" class="headerlink" title="三维纹理"></a>三维纹理</h3><p>三维纹理不止存储物体表面的材质，还有三维空间任何一个点的材质。可以在三维空间中添加一个噪声函数，经过一系列处理后得到任意一点的效果。</p><h3 id="存储之前计算好的结果"><a href="#存储之前计算好的结果" class="headerlink" title="存储之前计算好的结果"></a>存储之前计算好的结果</h3><p>例如，在着色时我们不会考虑阴影等物体，当计算完阴影后，我们可以将环境光遮蔽贴图记录下来，并在之后直接应用。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【GAMES101】图形学学习记录——光栅化</title>
      <link href="/undefined/6cf9a142.html"/>
      <url>/undefined/6cf9a142.html</url>
      
        <content type="html"><![CDATA[<h1 id="【GAMES101】图形学学习记录——光栅化"><a href="#【GAMES101】图形学学习记录——光栅化" class="headerlink" title="【GAMES101】图形学学习记录——光栅化"></a>【GAMES101】图形学学习记录——光栅化</h1><p>我们想要显示的三维模型基本上都是由大量多边形（一般为三角形）组成的，而将这些三角形渲染在屏幕上的过程即为光栅化。</p><h2 id="视锥"><a href="#视锥" class="headerlink" title="视锥"></a>视锥</h2><p>首先，我们要知道我们的屏幕的信息。<br><img src="/undefined/6cf9a142/screen.png" alt></p><p><strong>fovY</strong>：这是一个角度，表示观测点距离平面的竖直范围。</p><p><strong>Aspect ratio</strong>：宽高比，字面意思，为平面宽和高的比值。</p><p>通过下面这张图，我们可以知道以上两个值和之前在投影部分所说物体的t、b、l、r等值的关系，具体如下：<br><img src="/undefined/6cf9a142/fov to lrbt.png" alt="alt text"></p><script type="math/tex; mode=display">tan\frac {fovY}2=\frac t{|n|}</script><script type="math/tex; mode=display">aspect=\frac rt</script><h2 id="屏幕"><a href="#屏幕" class="headerlink" title="屏幕"></a>屏幕</h2><p>什么是屏幕？在这里，我们将其简单地认为屏幕由一组具有单个颜色的像素排列而成。<br><img src="/undefined/6cf9a142/array of pixels.png" alt="alt text"></p><p>光栅化的过程即为决定每一个像素应该显示什么颜色的过程。</p><h2 id="视口变换"><a href="#视口变换" class="headerlink" title="视口变换"></a>视口变换</h2><p>在正交投影时，我们将物体转换到了一个(-1,1)^3的正则立方体中，而在视口变换中，我们要将其显示在我们的屏幕中。</p><p>做法为将立方体的XY平面拉伸为屏幕的宽高。</p><script type="math/tex; mode=display">M_{viewport}=\begin{bmatrix}\frac{width}2 & 0 & 0 & \frac{width}2 \\0 & \frac{height}2 & 0 & \frac{height}2 \\0 & 0 & 1 & 0 \\0 & 0 & 0 & 1\end{bmatrix}</script><h2 id="判断像素是否在三角形内"><a href="#判断像素是否在三角形内" class="headerlink" title="判断像素是否在三角形内"></a>判断像素是否在三角形内</h2><p>现在，我们已经将物体（即组成它的三角形）在屏幕上表示出来了，但是如何判断一个像素在不在某个三角形内，该不该被渲染呢？</p><p>将两个向量做叉积，可以得到新的向量，新的向量垂直于这两个向量，方向与这两个向量有关，例如在右手坐标系中：</p><script type="math/tex; mode=display">\vec x \times \vec y=\vec z</script><p>用叉积判断像素是否在三角形内的方法如下图所示：<br><img src="/undefined/6cf9a142/pointInTriangle.png" alt="alt text"></p><script type="math/tex; mode=display">若\overrightarrow {P_0P_1}\times\overrightarrow {P_0Q},\overrightarrow {P_1P_2}\times\overrightarrow {P_1Q},\overrightarrow {P_2P_0}\times\overrightarrow {P_2Q}得到的三个向量的值全都大于0或全都小于0，则点在三角形内部。</script><p>注意，这里我们用来判断的点是<strong>像素的中心</strong>。</p><p>如果一个点在三角形的边缘，我们可以自行决定这个点在三角形内部还是三角形外部。</p><p>优化：一个三角形的范围有限，将整个屏幕的像素都判断一遍较为浪费资源。因此，我们可以为每个三角形建立一个Bounding Box，只需要将Bounding Box内的像素比较。如图：<br><img src="/undefined/6cf9a142/BoundongBox1.png" alt="alt text"></p><p>或者是按行或列建立的Bounding Box（适用于较为瘦长的三角形）：<br><img src="/undefined/6cf9a142/BoundingBox2.png" alt="alt text"></p><h2 id="反走样"><a href="#反走样" class="headerlink" title="反走样"></a>反走样</h2><p>这部分内容涉及很多理论内容，技术内容较少，因此我将简略描述。（并不是因为我懒</p><p>当我们按照上面的方法进行三角形的光栅化后，我们会发现，得到的结果和我们想象中的差很多，边缘会有很多“锯齿”。对于这种现象，我们称之为<strong>走样</strong>。<br><img src="/undefined/6cf9a142/Jaggie.png" alt="alt text"></p><p>走样的本质原因是采样的频率过低，采样的结果的高频部分混叠导致的信息丢失。我们可以砍掉三角形的高频信息，根据三角形在像素内的覆盖面积进行模糊，再进行采样。具体的实现方法是超采样。</p><p><strong>超采样(Supersampling)</strong>：我们可以人为地在像素内模拟出多个点，分别判断这些点是否在三角形内，最终整个像素的结果有这些点综合得出（需要注意的是，最终的结果并不是像素是否在三角形内，而是一个中间结果）。<br><img src="/undefined/6cf9a142/supersampling.png" alt="alt text"></p><p>超采样的结果示例：<br><img src="/undefined/6cf9a142/superSamplingResult.png" alt="alt text"></p><p>如今工业界已经有了许多抗锯齿的手段，例如<strong>MSAA</strong>、<strong>FXAA</strong>、<strong>TAA</strong>。</p><h2 id="深度缓冲-Z-buffering"><a href="#深度缓冲-Z-buffering" class="headerlink" title="深度缓冲(Z-buffering)"></a>深度缓冲(Z-buffering)</h2><p>在光栅化的过程中，我们判断哪个物体被遮挡，哪个物体没有的方法是使用深度缓冲。深度缓冲记录了每一个像素的最小深度，即每个像素中离摄像机最近的z值。在进行渲染时，我们只需要渲染离摄像机最近的物体。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【GAMES101】图形学学习记录——变换</title>
      <link href="/undefined/d0768364.html"/>
      <url>/undefined/d0768364.html</url>
      
        <content type="html"><![CDATA[<h1 id="【GAMES101】图形学学习记录——变换"><a href="#【GAMES101】图形学学习记录——变换" class="headerlink" title="【GAMES101】图形学学习记录——变换"></a>【GAMES101】图形学学习记录——变换</h1><p>在正式开始学习计算机图形学之前，我们需要了解一些关于线性代数的基础知识。</p><h2 id="点和向量的表示"><a href="#点和向量的表示" class="headerlink" title="点和向量的表示"></a>点和向量的表示</h2><p>我们通常用一个二维列向量来表示一个点的位置或者一个向量，例如：</p><script type="math/tex; mode=display">\begin{bmatrix}   1\\   2\\  \end{bmatrix}</script><h2 id="矩阵的表示"><a href="#矩阵的表示" class="headerlink" title="矩阵的表示"></a>矩阵的表示</h2><p>矩阵的表示方式：</p><script type="math/tex; mode=display">\left[\begin{matrix}1 & 2 & 3 \\4 & 5 & 6 \\7 & 8 & 9\end{matrix}\right]</script><h2 id="图形的变换"><a href="#图形的变换" class="headerlink" title="图形的变换"></a>图形的变换</h2><p>矩阵和向量之间可以进行加减乘除等运算，这里省略。我们知道，一个图形可以用一系列点来表示。如果我们想要对一个图形进行变换操作，我们只需要让这个图形的所有点移动到我们想要的位置即可。我们可以通过对这些点进行运算来实现这个操作。</p><h3 id="镜像变换"><a href="#镜像变换" class="headerlink" title="镜像变换"></a>镜像变换</h3><p><img src="/undefined/d0768364/Reflection.png" alt="alt text"><br>对于这个变换，我们只需要让x或y值变成相反数。</p><script type="math/tex; mode=display">\left[ \begin{matrix}   -x \\   y \\  \end{matrix}  \right] = \left[ \begin{matrix}   -1 & 0\\   0 & 1  \end{matrix}  \right] \left[ \begin{matrix}   x \\   y  \end{matrix}  \right]</script><h3 id="切变"><a href="#切变" class="headerlink" title="切变"></a>切变</h3><p><img src="/undefined/d0768364/Shear.png" alt="alt text"></p><script type="math/tex; mode=display">\left[ \begin{matrix}   x+ay \\   y \\  \end{matrix}  \right] = \left[ \begin{matrix}   1 & a\\   0 & 1  \end{matrix}  \right] \left[ \begin{matrix}   x \\   y  \end{matrix}  \right]</script><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p><img src="/undefined/d0768364/Rotate.png" alt="alt text"></p><script type="math/tex; mode=display">\left[ \begin{matrix}   cosθ*x-sinθ*y \\   sinθ*x+cosθ*y \\  \end{matrix}  \right] = \left[ \begin{matrix}   cosθ & -sinθ\\   sinθ & cosθ  \end{matrix}  \right] \left[ \begin{matrix}   x \\   y  \end{matrix}  \right]</script><h3 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h3><p><img src="/undefined/d0768364/Translation.png" alt="alt text"></p><script type="math/tex; mode=display">\left[\begin{matrix}x+tx \\y+ty\end{matrix}\right]=\left[\begin{matrix}x \\y\end{matrix}\right]+\left[\begin{matrix}tx \\ty\end{matrix}\right]</script><h2 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h2><p>我们可以注意到，前三个变换都是用变换矩阵乘以点的形式，而平移操作需要我们用点的向量加上平移矩阵。有没有一种方法可以将平移操作也统一成乘法形式？</p><p>答案是<strong>齐次坐标</strong>。</p><p>我们将所有n维的矩阵和向量都加上一个维度，例如：</p><script type="math/tex; mode=display">\begin{bmatrix}   1\\   2\\\end{bmatrix}=>\begin{bmatrix}   1\\   2\\   0\end{bmatrix}</script><script type="math/tex; mode=display">\begin{bmatrix}1 & 2 \\3 & 4\end{bmatrix}=>\begin{bmatrix}1 & 2 & 0 \\3 & 4 & 0 \\0 & 0 & 1\end{bmatrix}</script><p>我们可以在多出来的这一个维度中表示平移的操作，例如：</p><script type="math/tex; mode=display">\begin{bmatrix}   x+tx\\   y+ty\\   1\end{bmatrix}=\begin{bmatrix}1 & 0 & tx \\0 & 1 & ty \\0 & 0 & 1\end{bmatrix}\begin{bmatrix}   x\\   y\\   1\end{bmatrix}</script><p>而对于向量矩阵来说，多出来的这个维度也有其作用。例如下面这个向量：</p><script type="math/tex; mode=display">\begin{bmatrix}   x\\   y\\   w\end{bmatrix}</script><p>当w=0时，这个向量矩阵表示的就是一个向量。当w=1时，这个向量矩阵表示的是一个点。</p><p>而当w!=0且w!=1时，它表示的如下的点：</p><script type="math/tex; mode=display">\begin{bmatrix}   x/w\\   y/w\\   1\end{bmatrix}</script><p>对于前三种变换矩阵，我们只需要加上一个维度即可，例如旋转：</p><script type="math/tex; mode=display">\begin{bmatrix}   cosθ & -sinθ\\   sinθ & cosθ  \end{bmatrix}=>\begin{bmatrix}   cosθ & -sinθ & 0\\   sinθ & cosθ & 0 \\   0 & 0 & 1  \end{bmatrix}</script><h2 id="变换的组合"><a href="#变换的组合" class="headerlink" title="变换的组合"></a>变换的组合</h2><p>如果我们想对对象进行一系列变换，我们只需要依次对对象左乘变换即可，但是要注意顺序。</p><p>例如，我们想对X做变换M1,M2,…Mn，乘积的顺序应该是：</p><script type="math/tex; mode=display">X'=Mn*...*M3*M2*M1*X</script><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="三维空间中的旋转公式"><a href="#三维空间中的旋转公式" class="headerlink" title="三维空间中的旋转公式"></a>三维空间中的旋转公式</h3><p>绕x轴：</p><script type="math/tex; mode=display">\begin{bmatrix}1 & 0 & 0 & 0\\0 & cosθ & -sinθ & 0  \\0 & sinθ & cosθ & 0 \\0 & 0 & 0 & 1\end{bmatrix}</script><p>绕y轴：</p><script type="math/tex; mode=display">\begin{bmatrix}cosθ & 0 & sinθ & 0\\0 & 1 & 0 & 0  \\-sinθ & 0 & cosθ & 0 \\0 & 0 & 0 & 1\end{bmatrix}</script><p>绕z轴：</p><script type="math/tex; mode=display">\begin{bmatrix}cos & -sinθ & 0 & 0\\sinθ & cosθ & 0 & 0  \\0 & 0 & 1 & 0 \\0 & 0 & 0 & 1\end{bmatrix}</script><h3 id="绕任意轴的旋转公式"><a href="#绕任意轴的旋转公式" class="headerlink" title="绕任意轴的旋转公式"></a>绕任意轴的旋转公式</h3><script type="math/tex; mode=display">R(n,α)=cos(α)I+(1-cos(α))nn^T+sin(α)\begin{bmatrix}0 & -n_z & n_y \\n_z & 0 & -n_x \\-n_y & n_x & 0\end{bmatrix}</script><h2 id="观测变换"><a href="#观测变换" class="headerlink" title="观测变换"></a>观测变换</h2><p>现在我们已经知道了在一个坐标空间中的物体是如何摆放和移动的，但是如果我们想要表示出我们是如何“看到”它们的，我们要怎么做呢？</p><p>例如，在现实生活中，火车的轨道是平行的，但是我们却能看到铁轨在远处交汇。通过观测变换，我们就能知道摄像机在指定的位置看到的物体是什么样的。</p><p>观测变换(MVP变换)分为：<strong>模型变换</strong>（模型摆放的位置）、<strong>视图变换</strong>（确定摄像机的位置和方向，并保证所有物体跟随摄像机移动）、<strong>投影变换</strong>（将三维空间的物体投影到二维平面上。</p><p>我们的重点是<strong>投影变换</strong>。</p><h3 id="相机的摆放"><a href="#相机的摆放" class="headerlink" title="相机的摆放"></a>相机的摆放</h3><p>以(0,0,0)为原点，将摄像机放在原点上，并以y轴方向为摄像机的上方向，使摄像机看向-z方向。这样摆放符合右手坐标系。</p><h3 id="投影变换"><a href="#投影变换" class="headerlink" title="投影变换"></a>投影变换</h3><p>投影变换分为两种：正交投影和透视投影。前者不遵循近大远小法则，而后者较为接近我们现实中看到的情况。</p><h4 id="正交投影"><a href="#正交投影" class="headerlink" title="正交投影"></a>正交投影</h4><p>假设物体在如下的立方体中，我们要做的是将其移动到正则立方体（(-1,1)^3）中。之后如何将其显示在屏幕上，我们会在下一节“光栅化”中讲解。<br><img src="/undefined/d0768364/cuboid.png" alt="alt text"></p><p>这个过程比较简单，我们只需要将其移动到原点，再进行缩放。变换矩阵如下：</p><script type="math/tex; mode=display">M_{ortho}=\begin{bmatrix}2/(r-1) & 0 & 0 & 0 \\0 & 2/(t-b) & 0 & 0 \\0 & 0 & 2/(n-f) & 0 \\0 & 0 & 0 & 1\end{bmatrix}\begin{bmatrix}1 & 0 & 0 & -(r+l)/2 \\0 & 1 & 0 & -(t+b)/2\\0 & 0 & 1 & -(n+f)/2 \\0 & 0 & 0 & 1\end{bmatrix}</script><h4 id="透视投影及推导"><a href="#透视投影及推导" class="headerlink" title="透视投影及推导"></a>透视投影及推导</h4><p>在透视投影中，我们要投影的是如下所示的一个棱台。直接做投影比较困难，但是我们可以将其“压缩”成一个长方体后再对其做正交投影。下面给出推导过程。</p><p>所谓的压缩是指我们需要将较远的大平面压缩为和n处小平面相同大小。这里有三个原则：</p><ul><li>近平面上的任意一点都不会发生改变</li><li>远平面上的任意一点的z值都不会发生改变</li><li>远平面上的中心点不会发生改变</li></ul><p><img src="/undefined/d0768364/Perspective.png" alt="alt text"></p><p>对于任意一点(x,y,z)，我们假设它投影到近平面后的点为(x’,y’,z’)，从侧面看去，可以得到如下的一个相似三角形：<br><img src="/undefined/d0768364/SimilarTriangle.png" alt="alt text"></p><p>根据相似三角形的性质，我们可以得到：</p><script type="math/tex; mode=display">y\prime=\frac nzy</script><p>同理可得：</p><script type="math/tex; mode=display">x\prime=\frac nzx</script><p>因此，我们的目标就是找到一个变换矩阵使得(x,y,z)转换成(x’,y’,x’)，也可以写做如下形式：</p><script type="math/tex; mode=display">\begin{bmatrix}x \\y \\z \\1\end{bmatrix}=>\begin{bmatrix}\frac nzx \\\frac nzy \\unknown \\1\end{bmatrix}==\begin{bmatrix}nx \\ny \\still\ unknown \\z\end{bmatrix}</script><p>通过这两个关系，我们已经可以推出变换矩阵的一部分。</p><script type="math/tex; mode=display">\begin{bmatrix}n & 0 & 0 & 0 \\0 & n & 0 & 0\\? & ? & ? & ? \\0 & 0 & 1 & 0\end{bmatrix}\begin{bmatrix}x \\y \\z \\1\end{bmatrix}=\begin{bmatrix}ny \\nx \\unknown \\1\end{bmatrix} \\\\</script><p>剩下的一个行向量，我们需要用之前说过的三个原则来解出。</p><p>对于近平面上的点，它在变换前和变换后的z值都是n，可以得出：</p><script type="math/tex; mode=display">\begin{bmatrix}x \\y \\n \\1\end{bmatrix}=>\begin{bmatrix}x \\y \\n \\1\end{bmatrix}==\begin{bmatrix}nx \\ny \\n^2 \\n\end{bmatrix}</script><script type="math/tex; mode=display">\begin{bmatrix} 0 & 0 & A & B\end{bmatrix}\begin{bmatrix} x \\y \\n \\1\end{bmatrix}=n^2</script><script type="math/tex; mode=display">An+B=n^2</script><p>对于远平面上的点，它在变换前和变换后的z值都是f，同理可得：</p><script type="math/tex; mode=display">Af+B=f^2</script><p>通过这两个方程，我们就可以解出A和B的值：</p><script type="math/tex; mode=display">A=n+f \\B=-nf</script><p>最终得到的变换矩阵如下：</p><script type="math/tex; mode=display">M_{persp->ortho}=\begin{bmatrix}n & 0 & 0 & 0 \\0 & n & 0 & 0\\0 & 0 & n+f & -nf \\0 & 0 & 1 & 0\end{bmatrix}</script><p>之后的过程和正交投影相同。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/manifest.json"/>
      <url>/manifest.json</url>
      
        <content type="html"><![CDATA[{"name":"Keshiki's Blog","short_name":"Keshiki","theme_color":"#39c5bb","background_color":"#39c5bb","display":"standalone","scope":"/","start_url":"/","icons":[{"src":"/img/siteicon/16.png","sizes":"16x16","type":"image/png"},{"src":"/img/siteicon/32.png","sizes":"32x32","type":"image/png"},{"src":"/img/siteicon/48.png","sizes":"48x48","type":"image/png"},{"src":"/img/siteicon/60.png","sizes":"60x60","type":"image/png"},{"src":"/img/siteicon/128.png","sizes":"128x128","type":"image/png"},{"src":"/img/siteicon/144.png","sizes":"144x144","type":"image/png"},{"src":"/img/siteicon/512.png","sizes":"512x512","type":"image/png"}],"splash_pages":null}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/runtime/runtime.min.js"/>
      <url>/js/runtime/runtime.min.js</url>
      
        <content type="html"><![CDATA[var now=new Date;function createtime(){var grt=new Date("15/01/2025 00:00:00");now.setTime(now.getTime()+250);var days=(now-grt)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-grt)/1e3/60/60-24*dnum,hnum=Math.floor(hours);1==String(hnum).length&&(hnum="0"+hnum);var minutes=(now-grt)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes);1==String(mnum).length&&(mnum="0"+mnum);var seconds=(now-grt)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds);1==String(snum).length&&(snum="0"+snum);let currentTimeHtml="";currentTimeHtml=hnum<18&&hnum>=9?`<img class='boardsign' src='https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-上班摸鱼中.svg' title='距离月入25k也就还差一个大佬带我~'><span class='textTip'> <br> 本站居然运行了 ${dnum} 天</span><span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span> <i class='fas fa-heartbeat' style='color:red'></i>`:`<img class='boardsign' src='https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-下班啦.svg' title='下班了就该开开心心的玩耍，嘿嘿~'><span class='textTip'> <br> 本站居然运行了 ${dnum} 天</span><span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span> <i class='fas fa-heartbeat' style='color:red'></i>`,document.getElementById("workboard")&&(document.getElementById("workboard").innerHTML=currentTimeHtml)}setInterval(()=>{createtime()},250);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* @font-face {  font-family: Candyhome;  src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/Candyhome.ttf);  font-display: swap;  font-weight: lighter;} */@font-face {    font-family: ZhuZiAYuanJWD;    src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/ZhuZiAWan.woff2);    font-display: swap;    font-weight: lighter;  }    div#menus {    font-family: "ZhuZiAYuanJWD";  }  h1#site-title {    font-family: ZhuZiAYuanJWD;    font-size: 3em !important;  }  a.article-title,  a.blog-slider__title,  a.categoryBar-list-link,  h1.post-title {    font-family: ZhuZiAYuanJWD;  }    .iconfont {    font-family: "iconfont" !important;    font-size: 3em;    /* 可以定义图标大小 */    font-style: normal;    -webkit-font-smoothing: antialiased;    -moz-osx-font-smoothing: grayscale;  }    /* 时间轴生肖icon */  svg.icon {    /* 这里定义svg.icon，避免和Butterfly自带的note标签冲突 */    width: 1em;    height: 1em;    /* width和height定义图标的默认宽度和高度*/    vertical-align: -0.15em;    fill: currentColor;    overflow: hidden;  }    .icon-zhongbiao::before {    color: #f7c768;  }    /* bilibli番剧插件 */  #article-container .bangumi-tab.bangumi-active {    background: var(--anzhiyu-theme);    color: var(--anzhiyu-ahoverbg);    border-radius: 10px;  }  a.bangumi-tab:hover {    text-decoration: none !important;  }  .bangumi-button:hover {    background: var(--anzhiyu-theme) !important;    border-radius: 10px !important;    color: var(--anzhiyu-ahoverbg) !important;  }  a.bangumi-button.bangumi-nextpage:hover {    text-decoration: none !important;  }  .bangumi-button {    padding: 5px 10px !important;  }    a.bangumi-tab {    padding: 5px 10px !important;  }  svg.icon.faa-tada {    font-size: 1.1em;  }  .bangumi-info-item {    border-right: 1px solid #f2b94b;  }  .bangumi-info-item span {    color: #f2b94b;  }  .bangumi-info-item em {    color: #f2b94b;  }    /* 解决artitalk的图标问题 */  #uploadSource > svg {    width: 1.19em;    height: 1.5em;  }    /*top-img黑色透明玻璃效果移除，不建议加，除非你执着于完全一图流或者背景图对比色明显 */  #page-header:not(.not-top-img):before {    background-color: transparent !important;  }    /* 首页文章卡片 */  #recent-posts > .recent-post-item {    background: rgba(255, 255, 255, 0.9);  }    /* 首页侧栏卡片 */  #aside-content .card-widget {    background: rgba(255, 255, 255, 0.9);  }    /* 文章页面正文背景 */  div#post {    background: rgba(255, 255, 255, 0.9);  }    /* 分页页面 */  div#page {    background: rgba(255, 255, 255, 0.9);  }    /* 归档页面 */  div#archive {    background: rgba(255, 255, 255, 0.9);  }    /* 标签页面 */  div#tag {    background: rgba(255, 255, 255, 0.9);  }    /* 分类页面 */  div#category {    background: rgba(255, 255, 255, 0.9);  }    /*夜间模式伪类遮罩层透明*/  [data-theme="dark"] #recent-posts > .recent-post-item {    background: #121212;  }    [data-theme="dark"] .card-widget {    background: #121212 !important;  }    [data-theme="dark"] div#post {    background: #121212 !important;  }    [data-theme="dark"] div#tag {    background: #121212 !important;  }    [data-theme="dark"] div#archive {    background: #121212 !important;  }    [data-theme="dark"] div#page {    background: #121212 !important;  }    [data-theme="dark"] div#category {    background: #121212 !important;  }    [data-theme="dark"] div#category {    background: transparent !important;  }  /* 页脚透明 */  #footer {    background: transparent !important;  }    /* 头图透明 */  #page-header {    background: transparent !important;  }    #rightside > div > button {    border-radius: 5px;  }    /* 滚动条 */    ::-webkit-scrollbar {    width: 10px;    height: 10px;  }    ::-webkit-scrollbar-thumb {    background-color: #3b70fc;    border-radius: 2em;  }    ::-webkit-scrollbar-corner {    background-color: transparent;  }    ::-moz-selection {    color: #fff;    background-color: #3b70fc;  }    /* 音乐播放器 */    /* .aplayer .aplayer-lrc {    display: none !important;  } */    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {    left: -66px !important;    transition: all 0.3s;    /* 默认情况下缩进左侧66px，只留一点箭头部分 */  }    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {    left: 0 !important;    transition: all 0.3s;    /* 鼠标悬停是左侧缩进归零，完全显示按钮 */  }    .aplayer.aplayer-fixed {    z-index: 999999 !important;  }    /* 评论框  */  .vwrap {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 30px 0px;  }    /* 设置评论框 */    .vcard {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 0px 0px;  }    /* md网站下划线 */  #article-container a:hover {    text-decoration: none !important;  }    #article-container #hpp_talk p img {    display: inline;  }    /* 404页面 */  #error-wrap {    position: absolute;    top: 40%;    right: 0;    left: 0;    margin: 0 auto;    padding: 0 1rem;    max-width: 1000px;    transform: translate(0, -50%);  }    #error-wrap .error-content {    display: flex;    flex-direction: row;    justify-content: center;    align-items: center;    margin: 0 1rem;    height: 18rem;    border-radius: 8px;    background: var(--card-bg);    box-shadow: var(--card-box-shadow);    transition: all 0.3s;  }    #error-wrap .error-content .error-img {    box-flex: 1;    flex: 1;    height: 100%;    border-top-left-radius: 8px;    border-bottom-left-radius: 8px;    background-color: #3b70fc;    background-position: center;    background-size: cover;  }    #error-wrap .error-content .error-info {    box-flex: 1;    flex: 1;    padding: 0.5rem;    text-align: center;    font-size: 14px;    font-family: Titillium Web, "PingFang SC", "Hiragino Sans GB", "Microsoft JhengHei", "Microsoft YaHei", sans-serif;  }  #error-wrap .error-content .error-info .error_title {    margin-top: -4rem;    font-size: 9em;  }  #error-wrap .error-content .error-info .error_subtitle {    margin-top: -3.5rem;    word-break: break-word;    font-size: 1.6em;  }  #error-wrap .error-content .error-info a {    display: inline-block;    margin-top: 0.5rem;    padding: 0.3rem 1.5rem;    background: var(--btn-bg);    color: var(--btn-color);  }    #body-wrap.error .aside-list {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    bottom: 0px;    position: absolute;    padding: 1rem;    width: 100%;    overflow: scroll;  }    #body-wrap.error .aside-list .aside-list-group {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    max-width: 1200px;    margin: 0 auto;  }    #body-wrap.error .aside-list .aside-list-item {    padding: 0.5rem;  }    #body-wrap.error .aside-list .aside-list-item img {    width: 100%;    object-fit: cover;    border-radius: 12px;  }    #body-wrap.error .aside-list .aside-list-item .thumbnail {    overflow: hidden;    width: 230px;    height: 143px;    background: var(--anzhiyu-card-bg);    display: flex;  }    #body-wrap.error .aside-list .aside-list-item .content .title {    -webkit-line-clamp: 2;    overflow: hidden;    display: -webkit-box;    -webkit-box-orient: vertical;    line-height: 1.5;    justify-content: center;    align-items: flex-end;    align-content: center;    padding-top: 0.5rem;    color: white;  }    #body-wrap.error .aside-list .aside-list-item .content time {    display: none;  }    /* 代码框主题 */  #article-container figure.highlight {    border-radius: 10px;  }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/runtime/runtime.js"/>
      <url>/js/runtime/runtime.js</url>
      
        <content type="html"><![CDATA[var now = new Date();function createtime() {    var grt = new Date("15/01/2025 00:00:00");    now.setTime(now.getTime() + 250);    var days = (now - grt) / 1e3 / 60 / 60 / 24,        dnum = Math.floor(days),        hours = (now - grt) / 1e3 / 60 / 60 - 24 * dnum,        hnum = Math.floor(hours);    1 == String(hnum).length && (hnum = "0" + hnum);    var minutes = (now - grt) / 1e3 / 60 - 1440 * dnum - 60 * hnum,        mnum = Math.floor(minutes);    1 == String(mnum).length && (mnum = "0" + mnum);    var seconds = (now - grt) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,        snum = Math.round(seconds);    1 == String(snum).length && (snum = "0" + snum);    let currentTimeHtml = "";    (currentTimeHtml =        hnum < 18 && hnum >= 9            ? `<img class='boardsign' src='https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-上班摸鱼中.svg' title='距离月入25k也就还差一个大佬带我~'><span class='textTip'> <br> 本站生存了 ${dnum} 天</span><span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span> <i class='fas fa-heartbeat' style='color:red'></i>`            : `<img class='boardsign' src='https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-下班啦.svg' title='下班了就该开开心心的玩耍，嘿嘿~'><span class='textTip'> <br> 本站生存了 ${dnum} 天</span><span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span> <i class='fas fa-heartbeat' style='color:red'></i>`),        document.getElementById("workboard") && (document.getElementById("workboard").innerHTML = currentTimeHtml);}setInterval(() => {    createtime();}, 250);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/ali_font.js"/>
      <url>/js/ali_font.js</url>
      
        <content type="html"><![CDATA[!(function (c) {    var l,      h,      a,      t,      i,      v =        '<svg><symbol id="icon-dragon_chen" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#D6B196" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-498.122105 265.620211L431.157895 754.526316V485.052632h-66.074948c-14.470737 110.645895-44.355368 197.066105-102.696421 260.742736l-39.747368-36.432842C306.526316 617.876211 323.368421 462.901895 323.368421 242.526316V215.578947h377.263158v53.894737H377.182316c-0.404211 58.260211-2.209684 112.128-6.359579 161.684211H700.631579v53.894737h-122.152421a481.172211 481.172211 0 0 0 76.826947 119.70021l66.479158-39.855158 27.728842 46.214737-54.460631 32.687158c29.507368 24.953263 63.757474 45.675789 102.80421 58.098526l-16.303158 51.361684c-134.224842-42.711579-222.773895-167.073684-261.551158-268.207157H485.052632v221.857684l68.985263-41.391158 27.728842 46.214737-109.783579 65.886316zM646.736842 377.263158h-215.578947v-53.894737h215.578947v53.894737z" fill="#231F20" ></path></symbol><symbol id="icon-dog_xu" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#D6B196" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-375.592421 150.393263c33.684211 44.544 75.210105 74.698105 124.739369 90.812632l11.425684 3.718737 10.401684-6.009264C781.204211 727.740632 808.421053 622.565053 808.421053 592.842105h-53.894737c0 22.069895-19.132632 80.869053-33.711158 103.504842-34.816-14.605474-64.538947-39.262316-89.249684-74.13221 48.316632-55.269053 92.079158-117.328842 120.535579-179.900632l-49.044211-22.285473c-23.767579 52.250947-59.742316 104.717474-100.055579 152.656842-24.010105-50.930526-41.148632-115.927579-51.658105-195.395369H700.631579v-53.894737h-155.189895A1848.050526 1848.050526 0 0 1 538.947368 161.684211h-53.894736c0 58.206316 2.155789 112.074105 6.494315 161.68421H323.368421v26.947368c0 216.549053-13.177263 263.545263-100.702316 359.046737l39.747369 36.432842c63.326316-69.093053 92.806737-118.272 105.714526-206.848H485.052632v-53.894736h-111.319579a1742.147368 1742.147368 0 0 0 3.449263-107.789474h120.158316c12.611368 98.250105 35.031579 177.475368 67.395368 238.187789-61.978947 65.536-128.053895 117.975579-173.298526 142.282106l25.519158 47.481263c47.589053-25.573053 114.095158-77.446737 177.55621-142.821053z m125.170526-411.971368l-80.842105-80.842106-38.103579 38.103579 80.842105 80.842106 38.103579-38.103579z" fill="#231F20" ></path></symbol><symbol id="icon-dog" viewBox="0 0 1024 1024"><path d="M894.814316 904.434526l83.240421-183.134315-13.824-13.204211c-0.485053-0.458105-45.648842-47.589053-47.939369-185.263158-0.134737-7.922526-0.134737-33.953684-0.134736-55.996631-30.693053 15.306105-70.090105 19.887158-106.09179 19.887157-92.752842 0-163.624421-23.983158-210.647579-71.275789a192.512 192.512 0 0 1-27.944421-36.513684H377.263158v377.263158c342.662737 0 403.105684 51.092211 494.592 128.377263 7.922526 6.682947 15.521684 13.312 22.959158 19.86021z" fill="#85C3DE" ></path><path d="M326.063158 282.947368c0 34.250105-13.231158 44.463158-29.642105 44.463158s-29.642105-10.213053-29.642106-44.463158c0-34.223158 13.231158-44.463158 29.642106-44.463157s29.642105 10.24 29.642105 44.463157zM269.473684 430.295579v311.646316L190.275368 916.210526h59.203369L323.368421 753.637053V377.263158h-26.947368c-119.403789 0-172.732632-53.382737-185.505685-107.789474h35.624421c51.092211 0 68.581053-15.764211 120.535579-62.544842 12.773053-11.506526 28.079158-25.276632 47.023158-41.741474l18.351158-15.952842-69.658947-99.139368-44.085895 30.989474 41.768421 59.472842c-11.183158 9.862737-20.884211 18.593684-29.480421 26.327579C180.736 212.156632 176.235789 215.578947 146.539789 215.578947H53.894737v26.947369c0 88.710737 66.910316 178.149053 215.578947 187.769263z m216.710737-161.414737c2.290526 71.733895 28.698947 136.326737 75.048421 182.918737C618.711579 509.628632 702.437053 538.947368 810.091789 538.947368c18.593684 0 36.190316-1.158737 52.628211-3.449263 3.745684 111.265684 33.630316 170.334316 51.496421 196.015158l-38.507789 84.722526C782.174316 742.049684 688.774737 700.631579 377.263158 700.631579v53.894737c34.277053 0 65.697684 0.512 94.639158 1.509052L374.595368 970.105263h59.203369l96.013474-211.240421c66.182737 4.338526 117.005474 11.829895 157.911578 22.016L626.229895 916.210526h59.176421l54.16421-119.134315c47.616 18.405053 79.737263 42.091789 113.125053 69.739789L805.753263 970.105263h59.203369l113.071157-248.778105-13.824-13.204211c-0.485053-0.458105-45.648842-47.589053-47.939368-185.263158C985.168842 498.553263 1024 447.811368 1024 377.263158c0-95.205053-66.506105-161.684211-161.684211-161.684211v53.894737c65.482105 0 107.789474 42.307368 107.789474 107.789474 0 89.088-87.013053 107.789474-160.013474 107.789474-92.752842 0-163.624421-23.983158-210.647578-71.27579-30.315789-30.504421-45.891368-65.832421-53.35579-98.735158 11.210105 6.952421 22.932211 13.338947 35.274105 19.186527l23.04-48.720843c-92.106105-43.654737-148.992-128.646737-219.243789-243.981473l-46.026105 28.05221c49.448421 81.246316 92.968421 148.506947 147.051789 199.302737z" fill="#231F20" ></path></symbol><symbol id="icon-goat" viewBox="0 0 1024 1024"><path d="M548.378947 646.736842a952.32 952.32 0 0 1 140.90779-161.68421H107.789474c0 107.600842 0 107.600842-63.649685 169.283368l-13.069473 12.665263L66.721684 754.526316h417.172211c20.345263-41.472 43.654737-77.446737 64.485052-107.789474z" fill="#F7C768" ></path><path d="M608.256 144.734316C555.762526 115.577263 506.098526 107.789474 485.052632 107.789474V53.894737c32.579368 0 91.270737 11.452632 149.369263 43.735579 75.290947 41.822316 130.694737 94.531368 171.385263 150.878316C755.873684 288.013474 697.101474 323.368421 646.736842 323.368421h-107.789474v-53.894737h107.789474c20.506947 0 48.424421-11.210105 80.437895-31.285895a471.04 471.04 0 0 0-118.918737-93.453473zM832.673684 342.231579c-16.384 0-29.642105 10.24-29.642105 44.463158 0 34.250105 13.231158 44.463158 29.642105 44.463158s29.642105-10.213053 29.642105-44.463158c0-34.223158-13.231158-44.463158-29.642105-44.463158zM1024 619.789474C1024 347.109053 901.066105 122.448842 686.753684 3.395368l-26.165895 47.104C914.324211 191.461053 964.688842 440.400842 969.647158 592.842105h-84.506947c-17.92-35.624421-45.352421-69.12-87.013053-101.995789l-16.788211-13.285053-16.734315 13.392842c-66.128842 52.897684-134.629053 127.083789-187.311158 209.677474H102.965895l-8.272842-20.318316C159.043368 617.013895 161.684211 603.109053 161.684211 485.052632v-53.894737h485.052631v-53.894737H161.684211c0-80.384 14.309053-110.026105 66.586947-137.916632l-25.384421-47.535158C123.365053 234.226526 107.789474 291.920842 107.789474 377.263158v107.789474c0 107.600842 0 107.600842-63.649685 169.283368l-13.069473 12.665263L110.618947 862.315789h58.206316l-43.897263-107.789473h103.477895l43.897263 107.789473h58.206316l-43.897263-107.789473h259.47621C508.981895 824.939789 485.052632 899.152842 485.052632 970.105263h53.894736c0-68.688842 27.270737-144.060632 68.958316-215.578947H687.157895c7.410526 0 13.473684 6.063158 13.473684 13.473684V862.315789h53.894737v-94.315789c0-37.160421-30.208-67.368421-67.368421-67.368421h-44.65179c40.771368-58.017684 89.438316-111.427368 138.913684-153.626947C841.512421 600.037053 862.315789 655.225263 862.315789 754.526316h53.894737c0-38.912-2.748632-74.482526-11.102315-107.789474H1024v-26.947368z" fill="#231F20" ></path></symbol><symbol id="icon-goat_wei" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#D6B196" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-431.157895 50.202947c52.304842 70.925474 136.973474 152.144842 232.528843 190.383158l19.994947-50.041263c-109.271579-43.708632-202.805895-152.629895-238.780632-217.49221H808.421053v-53.894737H538.947368v-53.894737h215.578948v-53.894737h-215.578948V161.684211h-53.894736v161.68421h-215.578948v53.894737h215.578948v53.894737H215.578947v53.894737h255.757474c-35.974737 64.862316-129.536 173.783579-238.807579 217.49221l20.021895 50.041263c95.528421-38.238316 180.197053-119.484632 232.501895-190.383158V808.421053h53.894736v-246.218106z" fill="#231F20" ></path></symbol><symbol id="icon-dragon" viewBox="0 0 1024 1024"><path d="M366.376421 344.441263l152.980211-152.98021c43.142737-43.142737 141.204211-9.216 270.201263 115.738947-15.225263 9.835789-25.114947 15.818105-44.13979 32.256s-38.076632 35.489684-59.418947 56.832c-4.203789 4.203789-51.173053 53.221053-78.740211 82.027789-10.805895-12.126316-22.743579-24.171789-34.654315-36.082526L493.136842 362.792421l-54.218105 54.218105-72.542316-72.569263zM862.315789 512c0 46.834526-45.352421 80.842105-107.789473 80.842105-108.948211 0-189.359158-28.806737-267.129263-56.697263C414.100211 509.871158 344.872421 485.052632 258.182737 485.052632 80.788211 485.052632 0 588.126316 0 683.897263h53.894737C73.216 659.779368 135.302737 646.736842 177.340632 646.736842c77.338947 0 223.124211 23.282526 291.893894 47.912421C547.462737 722.701474 615.989895 754.526316 734.315789 754.526316 862.315789 754.526316 916.210526 670.315789 916.210526 512h-53.894737z" fill="#FF8787" ></path><path d="M552.421053 1024c-69.766737 0-113.825684-13.958737-156.402527-27.459368-54.487579-17.273263-110.807579-35.004632-232.421052-26.516211l-3.826527-53.733053c131.718737-9.458526 195.934316 10.967579 252.52379 28.887579 42.226526 13.365895 78.686316 24.926316 140.126316 24.926316 92.752842 0 148.210526-57.936842 148.210526-113.960421 0-16.949895-5.524211-101.618526-114.634105-101.618526-64.970105 0-112.747789 23.336421-163.328 48.02021C365.325474 830.571789 300.301474 862.315789 204.288 862.315789 85.908211 862.315789 0 787.294316 0 683.897263 0 588.126316 80.788211 485.052632 258.182737 485.052632c86.689684 0 155.917474 24.818526 229.214316 51.09221 45.810526 16.410947 92.564211 33.172211 145.488842 44.166737 9.000421-7.033263 13.850947-16.276211 13.850947-26.758737 0-37.187368-37.672421-74.859789-74.13221-111.265684l-3.287579-3.287579 38.103579-38.103579 3.260631 3.287579C652.853895 446.275368 700.631579 494.026105 700.631579 553.552842c0 12.719158-2.802526 24.926316-7.976421 36.109474A594.997895 594.997895 0 0 0 754.526316 592.842105c62.437053 0 107.789474-34.007579 107.789473-80.842105 0-58.853053-52.870737-110.268632-108.840421-164.702316l-8.057263-7.841684c-19.024842 16.437895-38.076632 35.489684-59.418947 56.832l-38.103579-38.103579c74.805895-74.832842 134.898526-134.898526 268.314947-141.931789V55.619368c-63.407158 7.787789-120.993684 39.424-121.667368 39.801264l-15.818105 8.811789-14.120421-11.344842C731.701895 66.452211 709.712842 53.894737 673.684211 53.894737c-41.418105 0-74.347789 25.869474-109.190737 53.301895-26.624 20.911158-54.137263 42.549895-86.851369 53.194105L469.342316 161.684211h-69.093053l-105.525895 105.525894-38.103579-38.130526L324.015158 161.684211H161.684211V107.789474h303.104c22.231579-8.272842 43.708632-25.168842 66.398315-42.981053C569.829053 34.438737 613.618526 0 673.684211 0c48.909474 0 81.408 17.946947 110.888421 40.097684C813.702737 26.300632 877.729684 0 943.157895 0h26.947368v323.368421h-53.894737v-53.167158c-54.164211 3.098947-92.914526 15.845053-127.002947 36.675369l1.832421 1.778526C852.587789 368.505263 916.210526 430.376421 916.210526 512c0 60.928-43.708632 109.945263-107.789473 127.622737V700.631579h53.894736v-53.894737h53.894737v53.894737h53.894737v53.894737h-53.894737v53.894737h-53.894737v-53.894737h-53.894736c-29.722947 0-53.894737-24.171789-53.894737-53.894737v-53.894737c-118.325895 0-207.063579-31.797895-285.318737-59.877053C400.437895 562.229895 335.494737 538.947368 258.182737 538.947368 117.059368 538.947368 53.894737 611.732211 53.894737 683.897263 53.894737 757.221053 115.738947 808.421053 204.288 808.421053c11.910737 0 23.228632-0.538947 34.034526-1.536C248.454737 796.321684 269.473684 770.640842 269.473684 739.166316c0-33.118316-43.088842-70.979368-58.152421-81.596632l30.935579-44.139789c8.299789 5.793684 81.111579 58.664421 81.111579 125.736421 0 19.429053-4.527158 37.052632-10.994526 52.304842 30.773895-10.051368 58.314105-23.498105 86.662737-37.349053C452.877474 727.848421 508.577684 700.631579 585.997474 700.631579 702.410105 700.631579 754.526316 778.725053 754.526316 856.144842 754.526316 938.657684 678.912 1024 552.421053 1024z m-21.180632-623.104L493.136842 362.792421l137.889684-137.889684 38.103579 38.103579-137.889684 137.889684z m-126.760421-18.351158l-38.103579-38.103579 152.980211-152.98021 38.103579 38.103579-152.980211 152.98021z m282.004211-218.624c15.494737-9.754947 43.331368-31.447579 43.331368-31.447579-25.734737-27.809684-49.556211-33.333895-67.368421-29.07621-19.240421 4.608-37.753263 24.602947-37.753263 24.602947s42.253474 22.447158 61.790316 35.920842z" fill="#231F20" ></path></symbol><symbol id="icon-horse" viewBox="0 0 1024 1024"><path d="M776.003368 646.736842c16.599579-99.947789 43.439158-181.086316 83.213474-256.538947l6.817684-12.934737H269.473684c-36.756211 0-53.894737 54.945684-53.894737 92.05221 0 46.753684 6.656 77.527579 70.278737 176.074106l84.533895 128.269473L498.876632 646.736842h277.126736z" fill="#FFAF6E" ></path><path d="M1024 0v404.210526c0 33.333895 0 134.736842-92.079158 134.736842h-13.824l-78.362947-109.056c-22.743579 49.906526-40.340211 103.046737-53.490527 162.950737h115.092211C937.310316 592.842105 970.105263 625.637053 970.105263 661.638737c0 60.631579-69.389474 154.300632-77.312 164.75621l-43.008-32.471579C875.466105 759.861895 916.210526 693.813895 916.210526 661.638737c0-5.982316-8.919579-14.901895-14.901894-14.901895h-125.332211C761.128421 736.121263 754.526316 840.569263 754.526316 970.105263h-53.894737c0-283.971368 31.097263-453.605053 110.888421-605.049263l20.318316-38.534737 112.801684 156.995369c14.443789-4.419368 25.465263-20.938105 25.465263-79.306106V0h53.894737z m-161.684211 161.684211h53.894737V0h-53.894737v80.842105c-17.381053-14.955789-38.184421-26.947368-80.842105-26.947368h-134.736842v53.894737h134.736842c37.672421 0 80.842105 40.906105 80.842105 53.894737z m-107.789473 0h-215.578948v53.894736h161.684211l53.894737-53.894736zM300.894316 766.544842L400.680421 916.210526h64.754526l-95.043368-142.551579L498.876632 646.736842h167.855157a1212.631579 1212.631579 0 0 1 9.431579-53.894737h-199.383579l-175.885473 173.702737z m109.97221-184.400842l-37.861052-38.319158-132.419369 130.802526C173.729684 571.095579 161.684211 529.812211 161.684211 469.315368 161.684211 398.578526 199.464421 323.368421 269.473684 323.368421h323.368421l53.894737-53.894737H269.473684c-6.709895 0-13.258105 0.565895-19.698526 1.482105C234.927158 249.451789 204.638316 215.578947 160.633263 215.578947 65.967158 215.578947 0 349.291789 0 469.315368c0 70.170947 16.141474 136.650105 49.232842 202.671158L6.197895 723.833263l41.472 34.41179 66.128842-79.737264-8.704-16.033684C83.105684 622.133895 53.894737 558.214737 53.894737 469.315368 53.894737 368.451368 106.765474 269.473684 160.633263 269.473684c13.231158 0 25.815579 9.889684 35.43579 20.533895C142.874947 321.967158 107.789474 388.500211 107.789474 469.315368c0 78.201263 19.698526 130.937263 93.642105 243.981474l-55.296 54.622316L280.899368 970.105263h64.754527l-130.048-195.072 195.260631-192.889263z" fill="#231F20" ></path></symbol><symbol id="icon-monkey_shen" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#BBC4C9" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-431.157895 134.736842h161.684211v53.894737h53.894737V269.473684h-215.578948V161.684211h-53.894736v107.789473h-215.578948v431.157895h53.894737v-53.894737h161.684211v215.578947h53.894736v-215.578947z m0-161.68421h161.684211v107.789473h-161.684211v-107.789473z m-215.578947 0h161.684211v107.789473h-161.684211v-107.789473z m215.578947-161.684211h161.684211v107.789474h-161.684211v-107.789474z m-215.578947 0h161.684211v107.789474h-161.684211v-107.789474z" fill="#231F20" ></path></symbol><symbol id="icon-ox_chou" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#D6B196" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-161.68421 188.631579h-159.555369c13.985684-172.813474 43.115789-357.429895 70.817684-385.158737L700.631579 269.473684H323.368421v53.894737h107.169684c-1.940211 45.756632-8.192 103.962947-15.76421 161.684211H323.368421v53.894736h83.968c-9.862737 68.446316-20.264421 130.128842-25.734737 161.684211H215.578947v53.894737h592.842106v-53.894737z m-346.543158-161.684211h149.800421a3313.717895 3313.717895 0 0 0-16.842105 161.684211h-158.477474c6.036211-35.247158 16.114526-95.636211 25.519158-161.684211z m22.608842-215.578947h171.735579c-15.198316 41.121684-27.405474 100.594526-36.890948 161.684211h-150.123789c7.383579-57.505684 13.419789-115.361684 15.279158-161.684211z" fill="#231F20" ></path></symbol><symbol id="icon-monkey" viewBox="0 0 1024 1024"><path d="M757.733053 485.052632H565.894737a80.842105 80.842105 0 0 0-80.842105 80.842105v215.578947c0 40.96 43.546947 99.678316 77.446736 139.210105C596.426105 960.215579 603.055158 970.105263 603.055158 970.105263H754.526316s15.144421-18.674526 45.891368-58.071579S862.315789 809.984 862.315789 717.608421c0-89.573053-47.993263-166.346105-104.582736-232.555789z" fill="#C3D686" ></path><path d="M538.947368 1024h-53.894736c0-32.794947 25.869474-87.417263 77.446736-103.316211C528.599579 881.152 485.052632 822.433684 485.052632 781.473684c0-44.570947 36.271158-80.842105 80.842105-80.842105h80.842105v53.894737h-80.842105a26.947368 26.947368 0 0 0-26.947369 26.947368c0 19.725474 36.675368 77.473684 92.133053 134.736842h88.602947c20.210526-14.147368 88.737684-71.464421 88.737685-198.602105 0-108.382316-93.237895-202.967579-168.151579-278.986105-49.502316-50.202947-88.576-89.842526-98.735158-128.61979-11.749053-44.732632-21.584842-112.586105-26.327579-148.318315H377.263158c-45.136842 0-89.519158 8.434526-121.802105 53.894736H431.157895v53.894737c-97.28 0-107.789474 113.071158-107.789474 161.684211v53.894737h53.894737v161.68421h-53.894737v-107.789474h-26.947368c-170.253474 0-188.631579-94.234947-188.631579-134.736842 0-31.043368 35.220211-72.326737 55.727158-93.722947 2.694737-14.686316 5.847579-28.348632 9.431579-41.013895H161.684211V215.578947h31.528421C239.642947 120.993684 317.224421 107.789474 377.263158 107.789474h185.640421l2.802526 23.794526c0.134737 1.050947 12.719158 106.657684 27.944421 164.756211 6.494316 24.872421 44.624842 63.514947 84.965053 104.448C760.481684 483.813053 862.315789 587.129263 862.315789 717.608421c0 92.375579-31.124211 155.028211-61.898105 194.425263C904.919579 892.146526 970.105263 803.004632 970.105263 673.684211c0-91.405474-42.819368-154.381474-84.237474-215.255579C847.791158 402.458947 808.421053 344.576 808.421053 269.473684c0-119.349895 87.093895-161.684211 161.68421-161.68421v53.894737c-32.417684 0-107.789474 10.509474-107.789474 107.789473 0 58.502737 31.555368 104.933053 68.096 158.639158C974.282105 492.597895 1024 565.679158 1024 673.684211c0 177.286737-108.301474 296.421053-269.473684 296.421052h-161.684211c-37.672421 0-53.894737 40.906105-53.894737 53.894737zM229.214316 269.473684a384.808421 384.808421 0 0 0-14.012632 58.341053l-1.401263 8.488421-6.090105 6.117053c-22.878316 22.932211-44.813474 52.601263-46.026105 62.275368 0 56.805053 53.76 75.264 107.789473 79.386947V431.157895c0-58.691368 13.473684-119.619368 46.511158-161.684211h-86.770526zM323.368421 1024h-53.894737c0-32.794947 25.869474-87.417263 77.446737-103.316211C313.020632 881.152 269.473684 822.433684 269.473684 781.473684c0-44.570947 36.271158-80.842105 80.842105-80.842105h45.16379A188.847158 188.847158 0 0 1 565.894737 592.842105h134.736842v53.894737h-134.736842c-74.293895 0-134.736842 60.442947-134.736842 134.736842v26.516211l-53.894737 0.377263V781.473684c0-9.162105 0.646737-18.135579 1.913263-26.947368H350.315789c-14.848 0-26.947368 12.072421-26.947368 26.947368 0 19.725474 36.675368 77.473684 92.133053 134.736842H431.157895v53.894737h-53.894737c-37.672421 0-53.894737 40.906105-53.894737 53.894737z" fill="#231F20" ></path></symbol><symbol id="icon-horse_wu" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#FF8787" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-431.157895 26.947368h269.473685v-53.894736H538.947368v-161.684211h161.684211v-53.894737H411.001263c12.045474-33.28 20.156632-69.793684 20.156632-107.789473h-53.894737c0 121.963789-105.364211 233.391158-106.415158 234.496l38.858105 37.349052c2.883368-3.018105 43.816421-46.133895 77.392842-110.160842H485.052632v161.684211H215.578947v53.894736h269.473685v323.368421h53.894736V538.947368z" fill="#231F20" ></path></symbol><symbol id="icon-ox" viewBox="0 0 1025 1024"><path d="M540.294737 754.526316h215.578947c20.210526 0 35.112421 1.374316 53.894737 4.581052 91.863579 15.656421 145.354105 67.691789 161.684211 86.069895V916.210526h53.894736V635.580632l-7.895579-7.895579c-9.269895-9.269895-36.513684-49.232842-44.032-196.527158H540.294737a161.684211 161.684211 0 0 0-161.684211 161.68421v131.098948c43.304421 20.210526 97.28 30.585263 161.684211 30.585263z" fill="#FFAF6E" ></path><path d="M1025.347368 635.580632V916.210526h-53.894736v-71.033263c-16.330105-18.405053-69.820632-70.413474-161.684211-86.069895V916.210526h-53.894737v-161.68421h-107.789473v215.578947h-53.894737V700.631579h161.68421c100.998737 0 172.570947 38.669474 215.578948 71.868632v-115.738948c-33.684211-43.627789-51.712-137.458526-53.706106-279.498105H701.978947c-76.934737 0-127.218526-26.219789-175.804631-51.550316a1556.048842 1556.048842 0 0 0-26.839579-13.743158c-26.839579 26.004211-66.209684 44.921263-115.738948 55.511579 24.441263 22.986105 60.874105 52.116211 106.469053 72.838737l-22.312421 49.044211c-76.584421-34.816-129.589895-88.926316-150.824421-113.125053-10.644211 0.619789-21.477053 1.024-32.687158 1.024a473.734737 473.734737 0 0 1-123.365053-15.952842l-93.022315 186.314105 68.581052 53.86779C167.882105 579.557053 237.891368 538.947368 324.715789 538.947368v53.894737c-95.986526 0-170.361263 62.490947-171.088842 63.137684l-16.78821 14.282106-136.838737-107.358316 109.729684-219.809684C46.430316 314.448842 1.347368 267.371789 1.347368 199.868632 1.347368 89.815579 121.586526 53.894737 163.031579 53.894737v53.894737c-14.120421 0-107.789474 17.165474-107.789474 92.079158C55.242105 290.465684 192.188632 323.368421 284.240842 323.368421c67.907368 0 122.421895-12.988632 157.696-35.624421-42.711579-14.336-95.097263-23.120842-169.337263-18.324211l-3.503158-53.786947c95.878737-6.117053 160.148211 8.515368 211.429053 28.833684C484.244211 235.439158 486.4 225.818947 486.4 215.578947c0-48.855579-57.829053-76.288-58.394947-76.557473l22.393263-49.017263C454.063158 91.648 540.294737 131.826526 540.294737 215.578947c0 18.566737-3.422316 35.84-9.997474 51.631158 7.060211 3.584 13.985684 7.168 20.776421 10.698106C597.854316 302.322526 638.248421 323.368421 701.978947 323.368421h269.473685v26.947368c0 214.689684 35.220211 266.590316 45.999157 277.369264l7.895579 7.895579z m-729.384421 25.141894l-98.789052 118.541474 86.797473 137.835789 45.594948-28.725894-65.913263-104.690527 37.052631-44.43621C358.642526 785.192421 439.080421 808.421053 540.294737 808.421053v-53.894737c-99.893895 0-175.077053-24.549053-223.474526-72.946527l-20.857264-20.857263z" fill="#231F20" ></path></symbol><symbol id="icon-rabbit_mao" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#7DD47F" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-377.263158-188.631579h107.789474v323.368421c-20.48 0-39.936-11.264-40.016842-11.317895l-27.728842 46.214737c3.206737 1.940211 32.660211 18.997895 67.745684 18.997895 30.746947 0 53.894737-23.147789 53.894737-53.894737V269.473684h-215.578948v538.947369h53.894737V323.368421z m-107.789473 242.526316v-242.526316h-53.894737v196.904421l-107.789474 40.421053v-243.927579l169.094737-48.316632-14.821053-51.819789L269.473684 276.102737v304.801684l-36.405895 13.662316 18.917053 50.472421 178.741895-67.018105c-5.039158 69.928421-55.269053 106.981053-165.133474 122.933894l7.733895 53.328842C325.712842 746.657684 485.052632 723.536842 485.052632 565.894737z" fill="#231F20" ></path></symbol><symbol id="icon-rabbit" viewBox="0 0 1024 1024"><path d="M680.96 488.744421a1666.667789 1666.667789 0 0 0-54.433684-23.95621c-16.006737 12.234105-33.899789 20.264421-60.631579 20.264421h-80.842105c-36.810105 0-83.644632 30.396632-104.394106 67.772631-42.819368 77.123368-53.409684 117.813895-11.021473 201.701053C397.096421 808.879158 431.157895 876.409263 431.157895 970.105263h338.539789l68.338527-138.859789c20.129684-40.96 24.252632-73.701053 24.252631-110.349474 0.026947-57.397895-25.061053-159.717053-181.328842-232.151579z" fill="#FFBDD8" ></path><path d="M862.315789 720.896c0 36.621474-4.122947 69.389474-24.252631 110.349474L769.697684 970.105263H485.052632v-53.894737h48.370526C507.877053 880.074105 485.052632 833.509053 485.052632 781.473684c0-59.418947 24.171789-113.313684 63.218526-152.360421l38.103579 38.103579A161.091368 161.091368 0 0 0 538.947368 781.473684c0 54.784 35.381895 104.043789 63.514948 134.736842h133.712842l53.490526-108.759579c15.710316-31.851789 18.755368-55.834947 18.755369-86.554947 0-80.976842-63.434105-150.096842-178.607158-195.503158-17.542737 8.138105-38.292211 13.554526-63.919158 13.554526h-80.842105c-13.958737 0-43.924211 15.979789-57.290106 40.016843l-47.104-26.165895C401.408 515.449263 448.242526 485.052632 485.052632 485.052632h80.842105c37.268211 0 57.478737-15.440842 79.090526-36.45979C625.367579 336.195368 549.753263 269.473684 485.052632 269.473684h-107.789474a21.288421 21.288421 0 0 0-5.955369 2.021053A683.762526 683.762526 0 0 0 302.187789 194.021053c-35.84-34.223158-61.763368-58.933895-94.908631-79.440842A42.442105 42.442105 0 0 0 185.478737 107.789474a22.824421 22.824421 0 0 0-17.381053 7.194947c-10.913684 11.425684-6.063158 28.240842 1.428211 39.181474 21.989053 32.121263 47.912421 56.858947 83.752421 91.109052 20.614737 19.671579 49.259789 43.169684 77.392842 63.08379C281.007158 367.400421 215.578947 484.432842 215.578947 592.842105c0 74.482526 24.791579 124.065684 51.065264 176.586106C294.534737 825.209263 323.368421 882.903579 323.368421 970.105263h-53.894737c0-74.482526-24.791579-124.065684-51.065263-176.586105C190.517895 737.738105 161.684211 680.043789 161.684211 592.842105c0-90.866526 42.226526-197.685895 93.453473-274.485894a803.759158 803.759158 0 0 1-39.046737-34.115369C177.852632 247.754105 150.231579 221.399579 125.035789 184.616421c-24.441263-35.759158-22.797474-78.686316 4.069053-106.819368 26.300632-27.567158 70.898526-31.043368 106.522947-9.000421 37.941895 23.444211 65.562947 49.798737 103.774316 86.258526 9.970526 9.512421 33.037474 32.309895 56.93979 60.550737h68.634947c-27.621053-37.780211-60.416-72.730947-88.522105-99.543579-28.833684-27.540211-54.730105-52.116211-84.533895-74.024421L326.305684 0.296421c31.232 23.228632 57.802105 48.532211 87.309474 76.719158 53.840842 51.388632 94.450526 100.594526 121.74821 146.83621 82.836211 26.650947 150.042947 116.870737 165.025685 230.750316l1.724631 13.177263-9.404631 9.404632c-3.772632 3.772632-7.706947 7.653053-11.802948 11.587368C837.227789 561.178947 862.315789 663.498105 862.315789 720.896zM309.463579 754.526316c3.934316 8.057263 7.895579 16.087579 11.991579 24.144842C348.887579 832.970105 377.263158 889.128421 377.263158 970.105263h53.894737c0-93.696-34.061474-161.226105-61.520842-215.578947h-60.173474z m597.90821 53.894737c-3.422316 9.404632-7.814737 19.806316-13.770105 31.959579L829.790316 970.105263h60.065684l52.143158-105.957052c10.778947-21.935158 17.515789-40.016842 21.90821-55.727158h-56.535579zM514.694737 390.736842c0-34.223158-13.231158-44.463158-29.642105-44.463158s-29.642105 10.24-29.642106 44.463158c0 34.250105 13.231158 44.463158 29.642106 44.463158s29.642105-10.213053 29.642105-44.463158z" fill="#231F20" ></path></symbol><symbol id="icon-rat_zi" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#85C3DE" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-431.157895 188.631579v-215.578947h269.473685v-53.894737H538.947368v-39.585684c26.543158-18.081684 94.585263-65.050947 177.852632-127.488L700.631579 215.578947H323.368421v53.894737h295.316211a4221.008842 4221.008842 0 0 1-121.640421 85.369263l-11.991579 8.003369V431.157895H242.526316v53.894737h242.526316v215.578947c0 48.343579-13.850947 53.894737-134.736843 53.894737v53.894737c105.391158 0 188.631579 0 188.631579-107.789474z" fill="#231F20" ></path></symbol><symbol id="icon-rat" viewBox="0 0 1024 1024"><path d="M727.659789 431.157895c-132.581053 0-220.348632 47.454316-285.803789 154.354526-19.779368 32.309895-15.845053 76.503579-9.404632 96.579368 3.260632 10.159158 7.760842 18.647579 12.422737 25.546106C464.761263 737.010526 499.927579 754.526316 538.947368 754.526316h66.829474c1.158737 17.893053-1.967158 34.762105-15.144421 53.975579-12.692211 18.539789-37.807158 40.151579-56.32 54.810947 25.249684-0.673684 52.709053-0.997053 83.240421-0.997053C877.487158 862.315789 970.105263 711.922526 970.105263 571.176421 936.421053 512 882.364632 431.157895 727.659789 431.157895z" fill="#85C3DE" ></path><path d="M210.432 1012.897684l-43.573895-31.690105c106.954105-147.051789 185.317053-171.196632 423.828211-172.705684 21.396211-31.258947 16.249263-56.266105 9.377684-89.70779-3.557053-17.138526-7.221895-34.842947-7.221895-54.433684 0-68.958316 25.330526-104.636632 63.407158-136.973474l34.896842 41.040842c-29.453474 25.061053-44.409263 46.780632-44.409263 95.932632 0 14.093474 2.937263 28.402526 6.063158 43.546947 5.901474 28.510316 12.8 62.032842-1.131789 99.462737 166.373053-10.24 264.542316-96.902737 264.542315-236.193684C916.210526 418.330947 827.580632 323.368421 684.921263 323.368421c-83.644632 0-153.303579 29.696-174.187789 39.612632a224.875789 224.875789 0 0 1-20.533895 31.339789l-41.741474-34.115368 20.884211 17.057684-20.911158-16.976842C448.781474 359.828211 485.052632 314.287158 485.052632 262.736842c0-34.816-8.946526-60.766316-26.570106-77.069474-17.515789-16.249263-44.786526-24.602947-81.219368-24.953263V323.368421h-53.894737V109.783579l24.872421-1.913263c64.700632-4.931368 114.095158 7.895579 146.863158 38.238316C524.207158 173.056 538.947368 212.291368 538.947368 262.736842c0 11.102316-1.131789 21.908211-3.072 32.202105 37.268211-12.584421 89.842526-25.465263 149.045895-25.465263C858.165895 269.473684 970.105263 387.907368 970.105263 571.176421 970.105263 711.922526 877.487158 862.315789 617.552842 862.315789c-258.667789 0-311.942737 19.698526-407.120842 150.581895z m19.105684-256.835368c-12.045474 0-24.387368-0.565895-37.025684-1.64379l-22.096842-1.859368-2.425263-22.016C167.747368 728.144842 161.684211 672.444632 161.684211 631.026526c0-103.585684 21.450105-178.903579 53.894736-259.045052V107.789474h53.894737v274.782315l-2.021052 4.904422C235.439158 465.758316 215.578947 533.800421 215.578947 631.026526c0 22.878316 2.101895 51.442526 3.826527 70.979369 99.678316 2.802526 172.813474-35.408842 222.450526-116.493474l48.020211 24.090947c-11.237053 28.133053-11.371789 51.577263-0.377264 67.853474 9.701053 14.282105 28.645053 23.174737 49.448421 23.174737v53.894737c-39.019789 0-74.186105-17.515789-94.073263-46.888421a100.244211 100.244211 0 0 1-12.422737-25.546106c-53.221053 49.178947-121.128421 73.943579-202.913684 73.970527zM379.957895 525.473684c0-34.223158-13.231158-44.463158-29.642106-44.463158s-29.642105 10.24-29.642105 44.463158c0 34.250105 13.231158 44.463158 29.642105 44.463158s29.642105-10.213053 29.642106-44.463158z" fill="#231F20" ></path></symbol><symbol id="icon-rooster_you" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#BBC4C9" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-215.578947-188.631579h-161.684211v-26.947368h161.684211V242.526316H269.473684v53.894737h161.684211v26.947368h-161.684211v485.052632h53.894737v-53.894737h377.263158v53.894737h53.894737V323.368421zM323.368421 646.736842h377.263158v53.894737H323.368421v-53.894737z m0-269.473684h107.789474c0 103.316211-72.784842 107.654737-81.084632 107.789474L350.315789 538.947368c46.592 0 134.736842-33.792 134.736843-161.68421h53.894736v107.789474c0 29.722947 24.171789 53.894737 53.894737 53.894736h107.789474v53.894737H323.368421v-215.578947z m377.263158 0v107.789474h-107.789474v-107.789474h107.789474z m-215.578947-80.842105h53.894736v26.947368h-53.894736v-26.947368z" fill="#231F20" ></path></symbol><symbol id="icon-rooster" viewBox="0 0 1024 1024"><path d="M891.688421 506.421895C877.244632 455.033263 862.315789 401.893053 862.315789 323.368421V116.224l-323.368421 195.745684V323.368421c0 78.524632 14.928842 131.664842 29.372632 183.053474 12.611368 44.894316 24.522105 87.282526 24.522105 140.314947 0 101.618526-77.931789 176.693895-168.286316 203.991579l5.416422 11.587368h215.578947c24.333474 0 43.385263-0.242526 58.556631-2.128842C811.52 846.821053 916.210526 764.550737 916.210526 646.736842c0-53.032421-11.910737-95.420632-24.522105-140.314947z" fill="#FF8787" ></path><path d="M673.684211 354.357895c-16.384 0-29.642105-10.213053-29.642106-44.463158 0-34.223158 13.231158-44.463158 29.642106-44.463158s29.642105 10.24 29.642105 44.463158c0 34.250105-13.258105 44.463158-29.642105 44.463158zM540.106105 970.105263l-50.58021-107.789474h156.05221l50.607158 107.789474h59.553684l-51.60421-109.918316C811.52 846.821053 916.210526 764.550737 916.210526 646.736842c0-53.032421-11.910737-95.420632-24.522105-140.314947C877.244632 455.033263 862.315789 401.893053 862.315789 323.368421V107.789474c0-59.445895-48.343579-107.789474-107.789473-107.789474a107.924211 107.924211 0 0 0-107.789474 106.172632 100.890947 100.890947 0 0 0-24.117895-3.314527 88.710737 88.710737 0 0 0-88.602947 88.602948c0 20.668632 5.227789 39.720421 10.671158 53.921684l-99.489684 59.688421 93.749894 14.470737V377.263158c0 14.416842-5.901474 21.692632-33.360842 49.152l-11.129263 11.129263C398.228211 326.521263 324.985263 269.473684 215.740632 269.473684 96.768 269.473684 0 366.241684 0 485.214316V646.736842h53.894737v-161.522526A162.007579 162.007579 0 0 1 215.740632 323.368421c82.081684 0 140.422737 36.244211 240.64 152.252632l-38.615579 38.615579C367.804632 461.285053 323.098947 431.157895 259.584 431.157895A151.983158 151.983158 0 0 0 107.789474 582.952421V754.526316h53.894737v-171.573895A98.007579 98.007579 0 0 1 259.584 485.052632c46.322526 0 79.629474 20.911158 137.027368 86.016l18.970948 21.530947 128.080842-128.080842C572.200421 435.981474 592.842105 415.366737 592.842105 377.263158v-97.926737l23.309474-14.120421-13.662316-23.04c-0.161684-0.242526-14.578526-24.899368-14.578526-50.688 0-19.132632 15.575579-34.708211 34.70821-34.708211 5.093053 0 26.785684 3.179789 39.558737 18.647579l26.327579 46.026106 39.774316-24.090948-20.372211-49.367579C704.754526 140.449684 700.631579 117.517474 700.631579 107.789474c0-29.722947 24.171789-53.894737 53.894737-53.894737s53.894737 24.171789 53.894737 53.894737v215.578947c0 85.935158 16.680421 145.300211 31.366736 197.632C851.887158 564.008421 862.315789 601.141895 862.315789 646.736842c0 95.285895-99.408842 161.684211-188.631578 161.684211h-209.461895l-68.419369-145.704421C375.242105 618.954105 338.108632 592.842105 296.448 592.842105A80.976842 80.976842 0 0 0 215.578947 673.711158V862.315789h53.894737v-188.604631c0-14.874947 12.099368-26.974316 26.974316-26.974316 20.533895 0 38.965895 14.147368 50.553263 38.858105L480.579368 970.105263h59.526737z" fill="#231F20" ></path></symbol><symbol id="icon-snake_si" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#FF8787" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-242.041263 180.762947l-52.116211-13.797052C657.219368 749.864421 651.425684 754.526316 619.789474 754.526316h-242.526316V485.052632h269.473684v53.894736h53.894737V215.578947H323.368421v538.947369c0 29.722947 24.171789 53.894737 53.894737 53.894737h242.526316c77.689263 0 91.189895-51.065263 108.274526-115.658106zM377.263158 269.473684h269.473684v161.684211H377.263158v-161.684211z" fill="#231F20" ></path></symbol><symbol id="icon-tiger_yin" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#7DD47F" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-257.42821 299.250526l-107.789474-53.894737-24.117895 48.208843 107.789474 53.894736 24.117895-48.208842z m-269.473685-5.658947l-24.117894-48.208842-107.789474 53.894737 24.117895 48.208842 107.789473-53.894737zM700.631579 431.157895h-161.684211v-53.894737h107.789474v-53.894737H377.263158v53.894737h107.789474v53.894737h-161.684211v323.368421h53.894737v-53.894737h269.473684v53.894737h53.894737V431.157895z m-161.684211 161.68421h107.789474v53.894737h-107.789474v-53.894737z m-161.68421 0h107.789474v53.894737h-107.789474v-53.894737z m161.68421-107.789473h107.789474v53.894736h-107.789474v-53.894736z m-161.68421 0h107.789474v53.894736h-107.789474v-53.894736zM754.526316 215.578947h-223.097263l-20.803369-62.410105-51.119158 17.057684L474.624 215.578947H269.473684v107.789474h53.894737v-53.894737h377.263158v53.894737h53.894737V215.578947z" fill="#231F20" ></path></symbol><symbol id="icon-snake" viewBox="0 0 1024 1024"><path d="M107.789474 790.474105c0-72.434526 67.880421-91.513263 121.451789-91.513263 74.401684 0 153.815579 34.438737 237.891369 70.925474 50.580211 21.935158 104.609684 45.325474 162.250105 63.083789-52.412632 44.786526-118.784 74.347789-195.152842 83.078737-143.171368 16.357053-326.440421 7.006316-326.440421-125.574737zM377.263158 215.578947c-15.575579 0-30.288842 3.449263-43.654737 9.377685A250.691368 250.691368 0 0 0 323.368421 296.421053c0 115.550316 76.422737 169.391158 137.83579 212.614736 8.138105 5.712842 16.141474 11.371789 23.848421 17.057685V323.368421a107.789474 107.789474 0 0 0-107.789474-107.789474z" fill="#C3D686" ></path><path d="M671.528421 788.857263c44.328421 11.964632 89.626947 19.563789 136.892632 19.56379 89.168842 0 161.684211-60.442947 161.68421-134.736842s-72.515368-134.736842-161.68421-134.736843c-19.078737 0-37.025684 1.509053-54.218106 4.015158-0.754526-101.402947-38.211368-172.355368-79.413894-219.648L673.684211 323.368421a1749.962105 1749.962105 0 0 1-79.036632-1.751579c45.702737 35.866947 108.705684 107.870316 105.984 232.367158 0 0.431158-0.080842 0.808421-0.10779 1.239579-34.923789 10.994526-66.155789 26.731789-95.097263 45.190737a163.085474 163.085474 0 0 0-15.845052-42.388211c-21.557895-39.639579-60.065684-66.775579-97.360842-93.022316C433.098105 423.343158 377.263158 384 377.263158 296.421053c0-130.290526 108.274526-188.631579 215.578947-188.631579 64.134737 0 132.715789 12.045474 214.366316 37.807158C802.330947 180.250947 780.099368 209.381053 700.631579 214.635789V161.684211h-53.894737v53.679157c-63.272421-1.024-104.528842-5.200842-104.986947-5.254736l-5.578106 53.598315C538.408421 263.949474 592.357053 269.473684 673.684211 269.473684c125.170526 0 188.631579-48.128 188.631578-143.063579V106.981053l-18.432-6.144C747.789474 68.823579 668.025263 53.894737 592.842105 53.894737c-158.666105 0-269.473684 99.732211-269.473684 242.526316 0 115.550316 76.422737 169.391158 137.83579 212.614736 33.684211 23.713684 65.509053 46.106947 81.003789 74.698106 9.539368 17.542737 13.285053 33.414737 12.341895 47.750737 21.153684 9.108211 42.118737 17.839158 62.949052 25.977263C671.151158 620.193684 729.977263 592.842105 808.421053 592.842105c59.445895 0 107.789474 36.271158 107.789473 80.842106s-48.343579 80.842105-107.789473 80.842105c-105.472 0-203.237053-42.388211-297.768421-83.429053-94.800842-41.094737-184.346947-79.952842-281.411369-79.952842C122.718316 591.171368 53.894737 644.715789 53.894737 727.578947c0 79.063579 67.098947 136.434526 159.555368 136.434527 142.174316 0 230.426947-66.883368 306.79579-129.886316 31.420632 13.419789 62.787368 26.058105 94.450526 37.133474-47.077053 49.637053-110.969263 82.566737-186.610526 91.270736l5.066105 53.625264c93.453474-7.006316 143.144421 9.350737 195.718737 26.543157 46.457263 15.225263 94.127158 30.854737 169.822316 30.854737 19.994947 0 41.957053-1.077895 66.344421-3.557052l-5.416421-53.625263c-105.283368 10.778947-158.100211-6.548211-213.935158-24.872422-22.150737-7.275789-44.624842-14.632421-70.305684-20.345263a334.848 334.848 0 0 0 96.14821-82.297263z m-458.078316 21.261474C162.573474 810.118737 107.789474 784.276211 107.789474 727.578947c0-60.847158 62.733474-82.539789 121.451789-82.539789 77.850947 0 154.731789 30.288842 235.250526 64.943158-66.263579 52.924632-139.722105 100.136421-251.041684 100.136421z" fill="#231F20" ></path></symbol><symbol id="icon-tiger" viewBox="0 0 1024 1024"><path d="M431.157895 162.250105V134.736842c0-41.552842-39.289263-80.842105-80.842106-80.842105-28.833684 0-57.128421 4.661895-58.314105 4.850526L269.473684 62.490947v83.887158C144.788211 223.824842 89.222737 346.839579 66.991158 431.157895h266.051368c240.747789 0 415.851789 107.789474 415.85179 269.473684-14.848-25.114947-43.924211-53.894737-88.68379-53.894737-67.988211 0-121.263158 71.033263-121.263158 161.684211 0 66.802526 30.477474 119.888842 60.712421 156.16 12.638316 15.171368 36.055579 37.726316 59.014737 58.88 5.066105 0.107789 9.781895 0.538947 15.009685 0.538947 219.297684 0 350.315789-191.811368 350.315789-377.263158C1024 327.545263 679.855158 172.813474 431.157895 162.250105z" fill="#F7C768" ></path><path d="M673.684211 1024c-114.768842 0-188.820211-33.333895-254.167579-62.787368-53.625263-24.144842-99.974737-45.002105-161.28-45.002106-40.448 0-83.590737 23.255579-103.639579 45.16379l-39.747369-36.432842C142.497684 894.787368 199.168 862.315789 258.236632 862.315789c68.392421 0 119.861895 21.288421 172.921263 45.056V673.684211c0-35.166316-17.542737-64.107789-30.639158-80.815158-15.198316 9.835789-32.067368 18.890105-50.741895 26.947368l-21.342316-49.475368C469.800421 509.413053 485.052632 377.317053 485.052632 323.368421V221.642105A597.827368 597.827368 0 0 0 404.210526 215.578947h-26.947368V134.736842c0-12.099368-14.848-26.947368-26.947369-26.947368-9.377684 0-18.836211 0.592842-26.947368 1.347368V269.473684h-53.894737V211.671579c-136.030316 102.912-158.450526 266.886737-161.306947 295.882105 9.135158 9.108211 38.992842 25.061053 71.976421 38.669474l38.103579-59.365053 12.449684-1.589894C321.212632 473.653895 377.263158 392.192 377.263158 323.368421h53.894737c0 88.333474-68.796632 192.242526-180.870737 213.342316l-48.397474 75.398737-20.291368-7.437474C53.894737 557.756632 53.894737 523.317895 53.894737 512c0-50.041263 37.025684-254.733474 215.578947-365.621895V62.490947l22.528-3.745684C293.187368 58.556632 321.482105 53.894737 350.315789 53.894737c41.552842 0 80.842105 39.289263 80.842106 80.842105v27.513263c248.697263 10.563368 592.842105 165.295158 592.842105 484.486737 0 185.451789-131.018105 377.263158-350.315789 377.263158z m-13.473685-323.368421c-36.513684 0-67.368421 49.367579-67.368421 107.789474 0 85.746526 68.096 145.084632 89.465263 161.549473 91.540211-2.533053 164.378947-45.487158 213.827369-107.654737H700.631579v-53.894736h230.238316c8.919579-17.273263 16.357053-35.354947 22.285473-53.894737h-239.885473l-6.467369-17.650527C706.290526 735.582316 692.439579 700.631579 660.210526 700.631579zM485.052632 931.112421c33.926737 14.066526 70.521263 26.597053 114.607157 33.468632C569.424842 928.309895 538.947368 875.223579 538.947368 808.421053c0-90.650947 53.274947-161.684211 121.263158-161.684211 44.759579 0 73.835789 28.779789 88.68379 53.894737h217.007158c2.775579-17.866105 4.203789-35.920842 4.203789-53.894737 0-38.938947-5.658947-74.752-15.925895-107.627789l-126.706526 126.679579-38.103579-38.103579L932.001684 485.052632a367.939368 367.939368 0 0 0-57.775158-81.596632l-154.543158 154.543158-38.103579-38.103579 153.573053-153.573053a537.869474 537.869474 0 0 0-82.593684-56.751158l-140.665263 140.638316-38.103579-38.103579 128.134737-128.134737A794.731789 794.731789 0 0 0 538.947368 231.046737V323.368421c0 50.149053-11.102316 156.698947-95.932631 236.328421 18.378105 23.417263 42.037895 63.407158 42.037895 113.987369v257.42821zM215.578947 431.157895v-53.894737c39.774316 0 53.894737-29.022316 53.894737-53.894737h53.894737c0 53.571368-37.025684 107.789474-107.789474 107.789474z" fill="#231F20" ></path></symbol><symbol id="icon-boar" viewBox="0 0 1024 1024"><path d="M732.079158 377.263158c-107.789474 0-186.421895 31.393684-281.869474 126.841263L180.331789 773.982316C257.724632 807.909053 348.725895 808.421053 485.052632 808.421053h96.013473c55.834947-34.411789 133.551158-53.894737 227.354948-53.894737h121.344L970.105263 680.555789V572.631579c0-94.315789-130.236632-195.368421-238.026105-195.368421z" fill="#FFBDD8" ></path><path d="M808.421053 700.631579v53.894737c-196.446316 0-323.368421 84.641684-323.368421 215.578947h-53.894737c0-163.705263 148.075789-269.473684 377.263158-269.473684z m-323.368421 107.789474v-53.894737c-158.342737 0-245.598316 0-319.649685-49.367579L158.612211 700.631579H80.842105c-21.692632 0-26.624-14.821053-26.947368-26.947368v-82.620632c84.156632-11.183158 161.684211-74.913684 161.68421-186.853053V215.578947H161.684211v161.684211H134.736842c-66.964211 0-134.736842 37.025684-134.736842 107.789474h53.894737c0-42.630737 52.870737-53.894737 80.842105-53.894737h24.629895C147.132632 504.912842 85.153684 538.947368 26.947368 538.947368H0v134.736843c0 32.498526 21.530947 80.842105 80.842105 80.842105h61.682527c32.687158 20.506947 67.125895 33.145263 105.957052 41.013895A232.879158 232.879158 0 0 0 215.578947 916.210526h53.894737c0-41.930105 14.012632-80.303158 39.424-112.505263C358.885053 808.151579 415.959579 808.421053 485.052632 808.421053z m-72.946527-342.420211L323.368421 554.738526V431.157895h-53.894737v253.682526l180.736-180.736-38.103579-38.103579zM323.368421 161.684211h-53.894737v190.032842a769.536 769.536 0 0 1 53.894737-49.098106V161.684211z m323.368421-53.894737c-72.623158 0-146.809263 23.336421-215.578947 58.637473V107.789474h-53.894737v154.138947C458.832842 205.392842 555.331368 161.684211 646.736842 161.684211c148.587789 0 269.473684 120.885895 269.473684 269.473684v235.654737L809.579789 862.315789h61.359158L970.105263 680.555789V431.157895c0-178.310737-145.057684-323.368421-323.368421-323.368421z" fill="#231F20" ></path></symbol><symbol id="icon-boar_hai" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#85C3DE" ></path><path d="M309.975579 804.756211l-27.136-46.592c103.073684-60.011789 183.026526-132.473263 241.475368-219.24379H350.315789l-13.473684-50.283789c58.88-33.980632 99.435789-117.571368 118.703158-165.295158H242.526316v-53.894737h538.947368v53.894737h-268.18021c-12.395789 34.088421-42.469053 106.603789-90.435369 161.68421h134.009263a680.555789 680.555789 0 0 0 46.349474-107.708631l51.092211 17.057684c-58.421895 175.265684-171.034947 309.490526-344.333474 410.381474z m192.350316-2.937264L467.806316 760.454737c88.414316-73.728 154.516211-158.773895 202.105263-259.907369l48.801684 22.959158a797.372632 797.372632 0 0 1-82.351158 137.781895c32.741053 15.009684 83.456 44.867368 137.647158 101.591579l-38.938947 37.268211c-57.236211-59.877053-109.325474-85.557895-133.766737-95.178106a850.997895 850.997895 0 0 1-98.977684 96.848842z m48.613052-536.872421l-80.842105-53.894737 29.884632-44.840421 80.842105 53.894737-29.884632 44.840421zM512 53.894737C259.395368 53.894737 53.894737 259.395368 53.894737 512s205.500632 458.105263 458.105263 458.105263c9.081263 0 17.973895-0.835368 26.947368-1.374316v-53.894736c-8.946526 0.619789-17.866105 1.374316-26.947368 1.374315-222.881684 0-404.210526-181.328842-404.210526-404.210526S289.118316 107.789474 512 107.789474s404.210526 181.328842 404.210526 404.210526c0 195.206737-139.075368 358.507789-323.368421 396.045474v54.460631c214.096842-38.346105 377.263158-225.549474 377.263158-450.533052C970.105263 259.395368 764.604632 53.894737 512 53.894737z" fill="#231F20" ></path></symbol><symbol id="icon-bilibili1" viewBox="0 0 1129 1024"><path d="M234.909 9.656a80.468 80.468 0 0 1 68.398 0 167.374 167.374 0 0 1 41.843 30.578l160.937 140.82h115.07l160.936-140.82a168.983 168.983 0 0 1 41.843-30.578A80.468 80.468 0 0 1 930.96 76.445a80.468 80.468 0 0 1-17.703 53.914 449.818 449.818 0 0 1-35.406 32.187 232.553 232.553 0 0 1-22.531 18.508h100.585a170.593 170.593 0 0 1 118.289 53.109 171.397 171.397 0 0 1 53.914 118.288v462.693a325.897 325.897 0 0 1-4.024 70.007 178.64 178.64 0 0 1-80.468 112.656 173.007 173.007 0 0 1-92.539 25.75H212.377a341.186 341.186 0 0 1-72.421-4.024A177.835 177.835 0 0 1 28.91 939.065a172.202 172.202 0 0 1-27.36-92.539V388.662a360.498 360.498 0 0 1 0-66.789A177.03 177.03 0 0 1 162.487 178.64h105.414c-16.899-12.07-31.383-26.555-46.672-39.43a80.468 80.468 0 0 1-25.75-65.984 80.468 80.468 0 0 1 39.43-63.57M216.4 321.873a80.468 80.468 0 0 0-63.57 57.937 108.632 108.632 0 0 0 0 30.578v380.615a80.468 80.468 0 0 0 55.523 80.469 106.218 106.218 0 0 0 34.601 5.632h654.208a80.468 80.468 0 0 0 76.444-47.476 112.656 112.656 0 0 0 8.047-53.109v-354.06a135.187 135.187 0 0 0 0-38.625 80.468 80.468 0 0 0-52.304-54.719 129.554 129.554 0 0 0-49.89-7.242H254.22a268.764 268.764 0 0 0-37.82 0z m0 0" fill="#20B0E3" ></path><path d="M348.369 447.404a80.468 80.468 0 0 1 55.523 18.507 80.468 80.468 0 0 1 28.164 59.547v80.468a80.468 80.468 0 0 1-16.094 51.5 80.468 80.468 0 0 1-131.968-9.656 104.609 104.609 0 0 1-10.46-54.719v-80.468a80.468 80.468 0 0 1 70.007-67.593z m416.02 0a80.468 80.468 0 0 1 86.102 75.64v80.468a94.148 94.148 0 0 1-12.07 53.11 80.468 80.468 0 0 1-132.773 0 95.757 95.757 0 0 1-12.875-57.133V519.02a80.468 80.468 0 0 1 70.007-70.812z m0 0" fill="#20B0E3" ></path></symbol><symbol id="icon-yinle" viewBox="0 0 1024 1024"><path d="M512.2976 0a531.2 531.2 0 0 0-512 548.48V960h128V548.48a398.72 398.72 0 0 1 384-411.52 398.72 398.72 0 0 1 384 411.52V960h128V548.48A531.2 531.2 0 0 0 512.2976 0z" fill="#5c8add" ></path><path d="M64.2976 576l256 0 0 448-256 0 0-448Z" fill="#5c8add" ></path><path d="M704.2976 576l256 0 0 448-256 0 0-448Z" fill="#5c8add" ></path></symbol><symbol id="icon-icon-test-copy" viewBox="0 0 1024 1024"><path d="M512 512m-229.517241 0a229.517241 229.517241 0 1 0 459.034482 0 229.517241 229.517241 0 1 0-459.034482 0Z" fill="#5c8add" ></path><path d="M512 1024A512 512 0 1 1 1024 512 512 512 0 0 1 512 1024z m0-141.241379A370.758621 370.758621 0 1 0 141.241379 512 370.758621 370.758621 0 0 0 512 882.758621z" fill="#5c8add" ></path></symbol><symbol id="icon-V" viewBox="0 0 1024 1024"><path d="M1012.47774251 492.58192592L544.94137566 87.22962963a49.96686561 49.96686561 0 0 0-65.88275132 0L11.63784127 492.6975097c-21.03624691 18.26223633-23.3479224 49.93219048-5.08568606 70.96843739 18.03106878 21.03624691 49.93219048 23.3479224 70.96843738 5.08568607L512 191.83294532l434.71057495 376.91868784c9.47786949 8.20644797 21.26741446 12.25188008 32.82579189 12.13629629 14.10122046 0 27.97127337-5.77918871 38.02706173-17.33756613 18.14665256-20.92066314 15.95056084-52.70620106-5.08568606-70.9684374z" fill="#5c8add" ></path><path d="M109.30613051 567.59579541V896.89396825c0 42.53482892 34.90629982 77.44112875 77.44112875 77.44112875h220.76500882V666.30433862c0-25.54401411 20.92066314-46.46467725 46.46467724-46.46467724h116.16169313c25.54401411 0 46.46467725 20.92066314 46.46467725 46.46467724V974.335097h220.76500882c42.53482892 0 77.44112875-34.90629982 77.44112874-77.44112875l0.11558377-329.29817284L512 218.18604586 109.30613051 567.59579541zM848.00203175 197.49655027h-63.91782716c-12.82979894 0-23.23233862 10.40253968-23.23233863 23.23233862v24.27259259l110.49808818 95.70336508V220.72888889h-0.11558377c0-12.82979894-10.40253968-23.23233862-23.23233862-23.23233862zM905.44716754 83.18419754s-34.90629982 56.86721693-89.11508994 100.32671603c152.68616579 13.98563668 127.83565432-133.26809171 127.83565432-133.2680917-134.07717813-10.28695591-132.92134039 102.29164021-131.072 127.83565432 20.92066314-20.92066314 49.70102293-62.64640564 92.35143562-94.89427865zM798.53217637 174.61096297c-19.64924162-16.52847972-40.56990476-43.45949912-51.203612-53.97762258 0 0 32.94137566 20.57391182 56.40488184 49.3542716 2.42725926-18.37782011 6.47269135-93.3916896-93.16052205-85.3008254 0 0-13.98563668 104.71889947 87.95925221 89.92417638z" fill="#5c8add" ></path></symbol><symbol id="icon-zhifeiji" viewBox="0 0 1167 1024"><path d="M41.201759 463.52493L1110.665064 30.117647c10.32605-4.159104 21.942857 0.860504 26.101961 11.043137 1.434174 3.728852 1.864426 7.744538 1.003921 11.616807L949.033691 978.823529c-2.151261 10.89972-12.764146 17.927171-23.663865 15.632493-2.72493-0.573669-5.306443-1.721008-7.601121-3.298599L634.80624 789.79944l-163.065546 133.951821c-16.492997 13.62465-40.87395 11.186555-54.498599-5.306443-3.011765-3.728852-5.306443-7.887955-6.884034-12.477311l-102.973669-313.080112-265.178712-91.787115c-10.469468-3.585434-16.062745-15.058824-12.333893-25.528291 1.864426-5.44986 6.023529-9.895798 11.329972-12.047059z" fill="#FCFDFC" ></path><path d="M929.385512 1023.569748c-3.155182 0-6.453782-0.286835-9.752381-1.003922-6.740616-1.434174-12.907563-4.015686-18.50084-8.031372L635.953579 825.940616l-146.142297 120.040336c-13.911485 11.473389-31.408403 16.779832-49.335574 15.058824-17.927171-1.721008-34.133333-10.32605-45.463305-24.237535-5.306443-6.453782-9.322129-13.768067-11.903642-21.79944l-98.527731-299.598879-251.697479-87.19776c-12.333894-4.302521-22.229692-13.05098-27.966386-24.811204s-6.453782-24.954622-2.151261-37.288515c4.589356-13.337815 14.771989-23.9507 27.82297-29.257143L1099.908761 3.585434c24.954622-10.039216 53.351261 2.007843 63.533894 26.819048 3.585434 8.891877 4.445938 18.644258 2.581513 28.109804L977.143495 984.560224c-4.732773 23.090196-25.098039 39.009524-47.757983 39.009524z m-294.579272-233.770308l282.962465 201.357983c2.294678 1.577591 4.87619 2.72493 7.601121 3.298599 10.89972 2.151261 21.512605-4.87619 23.663865-15.632493L1137.914364 52.777591c0.860504-3.872269 0.430252-7.887955-1.003922-11.616807-4.159104-10.32605-15.919328-15.202241-26.101961-11.043137L41.201759 463.52493c-5.306443 2.151261-9.465546 6.597199-11.47339 12.047059-1.721008 5.019608-1.434174 10.469468 0.860505 15.345658 2.294678 4.87619 6.453782 8.461625 11.473389 10.182633l265.178711 91.787115L410.214644 905.967507c1.434174 4.589356 3.872269 8.748459 6.884033 12.477311 6.597199 8.031373 15.919328 12.907563 26.101961 13.911485 10.32605 1.003922 20.365266-2.007843 28.396639-8.605042l163.208963-133.951821z" fill="#4A4A4A" ></path><path d="M307.097557 592.743978l105.698599 316.091876c6.310364 18.787675 26.532213 28.970308 45.319888 22.659944 4.159104-1.434174 7.887955-3.442017 11.186555-6.166946l164.786555-133.951821-165.360224-118.892997c297.017367-287.982073 447.462185-433.980952 451.191036-437.853222 0.573669-0.573669 2.581513-3.442017 0.430252-7.027451-1.290756-1.577591-3.298599-3.298599-7.027451-2.15126-202.218487 120.327171-404.293557 242.805602-606.22521 367.291877z" fill="#CAE0EE" ></path><path d="M446.786072 934.794398c-5.736695 0-11.329972-1.290756-16.636414-3.872269-8.891877-4.445938-15.632493-12.047059-18.787675-21.512605L305.376549 592.313725l1.003921-0.573669C507.308201 467.684034 711.391114 344.058263 912.60568 224.161345l0.286835-0.143418c3.585434-1.147339 6.310364-0.286835 8.605042 2.581513l0.143417 0.143417c2.438095 4.015686 0.573669 7.457703-0.573669 8.74846-3.872269 4.015686-155.177591 150.87507-450.043698 436.705882l165.503642 119.036414-166.220728 135.09916c-3.442017 2.868347-7.457703 5.019608-11.760225 6.453782-3.728852 1.290756-7.744538 2.007843-11.760224 2.007843z m-137.967507-341.333334l105.268348 314.944538c2.868347 8.748459 9.035294 15.77591 17.210084 19.935014 8.17479 4.159104 17.496919 4.732773 26.245378 1.864426 3.872269-1.290756 7.60112-3.298599 10.756302-5.880112l163.352381-132.804482L466.434252 672.627451l1.290756-1.147339C763.308201 384.932213 915.043775 237.642577 918.772627 233.626891c0 0 2.007843-2.294678 0.286835-5.306443-1.003922-1.290756-2.438095-2.438095-5.306443-1.577591-200.784314 119.610084-404.293557 242.94902-604.934454 366.718207z" fill="#CAE0EE" ></path><path d="M460.840974 924.898599l7.457703-253.561904 165.933894 119.896918-168.658824 135.959664c-1.290756 1.003922-3.011765 0.860504-4.015686-0.430252-0.430252-0.430252-0.717087-1.147339-0.717087-1.864426z" fill="#94C3E2" ></path><path d="M463.709322 929.344538c-1.290756 0-2.438095-0.573669-3.2986-1.577591-0.573669-0.860504-1.003922-1.864426-1.003921-2.868348l7.60112-256.286834 169.519328 122.621848-1.434174 1.147339-168.658823 135.959664c-0.860504 0.717087-1.721008 1.003922-2.72493 1.003922z m6.023529-255.282913l-7.457703 250.836974c0 0.286835 0.143417 0.717087 0.286835 1.003922 0.430252 0.573669 1.434174 0.717087 2.007843 0.286835l167.22465-134.812325-162.061625-117.315406z" fill="#94C3E2" ></path></symbol><symbol id="icon-lianjie" viewBox="0 0 1079 1024"><path d="M695.355535 432.666896c-0.553495-1.10699-0.885592-2.186305-1.383737-3.265619-0.193723-0.193723-0.193723-0.359772-0.359771-0.719543-12.508983-26.318678-39.436506-43.366319-69.325226-41.013966-39.076734 3.265619-68.439634 39.021384-65.312388 79.841627 0.857917 10.516401 3.653066 20.147211 7.998 28.83708 19.78744 46.659613 11.097571 103.448181-25.377737 141.750022l-191.094085 199.950001a118.088119 118.088119 0 0 1-171.998513 0c-47.434506-49.537786-47.434506-130.098956 0-179.636742l71.234782-74.389703-0.52582-0.553494a75.911814 75.911814 0 0 0 24.326097-61.880721c-3.127246-40.820243-37.3609-71.51153-76.437634-68.24591a69.463599 69.463599 0 0 0-46.908685 23.966325l-0.166049-0.193723-72.618519 75.856464c-103.226783 107.793115-103.226783 282.36538 0 390.158495 103.171433 107.793115 270.299193 107.793115 373.498301 0l191.619904-200.1714c80.256748-83.992838 97.636485-208.307773 52.83108-310.289193z" fill="#5c8add" ></path><path d="M1002.047012 80.865592c-103.226783-107.82079-270.382217-107.82079-373.581325 0l-191.619905 200.199075c-80.284423 83.854464-97.66416 208.197074-52.997128 310.233843 0.52582 1.079315 0.857917 2.15863 1.383737 3.26562 0.166048 0.166048 0.166048 0.359772 0.332097 0.719543 12.536658 26.291004 39.46418 43.366319 69.3529 41.013966 39.076734-3.265619 68.439634-39.021384 65.312388-79.869302a78.679288 78.679288 0 0 0-7.998-28.864755c-19.78744-46.631938-11.097571-103.448181 25.377737-141.750022l191.287808-199.839302a118.088119 118.088119 0 0 1 172.026188 0c47.434506 49.537786 47.434506 130.126631 0 179.692091l-71.234782 74.417378 0.52582 0.553495a75.939489 75.939489 0 0 0-24.353772 61.88072c3.15492 40.847917 37.3609 71.51153 76.465309 68.245911a69.463599 69.463599 0 0 0 46.908685-23.938651l0.166049 0.166048 72.646194-75.856464c103.03306-107.82079 103.03306-282.642127 0-390.269194z" fill="#5c8add" ></path></symbol><symbol id="icon-liaotian" viewBox="0 0 1171 1024"><path d="M1068.71699 0.243751H102.193768C46.228437 0.243751 0.500666 45.045267 0.500666 99.74309v696.251622c0 54.697824 45.727771 99.450589 101.693102 99.450589h329.113198l120.851966 114.465677a48.652788 48.652788 0 0 0 66.641644 0l120.851966-114.465677h329.064448c55.965331 0 101.741852-44.752765 101.741852-99.450589V99.74309C1170.458842 45.045267 1124.682321 0.243751 1068.71699 0.243751z m-439.776354 596.849784h-370.989696c-27.933915 0-50.846551-22.425133-50.846551-49.774045 0-27.348912 22.912636-49.725294 50.846551-49.725294h370.989696c27.933915 0 50.846551 22.376382 50.846551 49.725294 0 27.348912-22.912636 49.774045-50.846551 49.774045z m287.18795-211.381252H254.782171a50.456549 50.456549 0 0 1-50.846551-49.725294c0-27.397662 22.912636-49.774045 50.846551-49.774045h661.346415c27.933915 0 50.846551 22.376382 50.846551 49.774045 0 27.348912-22.912636 49.725294-50.846551 49.725294z" fill="#5C8ADD" ></path></symbol><symbol id="icon-xinfeng" viewBox="0 0 1400 1024"><path d="M1301.63733163 214.78520234a207.81921797 207.81921797 0 0 1 7.02423018 52.42036465v489.73590176a205.10753818 205.10753818 0 0 1-205.05853125 205.05853125H283.05853124A205.15654424 205.15654424 0 0 1 77.99999999 756.79444971V267.20556699a201.36672685 201.36672685 0 0 1 7.02423106-52.42036465L586.24393329 562.1905874c69.44187217 51.96297217 146.36536612 49.13694404 214.1736961 0zM1103.60303056 62.0000167H283.05853124A204.50312753 204.50312753 0 0 0 106.37462518 163.41030547l489.71956641 335.75823018c62.43397646 50.77048623 127.85733457 50.31309463 194.62019765 0L1280.28693749 163.41030547A204.68281729 204.68281729 0 0 0 1103.60303056 62.0000167z m0 0" fill="#5c8add" ></path></symbol><symbol id="icon-QQ1" viewBox="0 0 1024 1024"><path d="M0 512a512 512 0 1 0 1024 0A512 512 0 1 0 0 512z" fill="#18ACFC" ></path><path d="M500.113 228.39c118.396-1.518 178.924 61.004 201 156 3.497 15.048 0.15 34.807 0 50 27.143 5.682 33.087 60.106 10 75v1h1c8.26 14.33 19.04 28.125 26 44 7.332 16.723 9.306 35.16 14 55 4.024 17.01-2.287 51.505-10 57-0.771 0.683-2.231 1.312-3 2-14.601-3.016-30.377-16.865-38-27-3.065-4.074-5.275-9.672-10-12-0.395 21.568-12.503 41.15-22 55-3.514 5.123-14.073 13.217-14 18 3.691 2.836 8.305 2.956 13 5 10.513 4.577 25.449 13.168 32 22 2.334 3.146 5.548 7.555 7 11 16.193 38.414-36.527 48.314-63 54-27.185 5.839-77.818-10.224-92-19-8.749-5.414-16.863-18.573-29-19-3.666 2.389-14.438 1.132-20 1-16.829 32.804-101.913 47.868-148 31-14.061-5.146-43.398-17.695-38-40 4.437-18.327 19.947-29.224 35-37 5.759-2.975 18.915-4.419 22-10-13.141-8.988-24.521-28.659-31-44-3.412-8.077-4.193-25.775-9-32-7.789 12.245-32.097 36.91-52 33-3.071-4.553-7.213-9.097-9-15-4.792-15.835-1.81-40.379 2-54 8.117-29.02 16.965-50.623 32-72 4.672-6.643 11.425-12.135 16-19-8.945-9.733-6.951-37.536-1-49 4.002-7.709 9.701-7.413 10-20-1.92-3.022-0.071-8.604-1-13-4.383-20.75 3.273-47.552 9-63 19.8-53.421 53.712-90.466 105-112 11.986-5.033 25.833-7.783 39-11 5.322-1.3 11.969 0.518 16-2z" fill="#FFFFFF" ></path></symbol><symbol id="icon-rss" viewBox="0 0 1024 1024"><path d="M749.61196492 908.06119793C749.61196492 560.41848146 463.58151854 274.36328126 115.93880207 274.36328126V115.93880207c434.50388795 0 792.12239584 357.61850789 792.12239586 792.12239586zM224.55858562 690.72261555a108.91682943 108.91682943 0 0 1 108.69404499 108.74355267C333.25263061 859.29616292 284.24005737 908.06119793 224.31104736 908.06119793 164.48105265 908.06119793 115.96355592 859.41993206 115.96355592 799.46616822s48.69077351-108.71879883 108.61978351-108.74355267zM641.01693522 908.06119793h-153.96879069c0-203.60020956-167.50913289-371.13409627-371.10934246-371.13409629v-153.96879068c288.03550619 0 525.07813313 237.11688843 525.07813315 525.10288697z" fill="#FFA500" ></path></symbol><symbol id="icon-youxiang" viewBox="0 0 1024 1024"><path d="M583.60666667 972h-68.08c-8.43333333 0-15.33333333-6.9-15.33333334-15.33333333V609.52c0-8.43333333 6.9-15.33333333 15.33333334-15.33333333h68.08c8.43333333 0 15.33333333 6.9 15.33333333 15.33333333V956.66666667c0 8.43333333-6.9 15.33333333-15.33333333 15.33333333z" fill="#629FF9" ></path><path d="M294.42 167c-113.62 0-205.77333333 92-205.77333333 205.31333333v336.72h411.39333333V372.31333333c0.15333333-113.31333333-92-205.31333333-205.62-205.31333333z" fill="#2166CC" ></path><path d="M519.97333333 627H216.98666667c-25.45333333 0-46-20.54666667-46-46V393.78c0-25.45333333 20.54666667-46 46-46h302.98666666c25.45333333 0 46 20.54666667 46 46V581c0 25.45333333-20.54666667 46-46 46z" fill="#D2E4FF" ></path><path d="M565.97333333 397a49.22 49.22 0 0 0-49.37333333-49.22H220.36c-27.29333333 0-49.37333333 22.08-49.37333333 49.22v10.27333333l179.4 94.60666667c11.34666667 5.98 24.84 5.98 36.18666666 0l179.4-94.60666667v-10.27333333z" fill="#FFFFFF" ></path><path d="M730.5 167h-427.8v0.46c109.78666667 4.29333333 197.49333333 94.3 197.49333333 205.00666667v336.72h411.39333334c27.29333333 0 49.37333333-22.08 49.37333333-49.22V397c0-126.96-103.19333333-230-230.46-230z" fill="#4E8DF6" ></path><path d="M845.80666667 52H681.12666667c-9.04666667 0-16.40666667 7.36-16.40666667 16.40666667v336.72a24.67133333 24.67133333 0 1 0 49.37333333 0V134.18666667h131.71333334c9.04666667 0 16.40666667-7.36 16.40666666-16.40666667V68.40666667c0-9.04666667-7.36-16.40666667-16.40666666-16.40666667z" fill="#2166CC" ></path><path d="M896.25333333 659.81333333h-35.11333333c-8.43333333 0-15.33333333-6.9-15.33333333-15.33333333v-35.11333333c0-8.43333333 6.9-15.33333333 15.33333333-15.33333334h35.11333333c8.43333333 0 15.33333333 6.9 15.33333334 15.33333334v35.11333333c0 8.58666667-6.9 15.33333333-15.33333334 15.33333333z" fill="#FFFFFF" ></path><path d="M88.8 709.18666667l-24.22666667 131.40666666c-9.66 54.43333333 26.83333333 98.59333333 81.26666667 98.59333334h213.9c54.58666667 0 106.56666667-44.16 116.22666667-98.59333334l23.15333333-131.40666666H88.8z" fill="#2974CE" ></path></symbol><symbol id="icon-gitHub" viewBox="0 0 1049 1024"><path d="M523.6581816 52C262.83923907 52 52 262.8401375 52 523.6581816c0 208.49703047 135.09433812 384.97758117 322.50789391 447.44906532 23.42658172 4.68531653 32.01647887-10.15136894 32.01647796-22.64584583 0-10.93210574-0.78163433-48.41463703-0.78163433-87.45953855-131.18885996 28.11189824-158.5200223-56.22379738-158.52002231-56.22379739-21.08437312-54.66232469-52.3201152-68.71827336-52.3201152-68.71827335-42.94858371-28.89353348 3.12384382-28.89353348 3.12384384-28.89353348 47.63479867 3.12384382 72.62285398 48.41643391 72.62285398 48.4164339 42.16784782 71.84121875 110.10538527 51.53758242 137.43654672 39.04400399 3.90457972-30.45500618 16.3990566-51.5393793 29.67427028-63.25222094-104.64023039-10.93300418-214.74561566-51.53848086-214.74561657-232.70524742 0-51.53848086 18.74126609-93.70632867 48.4164339-126.50444187-4.68621496-11.71284164-21.08527156-60.12837711 4.6844181-124.94207075 0 0 39.82563922-12.49447688 129.62738726 48.41463704 37.48253129-10.15136894 78.08980484-15.61742227 117.91454562-15.61742137s80.43201433 5.46605242 117.91454473 15.61742137c89.80264648-60.90911391 129.62828571-48.41463703 129.62828571-48.41463704 25.76879122 64.81369363 9.37063305 113.22922911 4.68531651 124.94207075 30.45410773 32.79721477 48.41463703 74.96506258 48.41463703 126.50444187 0 181.16676656-110.10538527 220.99150644-215.52545401 232.70524742 17.1797934 14.83668547 32.01647887 42.94858371 32.01647886 87.45953946 0 63.25222094-0.78163433 114.009965-0.78163523 129.62738636 0 12.49447688 8.59079468 27.33116234 32.01737731 22.64584583 187.41265734-62.4705866 322.50699547-238.95203574 322.50699546-447.44996375C995.31636231 262.8401375 783.69369203 52 523.6581816 52z" fill="#663399" ></path><path d="M230.82365863 729.03136735c-0.7807359 2.34310703-4.68531653 3.12384382-7.80916035 1.56237113s-5.46605242-4.68531653-3.90368129-7.02842356c0.7807359-2.34220859 4.68531653-3.12384382 7.80826192-1.56147269s4.68531653 4.68531653 3.90457972 7.02752512z m18.7412661 21.08437312c-2.34220859 2.34220859-7.02752512 0.78163433-9.37063305-2.34310703-3.12294539-3.12294539-3.90457972-7.80826192-1.5614727-10.15136894 2.34220859-2.34220859 6.24678922-0.7807359 9.37063305 2.34310702 3.12384382 3.90457972 3.90457972 8.58899782 1.5614727 10.15136895zM268.30618992 777.44690281c-3.12294539 2.34220859-7.80826192 0-10.15136895-3.90457972-3.12384382-3.90457972-3.12384382-9.37063305 0-10.93210574 3.12384382-2.34310703 7.80916035 0 10.15226739 3.90457972 3.12294539 3.90368129 3.12294539 8.58899782 0 10.93210574z m25.76968965 26.55042555c-2.34220859 3.12294539-7.80916035 2.34220859-12.49447688-1.56237113-3.90457972-3.90368129-5.46605242-9.37063305-2.34220859-11.71284164 2.34220859-3.12384382 7.80826192-2.34310703 12.49447687 1.56147269 3.90368129 3.12384382 4.68531653 8.58989625 2.3422086 11.71374008z m35.1403227 14.83668637c-0.78163433 3.90457972-6.24768766 5.46605242-11.71374008 3.90457972-5.46605242-1.5614727-8.58899782-6.24768766-7.80916036-9.37063305 0.78163433-3.90457972 6.24768766-5.46605242 11.71374009-3.90457972 5.46605242 1.5614727 8.58899782 5.46605242 7.80916035 9.37063305z m38.26416562 3.12384382c0 3.90457972-4.68621496 7.02752512-10.15226738 7.02752512-5.46605242 0-10.15226738-3.12294539-10.15226739-7.02752512s4.68621496-7.02842356 10.15226739-7.02842445c5.46605242 0 10.15226738 3.12384382 10.15226738 7.02842445z m35.92016106-6.24768766c0.78163433 3.90457972-3.12384382 7.80916035-8.58899872 8.58989625-5.46695086 0.78163433-10.15226738-1.5614727-10.93390172-5.46605241-0.77983747-3.90457972 3.12384382-7.80916035 8.5907947-8.58899872 5.46605242-0.78163433 10.15136894 1.56057426 10.93210574 5.46515488z m0 0" fill="#663399" ></path></symbol><symbol id="icon-bilibili" viewBox="0 0 1024 1024"><path d="M832.61667555 181.33447111h-164.32545185l74.45617778-74.45617778c12.84020148-12.84020148 12.84020148-30.8140563 0-43.65425778-12.84020148-12.84020148-30.8140563-12.84020148-43.65425778 0L573.2882963 189.04101925H450.04420741L324.2272237 63.23617185c-10.26730667-12.84020148-25.68040297-15.40096-41.08136295-7.70654815-2.57289482 0-2.57289482 2.57289482-5.13365334 5.13365333-12.84020148 12.84020148-12.84020148 30.8140563 0 43.65425779l77.02907259 77.02907259h-164.32545185c-89.86927408 0-164.32545185 74.45617778-164.32545185 164.32545184v408.24073483c0 87.29637925 74.45617778 161.75255703 164.32545185 161.75255703h25.68040296c0 30.8140563 25.68040297 53.92156445 53.92156444 53.92156444s53.92156445-25.68040297 53.92156445-53.92156444H704.23893333c2.57289482 30.8140563 28.24116148 53.92156445 59.05521778 51.34866964 28.24116148-2.57289482 48.78791111-23.10750815 51.34866964-51.34866964h20.53461333c89.86927408 0 164.32545185-74.45617778 164.32545184-164.32545186V343.09916445c-2.56075852-89.86927408-77.02907259-161.76469333-166.88621037-161.76469334z m-5.13365333 634.19429926H200.99527111c-33.37481482 0-59.05521778-28.24116148-61.61597629-61.61597629l-2.57289482-415.94728297c0-33.37481482 28.24116148-61.6159763 61.6159763-61.61597629h626.48775111c33.37481482 0 59.05521778 28.24116148 61.61597629 61.61597629l2.57289482 415.94728297c-2.57289482 35.93557333-28.24116148 61.6159763-61.6159763 61.61597629z" fill="#ff7299" ></path><path d="M403.82919111 417.55534222l15.40096 77.0290726-205.40681481 38.50846815-15.40096-77.0290726 205.40681481-38.50846815z m197.70026667 77.0290726l15.40096-77.0290726 205.40681481 38.50846815-15.40096 77.0290726-205.40681481-38.50846815z m41.08136297 161.75255703c0 2.57289482 0 7.70654815-2.57289483 10.26730667-12.84020148 28.24116148-41.08136297 46.2150163-74.45617777 48.78791111-20.53461333 0-41.08136297-10.26730667-53.92156445-25.68040296-15.40096 15.40096-33.37481482 25.68040297-53.92156445 25.68040296-30.8140563-2.57289482-59.05521778-20.53461333-74.45617777-48.78791111 0-2.57289482-2.57289482-5.13365333-2.57289481-10.26730667 0-10.26730667 7.70654815-17.97385482 17.97385481-20.53461333h2.57289482c7.70654815 0 12.84020148 2.57289482 15.40096 10.26730666 0 0 20.53461333 28.24116148 38.50846815 28.24116149 35.94770963 0 35.94770963-30.8140563 56.48232296-53.92156445 23.10750815 25.68040297 23.10750815 53.92156445 56.48232296 53.92156445 23.10750815 0 38.50846815-28.24116148 38.50846815-28.24116149 2.57289482-5.13365333 10.26730667-10.26730667 15.40096-10.26730666 10.26730667-2.57289482 17.97385482 5.13365333 20.53461333 15.40096v5.13365333h0.0364089z" fill="#ff7299" ></path></symbol></svg>',      o = (o = document.getElementsByTagName("script"))[o.length - 1].getAttribute("data-injectcss"),      p = function (c, l) {        l.parentNode.insertBefore(c, l);      };    if (o && !c.__iconfont__svg__cssinject__) {      c.__iconfont__svg__cssinject__ = !0;      try {        document.write(          "<style>.svgfont {display: inline-block;width: 1em;height: 1em;fill: currentColor;vertical-align: -0.1em;font-size:16px;}</style>"        );      } catch (c) {        console && console.log(c);      }    }    function d() {      i || ((i = !0), a());    }    function m() {      try {        t.documentElement.doScroll("left");      } catch (c) {        return void setTimeout(m, 50);      }      d();    }    (l = function () {      var c,        l = document.createElement("div");      (l.innerHTML = v),        (v = null),        (l = l.getElementsByTagName("svg")[0]) &&          (l.setAttribute("aria-hidden", "true"),          (l.style.position = "absolute"),          (l.style.width = 0),          (l.style.height = 0),          (l.style.overflow = "hidden"),          (l = l),          (c = document.body).firstChild ? p(l, c.firstChild) : c.appendChild(l));    }),      document.addEventListener        ? ~["complete", "loaded", "interactive"].indexOf(document.readyState)          ? setTimeout(l, 0)          : ((h = function () {              document.removeEventListener("DOMContentLoaded", h, !1), l();            }),            document.addEventListener("DOMContentLoaded", h, !1))        : document.attachEvent &&          ((a = l),          (t = c.document),          (i = !1),          m(),          (t.onreadystatechange = function () {            "complete" == t.readyState && ((t.onreadystatechange = null), d());          }));  })(window);]]></content>
      
    </entry>
    
    
  
</search>
