<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Keshiki&#39;s Blog</title>
  
  <subtitle>我们的头脑比天空更辽阔.</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-02-17T03:30:48.945Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Keshiki</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【游戏不锐评】VA-11 Hall-A Cyberpunk Bartender Action —— 调制饮料，改变人生</title>
    <link href="http://example.com/undefined/e2faed25.html"/>
    <id>http://example.com/undefined/e2faed25.html</id>
    <published>2025-01-29T15:10:19.000Z</published>
    <updated>2025-02-17T03:30:48.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【游戏不锐评】VA-11-Hall-A-Cyberpunk-Bartender-Action-——-调制饮料，改变人生"><a href="#【游戏不锐评】VA-11-Hall-A-Cyberpunk-Bartender-Action-——-调制饮料，改变人生" class="headerlink" title="【游戏不锐评】VA-11 Hall-A Cyberpunk Bartender Action —— 调制饮料，改变人生"></a>【游戏不锐评】VA-11 Hall-A Cyberpunk Bartender Action —— 调制饮料，改变人生</h1><p>10/10</p><p>这个游戏唯一的缺点就是太短了。如果可以，我想玩一辈子。</p><h2 id="欢迎来到VA-11-HALL-A"><a href="#欢迎来到VA-11-HALL-A" class="headerlink" title="欢迎来到VA-11 HALL-A"></a>欢迎来到VA-11 HALL-A</h2><p>本作的背景是某个平行世界的207X年。故事发生在罪恶之城Glitch City的贫民窟附近的一家濒临倒闭的酒吧：VA-11 HALL-A中。在这里，我们的主角调酒师Jill一边为各种账单发愁，一边在酒吧倒闭前尽职地进行工作。</p><p><img src="/undefined/e2faed25/20250130005640_1.jpg" alt="20250130005640_1" style="zoom:50%;"></p><p>说起调酒师，我其实并没有去过酒吧，但是从各种文学和影视作品中，调酒师经常给我一种神秘、沉默、总是在侧耳倾听（甚至不知道什么时候会掏出一把枪）的印象。然而在VA11这部作品中，Jill只是一个普通人，有自己的生活、社交和自己的情感。她也有数不清的烦（帐）恼（单），不好的回忆。然而，她也确实擅长倾听客人的心声，和客人分享烦恼或者喜悦，并且成功地和其中的一些客人建立了深切的友情。</p><p>通过制作者的精心设计，在7.5小时的游戏流程过后，Jill已经成为了我最喜欢的女主角之一。夸张点说，也许这款游戏真的拥有改变人生的魔力。</p><p><img src="/undefined/e2faed25/d9ea66e6be2755175a72fb7ffb903bb05c9d14d9280d5c3b5.jpg" alt="d9ea66e6be2755175a72fb7ffb903bb05c9d14d9280d5c3b5" style="zoom:50%;"></p><h2 id="调酒是工作，唠嗑是生活"><a href="#调酒是工作，唠嗑是生活" class="headerlink" title="调酒是工作，唠嗑是生活"></a>调酒是工作，唠嗑是生活</h2><p>回到游戏本身，VA11是一部扮演调酒师，一边给顾客调酒，一边和顾客聊天的游戏。虽然大部分人对VA11的印象是一部剧情游戏，但是在我看来，这种说法只有一部分正确。VA11的主要内容确实是各种人物之间的对话，以及他们发生的故事，但是它的玩法也占了相当大的比重。这里我指的不是玩法本身带来的乐趣，因为只是按照菜单调酒确实没什么意思。然而，制作者将这种玩法完美地融入了剧情之中，使得其成为这款游戏中不可缺少的一部分。如果单纯将VA11制作成一部视觉小说，那它绝对无法达到现在的高度。</p><p>例如，当Miki（一位人造人偶像）向你点了一杯苦味饮料时，你点开苦味饮料的列表，上面有几种饮料供你选择。事实上，无论你选择哪个都不会影响结果，但是当你已经融入游戏时，你会不由自主地考虑她会更喜欢哪一种饮料，在这种情况下，你当然会避开那些火辣、男性化的酒，努力为客人提供最好的服务。这种体验会使玩家更能沉浸在游戏世界中。并且，这种行为也会为你带来回报。有时顾客会陷入消极之中，而如果你能记住他们喜欢的饮料并在正确的时间提供给他们，你就获得和他们加深关系的机会。</p><p>再比如，在游戏中的某一天下班时，我们会邀请老板到家中闲聊，在这个过程中，我们拥有一个按钮，可以让Jill开啤酒、喝啤酒。虽然这个按钮听上去有点傻，并且相当简陋，但是当我按照对话的节奏控制Jill喝啤酒时，我仿佛感觉我自己进入了游戏中，一边喝着啤酒，一边说着漫无边际的话语。这种感觉很难用语言去形容，但是我确实体会到了已经很久都没有在游戏中感受到过的沉浸感。</p><p>另一个令人感到惊艳的设计是点唱机。在每次开工前，我们需要在点唱机中填满十二首音乐（都是没有歌词的纯音乐。从游戏性考虑，这些音乐就是游戏过程中的bgm，当然不能有歌词，而这刚好也契合了剧情，因为Jill提到过她喜欢听没有歌词的音乐，歌词会让她在工作中分心，并且有可能会带来负面情绪），这不仅能让玩家可以自由地选择游玩过程中的自己喜欢的bgm，同时也是另一个提升沉浸感的手段。我通常喜欢在第一首音乐处选择《welcome to valhalla》，象征着工作的开始。而根据顾客谈论的内容，我会手动切换到符合场景的bgm来让顾客感到更加舒适（虽然根本就没有这种设定）。</p><p><img src="/undefined/e2faed25/20250129235725_2.jpg" alt="20250129235725_2" style="zoom:50%;"></p><h2 id="塑造角色的秘诀"><a href="#塑造角色的秘诀" class="headerlink" title="塑造角色的秘诀"></a>塑造角色的秘诀</h2><p>人们总是用“剧情神作”来描述那些优秀的剧情向游戏，这是一个笼统的称呼，因为剧情可以分为剧本、人物塑造、世界观塑造等，而“剧情神作”并不一定在所有方面都能做到完美。我认为，VA11的精髓在于其优秀的人物塑造，更进一步地说，是人物的真实感和生活感。上面介绍了各种游戏中能够提升沉浸感的手段，而这一切的基础都是建立在真实的人物塑造之上的，毕竟，谁会费心去记住一个没有任何真实感的角色喜欢什么酒呢？</p><p>这部作品的文字量并不是很多，并且几乎都是对话。正是通过这些用心程度相当之高的台词设计，制作者塑造出了一个个仿佛正活在某个世界上的角色。角色们的台词都相当自然，阅读时就像是在和真正的人在聊天一样，就算这些对话在现实生活中出现，也几乎没有违和感（如果忽略他们谈论的内容的话）。无论是特别的口癖，特殊的称呼，还是偶然间提起前几天谈话的内容，对于这些台词，我只想说：太有生活感了VA11。</p><p>游戏内容当然也不全是轻松愉快的闲聊，因为人的生活并不总是一成不变的，尤其是在Glitch City这座城市中。而当顾客遭遇了变故或者遇到某些烦恼时，Jill有时也会化身“人生导师”，想办法为顾客开导，偶尔还会说出一些相当有哲理的话。</p><p><img src="/undefined/e2faed25/20250121233656_2.jpg" alt="20250121233656_2" style="zoom:50%;"></p><p><img src="/undefined/e2faed25/20250121233700_1.jpg" alt="20250121233700_1" style="zoom:50%;"></p><p><img src="/undefined/e2faed25/20250121233726_1.jpg" alt="20250121233726_1" style="zoom:50%;"></p><p>正如某位顾客所说，Jill总是维持着“精明的调酒师”的形象，她似乎对一切都能淡然处之，并且无欲无求。然而任何对Jill有一些了解的人都不会赞同这种看法。作为本作的主角，制作者花费了大部分精力用来塑造Jill这个人物。在每天上班之前，游戏中有一个在房间中的环节，在这里，Jill会浏览新闻和论坛，并扮演自己养的猫Fore来分饰两角和自己自问自答，对新闻和论坛中的内容进行吐槽。这个环节对Jill起到了相当大的作用，我们可以通过她对各种内容的看法得知她的性格、爱好等。当我知道Jill甚至会为了买无线XX棒花光存款时，我的大脑停止思考了好几秒。而Jill曾为美少女战士动画着迷（其实现在也是）的属性也为其的性格增加了一些反差感，让人感觉更加真实（因为我在现实中还真见过不少这种人）。</p><p>短短7.5个小时的游戏时间里，这个游戏中的每一个角色都给我留下了鲜活的印象。比起某些galgame用动辄上两位数的时长塑造出的流水线女角色，VA11带给我的简直就是群像盛宴。随着AI技术的发展，许多人认为将AI接入游戏来生成随机的人物对话将成为使角色变得鲜活的最佳手段，但我目前还是认为，精心设计、拥有强大上下文关联的台词是AI无法逾越的高山。</p><p>再放张Jill美图</p><p><img src="/undefined/e2faed25/19fdf15a04b5941f92c5f9c12a9882e6c2ec7b8a153224cae.jpg" alt="19fdf15a04b5941f92c5f9c12a9882e6c2ec7b8a153224cae" style="zoom: 25%;"></p><h2 id="绝望的城，温情的人"><a href="#绝望的城，温情的人" class="headerlink" title="绝望的城，温情的人"></a>绝望的城，温情的人</h2><blockquote><p>这是不应存在的城市。由企业和黑帮主宰一切的避税天堂。在这里，所有人都被植入纳米机械，用于维持监控。白骑士监督每位市民，确保腐败政府的法律得到服从。</p><p>形形色色的暴行不过是这座城市日常生活的剪影。弱势群体的生活品质正在急剧下滑。对很多人而言，这是难以承受的重负。有些人选择投入自己的工作，家庭，或是研究之中。另一些人正在寻求逃离的方式。还有一些人……选择了放弃。</p><p>但也有人认为自己的答案就沉在酒杯的底部。</p></blockquote><p>作为赛博朋克题材的作品，本作的故事全都发生在一个典型的赛博朋克都市Glitch City中。腐败的政府，垄断的企业，义体改造，基因编辑，仿生人……这座城市下充满了赛博朋克世界观下的常见的元素。虽然我们无法直接在游戏中游览这座城市，但制作者仅通过各种对话就向我们展现了一座充满了罪恶与混乱的城市。</p><p>大部分赛博朋克题材的作品都着重于表达对赛博朋克世界观下极权的反抗，例如《赛博朋克2077》中的“让我们把这座城市烧成灰！” ，以及《幽灵行者》中一言不合直接将所有敌人砍成两截。与之相比，VA11似乎透漏出一股消极的意味，没有人挺身而出对抗政府，没有秘密集会传播思想，只有一群在这座城市过着自己生活的普通人。</p><p>然而，当完成一周目的游玩后，我感受到的却不是身处赛博朋克世界下无能为力，身不由己的绝望，而是乐观和豁然开朗。VA11中刻画的角色们并不是没有反抗，只是反抗的方式不同罢了。他们反抗的方式便是：即使生活在这样一个狗屎一样的世界上，也要认真生活，以及善待他人。Jill没有隐藏于手指间的单分子线，也没有瞪一眼就能让人脑袋开花的能力。她拥有的只有非凡的调酒技术，以及一颗真诚待人的心，而这足以为她和身边的人带来在Glitch City中继续生活下去的勇气。</p><p>VA11-HALL-A的顾客们在Glitch City这座城市中显得有些过于闪亮。他们会遇到各种问题，比如家庭问题，存在主义危机，甚至是受到生命威胁，他们也会抱怨，也会有痛苦和迷茫。但在这之后，他们会直面困难，并在Jill的帮助下度过难关。而当游戏接近尾声，Jill遭遇了生活中的巨大变故时，他们也反过来支撑着Jill，帮助她逐渐从阴影中走出，并最终解开心结。虽然最终世纪大和解的结局像是在包饺子，但是伴随着新年的钟声、对Lenore的悼念以及对未来生活的展望，这绝对是一盘充满各种滋味，让人回味无穷的饺子。</p><p>VA11在两个端点之间找到了一个绝妙的平衡点。先塑造出栩栩如生、令人喜爱的角色，再通过他们身上遭遇的不幸揭露这个城市乃至于这个世界的腐败，最后通过人物与他人的和解，最主要的是与自身的和解，来展现人物弧光并给予玩家希望。在大团圆结局的背后，VA11同样有着赛博朋克题材作品中必不可少批判和警示，以及丰富的设定。游戏中Lilim、缸中之脑、通过装置获得说话能力的狗等都是很有意思的设定，制作者对于一些经典问题，如意识上传、人工智能的自我意识等也展现了自己认真的思考。这些都是VA11中世界观塑造的加分项。</p><h2 id="故事结束了，但是他们的人生还在继续"><a href="#故事结束了，但是他们的人生还在继续" class="headerlink" title="故事结束了，但是他们的人生还在继续"></a>故事结束了，但是他们的人生还在继续</h2><blockquote><p>在距离城市主干道只有几步之遥的小路上，贫民区附件的某个地方，你可以找到这家BTC认证编号VA-11的酒吧的Hall A……</p><p>……但是全称过于拗口，因此我们称之为Valhalla。</p><p>这是钢筋混凝土荒漠中的小小绿洲。为疲惫不堪的灵魂带来慰藉的精神之泉。</p><p>我们的故事就将在这里展开。</p></blockquote><p>虽然最开始的评语有点开玩笑的意思，但是VA11的故事确实有点短，结尾也有些仓促。Jill才刚解开缠绕了自己几年的心结，将要迈向人生的新阶段，故事却在这一天戛然而止。当屏幕上开始播放后日谈的时候，我还是不敢相信：这就结束了？但当我看到那些被Jill帮助且帮助了Jill的角色们在这之后的幸福生活后，我还是释怀了。在Jill的顾客中，有的成为了她生活的一部分，也有的只是擦肩而过的。然而还有一种顾客，虽然他们不会常伴左右，但他们带来的影响是不可磨灭的，并在未来持续产生影响。而VA11对于我来说也是如此。游戏中的角色们都开启了新的生活，也许我并不能亲眼见证所有故事的结局，但我会永远记住这一小段时间的陪伴。</p><p>祝你们的未来一帆风顺，Jill，Dana，Gill，Gaby，Dorothy，Alma，Sei，Stella，Virgilio……</p><p>下个游戏见！</p><p><img src="/undefined/e2faed25/1b12cd068e07006a45255e9d83b38753970b2f031517cd586.jpg" alt="1b12cd068e07006a45255e9d83b38753970b2f031517cd586" style="zoom:80%;"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;【游戏不锐评】VA-11-Hall-A-Cyberpunk-Bartender-Action-——-调制饮料，改变人生&quot;&gt;&lt;a href=&quot;#【游戏不锐评】VA-11-Hall-A-Cyberpunk-Bartender-Action-——-调制饮料，改变人生&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【GAME101】图形学学习记录——光线追踪</title>
    <link href="http://example.com/undefined/7f87aff.html"/>
    <id>http://example.com/undefined/7f87aff.html</id>
    <published>2024-12-29T09:09:29.000Z</published>
    <updated>2025-02-19T14:37:45.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【GAME101】图形学学习记录——光线追踪"><a href="#【GAME101】图形学学习记录——光线追踪" class="headerlink" title="【GAME101】图形学学习记录——光线追踪"></a>【GAME101】图形学学习记录——光线追踪</h1><h2 id="阴影映射-Shadow-Mapping"><a href="#阴影映射-Shadow-Mapping" class="headerlink" title="阴影映射(Shadow Mapping)"></a>阴影映射(Shadow Mapping)</h2><p>在着色部分中，我们学习了如何表现出一个物体被光线照射时表现出的效果。但是着色无法解决一个问题：如何表现阴影。在光栅化的领域中，解决这一问题的方法是<strong>阴影映射</strong>。</p><p>阴影映射的重要思想是：<strong>如果一个点可以被我们看到，且它不在阴影里，那么这个点既可以被摄像机看到，也可以被光源看到。</strong>阴影映射只能处理点光源产生的阴影，并且结果非零即一。我们称之为<strong>硬阴影</strong>。</p><p><strong>第一步</strong>：在光源处放一个摄像机，看向我们想要渲染的场景，我们会得到一幅图。我们要做的是将这幅图上所有点的深度记录下来。</p><p><strong>第二步</strong>：在原本的摄像机处看向场景，对于任意一点，我们将其投影回它在上一步得到的图中的位置。将其和之前记录的深度进行比较，如果深度一致，说明这个点可以被光源看到。</p><p>阴影映射虽然能解决着色产生不了阴影的问题，但它有着极大的缺点，即只能生成硬阴影，这使得用这种方法产生的阴影在很多情况下并不真实。虽然现在已经有了一些关于这个问题的解决方法，但比较麻烦。</p><p>因为光栅化无法很好地解决软阴影和多个光源存在时的渲染等问题，光线追踪的技术应运而生。光线追踪的速度较慢，但质量非常高，因此常被应用于离线场景中（如动画制作）。</p><h2 id="基础光线追踪算法"><a href="#基础光线追踪算法" class="headerlink" title="基础光线追踪算法"></a>基础光线追踪算法</h2><h3 id="光线"><a href="#光线" class="headerlink" title="光线"></a>光线</h3><p>要了解光线追踪，我们首先要了解光线。一般来说，我们认为的光线有以下特点：</p><ul><li>光线沿直线传播</li><li>光线之间不会发生碰撞</li><li>光线从光源出发，到眼睛结束</li></ul><h3 id="光线投射"><a href="#光线投射" class="headerlink" title="光线投射"></a>光线投射</h3><p>对于上面第三点，有一个性质：<strong>光路的可逆性</strong>，即对于从光源到眼睛的一条光路，也可以认为是从眼睛发射出的感知光线投射到了光源，路径完全相同，只不过方向相反。光线追踪就利用了这个性质。</p><p>在光线追踪的场景里，我们假设眼睛是一个点。对于着色平面上的每一个像素，我们从眼睛处向其投射一道光线（后文简称为eye_ray），eye_ray第一个触碰到的点即为眼睛会看到的点。再将这个点投影向光源，即可根据能否到达光源判断这个点有没有被物体遮挡。当进行完这一过程后，我们已经得到了入射方向、观测方向、法线等信息，可以进行着色。如下图所示：</p><p><img src="/undefined/7f87aff/image-20241230220233799.png" alt="Ray Casting"></p><h3 id="递归的光线追踪-Whitted-Style-Ray-Tracing"><a href="#递归的光线追踪-Whitted-Style-Ray-Tracing" class="headerlink" title="递归的光线追踪(Whitted-Style Ray Tracing)"></a>递归的光线追踪(Whitted-Style Ray Tracing)</h3><p>在上述的过程中，光线仍然只反射了一次，而在现实生活中，光线是会反射很多次的。<strong>Whitted-Style Ray Tracing</strong>模拟了这一情形。</p><p>如下图所示，当光线照射到玻璃球上时，一部分光会发生折射，另一部分会发生发射，由此产生了多条光路，由此产生多个着色点。每个着色点着色的值都会被计算到成像平面的像素中。</p><p><img src="/undefined/7f87aff/image-20241230220757228.png" alt="Recursive Ray Tracing"></p><h3 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h3><p>虽然上面的过程十分清晰，但实际上有许多技术细节较难实现，主要是如何求eye_ray和物体表面的交点。</p><p>首先，我们要知道光线在数学上的定义。光线本质上是一条射线，它有一个起点o和一个方向d。对于光线上任意一个点，都可以用以下形式表示：</p><script type="math/tex; mode=display">r(t)=o+td\quad0\leq t<\infty</script><h4 id="隐式表示"><a href="#隐式表示" class="headerlink" title="隐式表示"></a>隐式表示</h4><p>以球体为例，球面的隐式表示为：</p><script type="math/tex; mode=display">(p-c)^2-R^2=0</script><p><img src="/undefined/7f87aff/image-20250101183346862.png" alt="sphere"></p><p>将两者联立，即可得到我们要找的交点p。</p><p>同理，对于任意图形的隐式表示，我们只需要将光线代入图形函数，即可求出交点位置：</p><script type="math/tex; mode=display">r(t)=o+td\quad 0\leq t<\infty \\p:f(p)=0 \\f(o+td)=0</script><p>当求出的t为正实数是，说明其有意义。</p><h4 id="显式表示"><a href="#显式表示" class="headerlink" title="显式表示"></a>显式表示</h4><p>对于显示表示，我们先考虑怎么实现光线与三角形求交。这个问题可以分成两部分：先求出光线和三角形所在平面的交点，再判断交点是否在三角形内。</p><p>我们可以用一个方向（法线）和一个平面上的点来定义任意一个平面，这样就可以轻松得到平面的显式表示。接下来的操作和之前相同。</p><script type="math/tex; mode=display">r(t)=0+td \quad 0\leq t<\infty \\p:(p-p\prime)\cdot N=o \\</script><p>联立解得：</p><script type="math/tex; mode=display">t=\frac {(p\prime -o)\cdot N}{d\cdot N}</script><p><img src="/undefined/7f87aff/image-20250101195520417.png" alt="image-20250101195520417"></p><p>判断点是否在三角形内的方法在之前的光栅化部分有所讲解，这里不再重复。</p><p><strong>以下是一种可以直接算出光线与三角形的交点并判断其是否在三角形内的算法：Moller Trumbore算法。</strong></p><p><img src="/undefined/7f87aff/image-20250101200341477.png" alt="Moller Trumbore"></p><p>在知道了怎么求光线和三角形的交点后，我们只需要求出光线和每一个三角形的交点，取最近的那个即是eye_ray和物体表面的交点。但是这样做的资源消耗太大了，有没有什么加速的方法呢？</p><h4 id="加速结构"><a href="#加速结构" class="headerlink" title="加速结构"></a>加速结构</h4><p><strong>包围盒(Bounding-Box)</strong>是指完全包裹住物体的一块体积。在这里，我们通常使用<strong>轴对齐包围盒(Axis-Aligned Bounding Box,AABB)</strong>，它是三组对面的交集，相当于划定了x、y、z的范围。</p><p><img src="/undefined/7f87aff/image-20250101202453704.png" alt="AABB"></p><p>一个重要思想：<strong>当光线不与包围盒相交时，它也一定不与物体相交。</strong></p><p>首先，我们来了解如何判定光线和包围盒是否相交。</p><p>先考虑二维的情况。对于光线和包围盒的两组对面，我们能求出光线进入对面的时间和离开对面的时间（即使得出的时间是负的）。这样我们就得到了两条线段，对这两条线段求交集即可得到光线进出包围盒的时间。如图所示：</p><p><img src="/undefined/7f87aff/image-20250101203633220.png" alt="2D"></p><p>三维空间内的做法类似。对于三组对面，我们分别求出三个光线进入对面的时间tmin和三个光线离开对面的时间tmax，取最大的tmin和最小的tmax，即为光线进入和离开包围盒的时间。如果进入的时间小于离开的时间，说明光线和包围盒有交点，反之说明没有交点。</p><p>接下来再考虑时间为负的情况。如果离开时间texit<0，说明包围盒在光线的“后面”，一定没有交点。如果t exit>=0且离开时间t enter&lt;0，说明光源在包围盒内，这时一定有交点。</0，说明包围盒在光线的“后面”，一定没有交点。如果t></p><p>总结一下，光线和包围盒有交点的条件为：</p><script type="math/tex; mode=display">t_{enter}<t_{exit}\&\&t_{exit}>=0</script><p>对于一个场景，我们找出它的一个包围盒，将包围盒均匀划分为一堆格子，并找出那些与物体表面相交的格子。当光线进入包围盒时，我们计算它将与哪些格子相交，当光线与那些和物体表面相交的格子相交时，光线就有可能和物体相交。这时，我们再做光线和物体的求交。这样大大降低了计算时的性能消耗，因为我们认为计算光线和盒子是否相交是非常快的。</p><p><img src="/undefined/7f87aff/image-20250102162426229.png" alt="grims"></p><p>以上方法只适用于场景中的物体比较均匀且密集的情况，如果场景较为空旷，光线会穿过许多空格子，造成性能浪费。</p><p><strong>空间划分(Spatial Partitions)</strong>是上面这种方法的改进。它的思想是在空旷的地方用一个大盒子包围，而物体密集的地方用一个个小的格子进行划分。下面是一些经典的空间划分方法：</p><p><img src="/undefined/7f87aff/image-20250102162727926.png" alt="Spatial Partitions"></p><p><img src="/undefined/7f87aff/image-20250102165315194.png" alt="KD-Tree"></p><p>KD-Tree有两个问题，一是三角形可能会同时在两个格子里，二是KD-Tree的建立并不简单直观。</p><p><strong>Object Partitions &amp; Bounding Volume Hierarchy(BVH)</strong></p><p>目前，这个结构得到了广泛的应用，因为塔它基本上解决了KD-Tree的物体。</p><p>这种结构的思想是按照物体进行划分。对于一些三角形，先求出它们的一个包围盒。将这些三角形按某种方法分成两部分，对这两部分三角形重新求包围盒，重复操作，直到满足一定的标准。</p><p><img src="/undefined/7f87aff/image-20250102172307429.png" alt="Object Partitions"></p><p>这样做的好处是每个三角形只会出现在一个包围盒里，但是包围盒之间也有可能产生重叠，在划分时应该尽可能减少这种重叠。</p><p>一种简单的划分方法是沿着最长的轴进行划分，并且每次都从之间的三角形处进行划分，这样建立的树较为平衡。有一种可以在O(n)时间内找到无序数列中第i大的数的算法，叫做快速选择。我们可以用这种方法快速找到最中间的三角形。</p><h2 id="辐射度量学-Radiometry"><a href="#辐射度量学-Radiometry" class="headerlink" title="辐射度量学(Radiometry)"></a>辐射度量学(Radiometry)</h2><p> 虽然我们之前花了大量的篇幅讲述如何模拟现实中的光照情况，但其仍然是做了许多简化的，例如我们将光简单地定义为一个点及光强，而在现实中显然不是这样。而通过辐射度量学，我们将精准地赋予光一系列物理量，把光及物体的表面和光如何作用等细节精确地表示出来。</p><h3 id="物理量"><a href="#物理量" class="headerlink" title="物理量"></a>物理量</h3><p>辐射度量学定义了光照的若干属性，如Radiant flux（光通量）,intensity（光强）,irradiance（辉度）,radiance（光亮度）。接下来将一一讲解。</p><h4 id="Radiant-Energy-and-Flux-Power"><a href="#Radiant-Energy-and-Flux-Power" class="headerlink" title="Radiant Energy and Flux(Power)"></a>Radiant Energy and Flux(Power)</h4><p>Radiant Energy表示的是光源辐射出来的能量，而Radiant flux是单位时间内的能量，即光通量，类似于功率。</p><script type="math/tex; mode=display">Q[J=Joule] \\\phi =\frac {dQ}{dt}\quad[W=Watt][lm=lumen]^*</script><h4 id="Radiant-Intensity-Irradiance-and-Radiance"><a href="#Radiant-Intensity-Irradiance-and-Radiance" class="headerlink" title="Radiant Intensity,Irradiance and Radiance"></a>Radiant Intensity,Irradiance and Radiance</h4><p><strong>Intensity</strong>定义了某个<strong>单位立体角内的光通量</strong>。所谓的立体角是二维角度在三维空间中的延伸。从一个球的球心向球面投影一块面积，面积除以球半径的平方就是对应立体角的大小。</p><script type="math/tex; mode=display">I(\omega)=\frac {d\phi}{d\omega}\quad[\frac \omega{sr}][\frac {lm}{sr}=cd=candela]</script><p><strong>Irradiance</strong>是指<strong>单位面积上的光通量</strong>。</p><script type="math/tex; mode=display">E(x)=\frac{d\phi(x)}{dA}\quad [\frac W{m^2}][\frac{lm}{m^2}=lux]</script><p>而<strong>Radiance</strong>定义了<strong>单位立体角和单位面积上的光通量</strong>，这意味着我们要对光通量做两次微分：</p><script type="math/tex; mode=display">L(p,\omega)=\frac{d^2\phi(p,\omega)}{d\omega dAcos\theta}\quad[\frac W{srm^2}][\frac{cd}{m^2}=\frac{lm}{srm^2}=nit]</script><p><img src="/undefined/7f87aff/image-20250103173408968.png" alt="Radiance"></p><p>Radiance和Irradiance之间的差异就是方向性。</p><h3 id="Bidirectional-Reflectance-Distribution-Function-BRDF"><a href="#Bidirectional-Reflectance-Distribution-Function-BRDF" class="headerlink" title="Bidirectional Reflectance Distribution Function(BRDF)"></a>Bidirectional Reflectance Distribution Function(BRDF)</h3><p>BRDF的意思是双向反射分布函数。这个函数真实地定义了反射的过程。它描述了有多少能量如果从某个方向进来，它会怎么向不同的方向分散。我们也可以理解成光线照射到某一个物体表面被吸收，物体表面再将能量发射出去。从这个角度，我们就可以用Radiance和Irradiance来理解反射。如图所示：</p><p><img src="/undefined/7f87aff/image-20250103185546708.png" alt="Reflection"></p><p>从一个单位立体角照射而来的Radiance被一小块单位面积dA吸收，得到了dA的Irradiance，而BRDF能告诉我们dA向各个方向单位立体角辐射的Radiance的大小。</p><p><img src="/undefined/7f87aff/image-20250103190008969.png" alt="BRDF"></p><script type="math/tex; mode=display">f_r(\omega_i\to\omega_r)=\frac{dL_r(\omega_r)}{dE_i(\omega_i)}=\frac{dL_r(\omega_r)}{L_i(\omega_i)cos\theta_id\omega_i}\quad[\frac1{sr}]</script><p>将每一个方向的入射光对出射光方向的贡献加起来，就可以得到出射光方向的光照效果。以下就是<strong>反射方程</strong>：</p><script type="math/tex; mode=display">L_r(p,\omega_r)=\int_{H^2}f_r(p,\omega_i\to\omega_r)L_i(p,\omega_i)cos\theta_id\omega_i</script><p>用更通用的方式重写这个方程，并考虑物体自身发光的情况，就得到了<strong>渲染方程</strong>：</p><script type="math/tex; mode=display">L_o(p.\omega_o)=L_e(p,\omega_o)+\int_{\Omega+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)(n\cdot \omega_i)d\omega_i</script><p>将光线传播写成算子形式，并进行展开，可以得到：</p><script type="math/tex; mode=display">L=E+KE+K^2E+K^3E+...</script><p>这中间的过程比较复杂，这里不做说明。我们需要知道的是，上面这个公式的意思是，全局光照由直接光照和间接光照相加得到，间接光照包括一次反射、两次反射、三次反射……。</p><h2 id="路径追踪"><a href="#路径追踪" class="headerlink" title="路径追踪"></a>路径追踪</h2><h3 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h3><p>在开始接下来的学习之前，我们先复习一些概率论的知识。</p><p>随机变量：</p><script type="math/tex; mode=display">X</script><p>随机变量服从于某种分布：</p><script type="math/tex; mode=display">X\sim p(x)</script><p>X可能的取值：</p><script type="math/tex; mode=display">x_i</script><p>X取xi概率：</p><script type="math/tex; mode=display">p_i</script><p>需要满足的要求：</p><script type="math/tex; mode=display">p_i\geq 0 \\\sum_{i=1}^np_i=1</script><p>期望：</p><script type="math/tex; mode=display">E[X]=\sum_{i=1}^nx_ip_x</script><p>在连续的情况下：</p><script type="math/tex; mode=display">p(x)\geq0 \quad and\quad\int p(x)dx=1 \\E[X]=\int xp(x)dx</script><p>概率密度函数(Probability Distribution Function,PDF)：</p><p><img src="/undefined/7f87aff/image-20250103225614329.png" alt="PDF"></p><p>随机变量是函数的情况：</p><script type="math/tex; mode=display">X\sim p(x) \\Y=f(X) \\E[Y]=E[f[X]]=\int f(x)p(x)dx</script><h3 id="蒙特卡洛积分"><a href="#蒙特卡洛积分" class="headerlink" title="蒙特卡洛积分"></a>蒙特卡洛积分</h3><p>蒙特卡洛积分是一种求复杂函数定积分的值的方法。它的思想是在积分范围内随机取一点并将以积分范围为底，随机点处的值为高的长方形的面积近似当作定积分的值。重复多次并求平均，结果会越来越精准。</p><script type="math/tex; mode=display">\int_a^bf(x)dx \\X_i\sim p(x) \\N_N=\frac1N\sum_{i=1}N\frac{f(X_i)}{p(X_i)}</script><h3 id="路径追踪的实现"><a href="#路径追踪的实现" class="headerlink" title="路径追踪的实现"></a>路径追踪的实现</h3><p>之前我们得到了渲染方程，而接下来的工作就是去解这个方程。而渲染方程中最重要的部分是一个定积分，我们将用蒙特卡洛方法去解这个定积分。</p><p>忽略物体自身发光的情况，渲染方程如下：</p><script type="math/tex; mode=display">L_o(p.\omega_o)=\int_{\Omega+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)(n\cdot \omega_i)d\omega_i</script><p><strong>首先我们只考虑直接光照。</strong>为了方便计算，我们假设对每个方向进行采样的概率相等。这样一来，我们就可以写出积分的蒙特卡洛形式：</p><script type="math/tex; mode=display">L_O(P,\Omega_o)=\int_{\Omega+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)(n\cdot\omega_i)d\omega_i\approx\frac1N\sum_{i=1}^N\frac{L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)(n\cdot\omega_i)}{p(\omega_i)} \\p(\omega_i)=\frac1{2\pi}</script><p>伪代码：</p><p><img src="/undefined/7f87aff/image-20250104165044537.png" alt="Path Tracing"></p><p><strong>接下来考虑包含间接光照的情况。</strong>对于着色点p，假设有一点q在受到光源照射后会反射给p，那么我们用直接光照的算法算出q点向四周辐射的能量，再将q点当作光源，就可以用相同的方法算出q点对于p点的贡献。伪代码：</p><p><img src="/undefined/7f87aff/image-20250104170016058.png" alt="Indirect"></p><p>虽然上面的想法很美好，但还有一个严重的问题：随着反射次数的提升，光线的数量会呈指数级增长，而这样的性能消耗是我们无法承受的。目前来说，路径追踪的做法是令n=1（这样显然会造成结果的不精确，解决方法会在之后细说），这样无论反射多少次，光线都不会增加。我们在每一个像素内取许多个采样点，对于每个采样点都连一条到达光源的路径，这在一定程度上和蒙特卡洛积分中取n个采样点的做法相同。这也是这个方法被称为路径追踪的原因。令n!=1的做法叫做分布式光线追踪。</p><p><img src="/undefined/7f87aff/image-20250104174103187.png" alt="Ray Generation"></p><p>另一个问题是，这个算法是一个递归的算法，但是它没有设置递归出口。这个问题的解决方法是<strong>“俄罗斯轮盘赌”</strong>。</p><p>我们都知道俄罗斯轮盘赌是一个概率问题，而在这里，它的思想是设置一个概率p，在每一次计算时，有p的概率会发射一条光线出去，得到的着色结果是Lo/p，而有(1-p)的概率不发射光线出去，得到的结果自然是0.这样做的好处是，最终得到的期望依旧是Lo。伪代码：</p><p><img src="/undefined/7f87aff/image-20250104175231862.png" alt="RR"></p><p>以上就是路径追踪的大致内容。</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>在进行蒙特卡洛采样时，如果用完全随机的方法，路径到达光源的几率较低，这样很多光线就被浪费了。如果我们能找到一个更好的采样方法，这个问题将会得到改善。</p><p>如果只在光源上进行采样，那么所有的光线都将到达光源，自然不会产生浪费。问题是蒙特卡洛积分要求采样位置和积分位置相同，因此我们要将渲染方程中对方位角的积分改写成对光源面积的积分，下面直接给出结果：</p><p><img src="/undefined/7f87aff/image-20250104181456138.png" alt="Sampling the Light"></p><p>这样，对于光源产生的光照，我们直接进行计算，而对于间接光照，我们仍使用俄罗斯轮盘赌的方法，伪代码如下：</p><p><img src="/undefined/7f87aff/image-20250104181716179.png" alt="final"></p><p>当然，还要注意光源被物体遮挡的情况。</p><p><img src="/undefined/7f87aff/image-20250104182026794.png" alt="shade"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;【GAME101】图形学学习记录——光线追踪&quot;&gt;&lt;a href=&quot;#【GAME101】图形学学习记录——光线追踪&quot; class=&quot;headerlink&quot; title=&quot;【GAME101】图形学学习记录——光线追踪&quot;&gt;&lt;/a&gt;【GAME101】图形学学习记录——光线</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【GAMES101]图形学学习记录——几何</title>
    <link href="http://example.com/undefined/a5e850e2.html"/>
    <id>http://example.com/undefined/a5e850e2.html</id>
    <published>2024-12-27T10:59:06.000Z</published>
    <updated>2025-02-19T14:40:06.123Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【GAMES101-图形学学习记录——几何"><a href="#【GAMES101-图形学学习记录——几何" class="headerlink" title="【GAMES101]图形学学习记录——几何"></a>【GAMES101]图形学学习记录——几何</h1><p>在现实生活中，物体有各种各样的形状，在这一节中，我们将学习如何在图形学中表示这些不同的形状。</p><h2 id="隐式和显式几何表示"><a href="#隐式和显式几何表示" class="headerlink" title="隐式和显式几何表示"></a>隐式和显式几何表示</h2><h3 id="隐式几何表示"><a href="#隐式几何表示" class="headerlink" title="隐式几何表示"></a>隐式几何表示</h3><p>只包含构成几何形状的点满足的<strong>关系</strong>，不包含这些点的具体位置，通常为一个函数。例如一个球的隐式表示：</p><script type="math/tex; mode=display">x^2+y^2+z^2=1</script><p>通常用以下方式表示：</p><script type="math/tex; mode=display">f(x,y,z)=x^2+y^2+z^2-1=0</script><p>隐式表示很容易判断一个点在不在几何平面上，但很难找出几何平面上有哪些点。</p><h3 id="显式几何表示"><a href="#显式几何表示" class="headerlink" title="显式几何表示"></a>显式几何表示</h3><p>直接将几何形状上的所有的点都表示出来，或者通过参数映射的方法定义的表面。参数映射的解释如下：</p><p><img src="/undefined/a5e850e2/image-20241228181255365.png" alt="image-20241228181255365"></p><p>显式表示很容易判断哪些点在平面上，但很难判断一个点在平面上，平面内还是平面外。</p><h2 id="不同的隐式表示"><a href="#不同的隐式表示" class="headerlink" title="不同的隐式表示"></a>不同的隐式表示</h2><p>之前所说函数形式的隐式表示虽然能表示出一个几何图形，但我们很难直观地通过一个复杂的函数知道这个几何图形的形状。以下是一些其他的隐式表示方法。</p><ul><li><strong>CSG(Constructive Solid Geometry)</strong>：通过对基础的几何体做一些简单的布尔运算来表示复杂的几何体。如图所示：</li></ul><p><img src="/undefined/a5e850e2/image-20241228190253928.png" alt="CSG"></p><ul><li><strong>Distance Functions(距离函数)</strong>：对于任何一个几何图形，不直接描述它的表面，而是描述如何一个点到这个表面的最近距离。求出两个物体的距离函数，并进行融合，就可以得到新的物体。（怎么感觉更不直观了</li></ul><p><img src="/undefined/a5e850e2/image-20241228192735963.png" alt="Distance Functions"></p><h2 id="不同的显式表示"><a href="#不同的显式表示" class="headerlink" title="不同的显式表示"></a>不同的显式表示</h2><ul><li><p><strong>点云</strong>：不考虑物体是一个表面，而是表面上的一些点，当足够精细时就和平面相差无几。</p></li><li><p><strong>多边形面</strong>：大多数是三角形和四边形。用多边形的组合来描述几何图形。在图形学中的应用最为广泛。</p><p>  .obj文件：一种文本文件，分别记录了一堆点，一堆法线和一堆纹理坐标，再将它们组织起来来描述图形。</p></li></ul><h2 id="曲线-Curves"><a href="#曲线-Curves" class="headerlink" title="曲线(Curves)"></a>曲线(Curves)</h2><h3 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h3><p>用一系列控制点去定义某一个曲线。</p><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>假设在时间0-1内，时间0在起始点，时间1在结束点，我们要算出在任意时间0-1中任意时刻点在空间中的位置。对于n个控制点（n&gt;2），我们在每两个相邻的点之间连一条线段，并在这个线段上找到使其比例为t的点。当进行一轮这样的操作后，我们得到了n-1个点。重复以上操作，直到最终只剩下一个点，这个点就是时间t所在的点。当我们枚举时间t，得到的点连成的就是贝塞尔曲线。图解如下：</p><p><img src="/undefined/a5e850e2/image-20241228224711812.png" alt="贝塞尔曲线"></p><script type="math/tex; mode=display">b^n(t)=b_0^n(t)=\sum_{j=0}^nb_jB_j^n(t) \\B_i^n(t)=C_n^it^i(1-t)^{n-i} \\B_i^nt被称为伯恩斯坦多项式</script><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ul><li>贝塞尔曲线的起点是第一个控制点，终点是最后一个控制点。</li><li>起点处切线的方向一定为b2-b1，终点处的方向一定为bn-b(n-1)。</li><li>控制点经过仿射变换后，生成的贝塞尔曲线形状不会改变。</li><li>控制点得到的曲线一定在控制点形成的<strong>凸包</strong>内。</li></ul><h4 id="逐段控制的贝塞尔曲线"><a href="#逐段控制的贝塞尔曲线" class="headerlink" title="逐段控制的贝塞尔曲线"></a>逐段控制的贝塞尔曲线</h4><p>当控制点过多时，计算成本会增加，同时控制的效果会变差。因此，更高效的做法是逐段用少量控制点（通常是四个）来逐段控制曲线。</p><h3 id="B-splines（B样条）"><a href="#B-splines（B样条）" class="headerlink" title="B-splines（B样条）"></a>B-splines（B样条）</h3><p>样条是一种完全可控的曲线，而B样条是贝塞尔曲线的延伸，它具有局部性，在改动控制点时影响的范围有限。</p><h2 id="曲面"><a href="#曲面" class="headerlink" title="曲面"></a>曲面</h2><h3 id="贝塞尔曲面"><a href="#贝塞尔曲面" class="headerlink" title="贝塞尔曲面"></a>贝塞尔曲面</h3><p>贝塞尔曲面是由贝塞尔曲线得到的。原理和双线性插值基本相同，我们在两个方向上分别应用贝塞尔曲线即可。</p><h2 id="三角形的细分和简化"><a href="#三角形的细分和简化" class="headerlink" title="三角形的细分和简化"></a>三角形的细分和简化</h2><h3 id="三角形的细分"><a href="#三角形的细分" class="headerlink" title="三角形的细分"></a>三角形的细分</h3><p>有的时候，三角形数量不足会导致模型不够精细，这时候，我们希望能增加三角形的数量来提升模型的精细度。细分通常分为两步：将一个三角形分成多个三角形，之后调整这些三角形的位置使其符合模型。</p><h4 id="Loop细分-Loop-Subdivision"><a href="#Loop细分-Loop-Subdivision" class="headerlink" title="Loop细分(Loop Subdivision)"></a>Loop细分(Loop Subdivision)</h4><p>将三角形三边的中点连起来，就得到了四个小的三角形。以前的顶点称为旧的顶点，中点称为新的顶点。</p><p>对于新的顶点，如果它被两个三角形共享，则它的位置由这两个三角形的旧的顶点加权得出。和它在同一条线段上的两个顶点的权值是3/8，另外两个顶点的权值是1/8。如图所示：</p><p><img src="/undefined/a5e850e2/image-20241229160151471.png" alt="New Vertex"></p><p>对于旧的顶点，定义n为顶点的度，定义u为和n有关的数，当n=3时，u=3/16，否则u=3/(8n)。旧的顶点的位置有自己和周围的点加权得出，如图所示：</p><p><img src="/undefined/a5e850e2/image-20241229160945037.png" alt="Old Vertex"></p><h4 id="Catmull-Clark细分"><a href="#Catmull-Clark细分" class="headerlink" title="Catmull-Clark细分"></a>Catmull-Clark细分</h4><p>Loop细分只能对三角形做细分，而Catmull-Clark细分在一般的情况下也能进行操作。</p><p>定义非四边形为所有边数不为4的多边形，奇异点为度不等于4的点。对所有的边都取中点，所有的面也取中心点，将中点和中心点连起来就产生了更多的多边形。当进行这样一次操作后，奇异点的数量增加了非四边形的数量，所有非四边形都消失，并且之后不会再有奇异点的增加和非四边形的出现。效果如下：</p><p><img src="/undefined/a5e850e2/image-20241229162632162.png" alt="Catmull-Clark"></p><p>每个点位置的更新方式如下图所示：</p><p><img src="/undefined/a5e850e2/image-20241229163314152.png" alt="Catmull-Clark Vertex Update Rules"></p><h3 id="三角形的简化"><a href="#三角形的简化" class="headerlink" title="三角形的简化"></a>三角形的简化</h3><p>有的时候（例如当物体离摄像机很远的时候），物体的精细程度并不十分重要，在这种情况下，我们希望用更少的三角形来表示物体，以达到减少性能消耗的目的。</p><h4 id="边坍缩-Edge-Collapse"><a href="#边坍缩-Edge-Collapse" class="headerlink" title="边坍缩(Edge Collapse)"></a>边坍缩(Edge Collapse)</h4><p>想象有一条边，当我们捏住它的两个顶点并重叠到一起，这条边就不复存在了。这就是边坍缩的概念。但是对于一个物体来说，我们怎么知道哪些边不重要，可以进行坍缩，哪些不能呢？这里需要用到<strong>二次误差度量</strong>的概念。<strong>二次误差度量是指顶点到到和它相邻的所有平面的距离的平方和</strong>。</p><p>在进行边坍缩时，优先坍缩二次误差度量最小的边即可。但是，当我们对一条边进行坍缩后，和它相邻的边会受到影响，导致二次误差度量受到影响，这使得我们无法先计算所有边的二次误差度量，再依次进行坍缩。在这里，我们可以用最小堆的数据结构进行计算。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;【GAMES101-图形学学习记录——几何&quot;&gt;&lt;a href=&quot;#【GAMES101-图形学学习记录——几何&quot; class=&quot;headerlink&quot; title=&quot;【GAMES101]图形学学习记录——几何&quot;&gt;&lt;/a&gt;【GAMES101]图形学学习记录——几何&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【GAMES101】图形学学习记录——着色</title>
    <link href="http://example.com/undefined/61766197.html"/>
    <id>http://example.com/undefined/61766197.html</id>
    <published>2024-12-26T14:01:01.000Z</published>
    <updated>2025-02-19T14:39:38.266Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【GAMES101】图形学学习记录——着色-Shading"><a href="#【GAMES101】图形学学习记录——着色-Shading" class="headerlink" title="【GAMES101】图形学学习记录——着色(Shading)"></a>【GAMES101】图形学学习记录——着色(Shading)</h1><p>简而言之，着色就是为物体附上不同材质的过程。</p><h2 id="Blinn-Phong模型"><a href="#Blinn-Phong模型" class="headerlink" title="Blinn-Phong模型"></a>Blinn-Phong模型</h2><p>Blinn-Phong模型简单地展示了一个<strong>着色点</strong>在受到光线照射时会表现出什么颜色。</p><p>输入：<strong>观测方向v</strong>，<strong>平面法线n</strong>，<strong>光照方向l</strong>，<strong>表面参数</strong>（颜色，反光度等）。</p><p><img src="/undefined/61766197/image-20241227010440816.png" alt="Blinn-Phong"></p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>在Blinn-Phong模型中，物体在受到光照后展现出的效果由三个部分组成：<strong>漫反射</strong>，<strong>高光反射</strong>，<strong>环境光照</strong>。</p><h4 id="漫反射"><a href="#漫反射" class="headerlink" title="漫反射"></a>漫反射</h4><p>光线照射在物体表面时向四周反射的现象被称为漫反射。公式如下：</p><script type="math/tex; mode=display">L_d=k_d(I/r^2)max(\vec n·\vec l) \\k_d:漫反射系数(和材质对光线的吸收率有关) \\I:光源的光照强度 \\r:光源到着色点的距离 \\</script><h4 id="镜面反射"><a href="#镜面反射" class="headerlink" title="镜面反射"></a>镜面反射</h4><p>当我们处于特定的角度观察较为光滑的物体时，会看到物体表面会有明亮的高光，这就是镜面反射产生的效果。</p><p>特定的角度为当观察方向(v)和镜面反射的方向(r)足够接近时（范围由材质决定）。</p><p>计算v和r的距离较为麻烦，因此我们可以用<strong>半程向量(h)</strong>和平面法线(n)之间的距离来代替。</p><p><img src="/undefined/61766197/image-20241227150555453.png" alt="specular"></p><p>半程向量的计算公式以及高光反射的计算公式。</p><script type="math/tex; mode=display">\vec h=bisector(\vec v,\vec l) =\frac {\vec v+\vec l}{||\vec v+\vec l||} \\L_s=k_s(I/r^2)max(0,cos\alpha)^p \\=k_s(I/r^2)max(0,\vec n·\vec h)^p \\k_s:镜面反射系数 \\I:光源光照强度 \\r:光源到着色的的距离 \\p:用于增大余弦曲线的参数</script><p>值得注意的是p这个参数。在现实生活中能看到高光的范围是很小的，但是因为余弦函数的曲线变化较为缓慢，即使观察距离和镜面反射角度相差较大，余弦值也仍然较高。通过进行p次方运算（p通常取120-150），可以是余弦函数曲线快速下降，保证只有在较小范围内能看到高光。</p><h4 id="环境光照"><a href="#环境光照" class="headerlink" title="环境光照"></a>环境光照</h4><p>顾名思义，环境光照是指环境中的光线照射产生的效果。公式如下：</p><script type="math/tex; mode=display">L_a=k_aI_a \\k_a:环境光系数 \\I_a:环境光强度</script><h4 id="Blinn-Phong反射"><a href="#Blinn-Phong反射" class="headerlink" title="Blinn-Phong反射"></a>Blinn-Phong反射</h4><p>将以上三种反射相加就得到了Blinn-Phong模型中的反射结果。</p><script type="math/tex; mode=display">L=L_a+L_d+L_s</script><h2 id="着色频率"><a href="#着色频率" class="headerlink" title="着色频率"></a>着色频率</h2><p>当确定了着色方式后，着色频率是接下来需要考虑的重要一环。着色频率决定了资源消耗和着色效果。如果着色频率过高，最终的着色效果会很好，但需要消耗大量资源；如果着色频率过低，消耗的资源相对较小，但效果可能不尽如人意。以下是几种典型的着色频率。</p><ul><li><strong>flat shading</strong>:对于每一个平面，根据平面的法线进行着色。</li><li><strong>Gouraud shading</strong>:对平面的每个顶点根据顶点的法线进行着色，平面内部的着色由顶点着色结果插值得出。</li><li><strong>Phong shading</strong>:求出每个顶点的法线并进行着色，对内部的每个像素都进行插值。</li></ul><p>如果我们知道了每个平面的法线，我们要如何得到每个顶点的法线？一种简单的做法是将与这个顶点相邻的平面的法线求平均：</p><script type="math/tex; mode=display">N_v=\frac {\Sigma_iN_i}{||\Sigma_iN_i||}</script><h2 id="图形管线（实时渲染管线）"><a href="#图形管线（实时渲染管线）" class="headerlink" title="图形管线（实时渲染管线）"></a>图形管线（实时渲染管线）</h2><p><strong>图形管线(Graphics Pipeline)</strong>是指渲染时的一套固定流程。</p><p><img src="/undefined/61766197/image-20241227155457889.png" alt="Graphics Pipeline"></p><p>当输入一堆三维空间中的顶点后，经过顶点处理、三角形处理、光栅化、片元处理、帧缓冲操作后就得到了输出：一个图像（由一组像素组成）。</p><h2 id="纹理映射"><a href="#纹理映射" class="headerlink" title="纹理映射"></a>纹理映射</h2><p>之前提到，一个着色点呈现出的效果和它的参数有关，但是我们不可能依次给每个着色点设置我们想要的参数。<strong>纹理映射(Texture Mapping)</strong>可以将二维的材质图包裹在三维物体的表面。以下是实现方法。</p><p>我们知道，三维物体是由一个个三角形组成的，那么我们可以将这些三角形映射二维材质图上的三角形中。这样一来，在进行纹理映射时，我们只需要找出三维物体的三角形和二维材质图的三角形之间的关系即可。我们使用uv坐标来实现。</p><p><img src="/undefined/61766197/image-20241227161719703.png" alt="uv"></p><h2 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h2><p>之前我们提到过，可以利用<strong>插值</strong>的方法得到平面内部的一些值。当计算完三角形顶点的属性后，利用插值可以在三角形内部进行平滑的过渡。</p><p>插值的原理是三角形内部的每个点根据其在三角形中的位置都有一个重心坐标(α,β,γ)。对于三角形ABC来说：</p><script type="math/tex; mode=display">(x,y)=\alpha A+\beta B+\gamma C \\\alpha +\beta +\gamma =1</script><p>重心坐标的求法是面积比：</p><script type="math/tex; mode=display">\alpha=\frac{A_a}{A_a+A_b+A_c}=\frac{-(x-x_B)(y_C-y_B)+(y-y_B)(x_C-x_B)}{-(x_A-x_B)(y_C-y_B)+(y_A-y_B)(x_C-x_B)} \\\beta=\frac{A_b}{A_a+A_b+A_c}=\frac{-(x-x_C)(y_A-y_C)+(y-y_C)(x_A-x_C)}{-(x_B-x_C)(y_A-y_C)+(y_B-y_C)(x_A-x_C)} \\\gamma=\frac{A_c}{A_a+A_b+A_c}=1-\alpha-\beta</script><p>对于任意要插值的属性V，计算公式如下：</p><script type="math/tex; mode=display">V=\alpha V_A+\beta V_B+\gamma V_C</script><h2 id="纹理放大和纹理缩小"><a href="#纹理放大和纹理缩小" class="headerlink" title="纹理放大和纹理缩小"></a>纹理放大和纹理缩小</h2><p>在理想情况下，物体大小和纹理大小应该是相同且一一对应的，但是在实际情况中，物体在不同的距离看起来会变大或变小，导致纹理和物体不能完全匹配，我们需要用一些方法来解决这个问题。</p><h3 id="纹理放大"><a href="#纹理放大" class="headerlink" title="纹理放大"></a>纹理放大</h3><p>当物体过近时，纹理对于物体来说过小，物体上点可能不会被准确地映射到纹理上的点上，而是一些点之间。解决这个问题的方法是<strong>双线性插值</strong>。</p><p>首先我们需要了解什么是线性插值。对于两个点v0,v1之间的点x，它的插值为：</p><script type="math/tex; mode=display">lerp(x,v_0,v_1)=v0+x(v_1-v_0)</script><p>而双线性插值则是在二维平面上做插值。</p><p><img src="/undefined/61766197/image-20241227180002234.png" alt="lerp"></p><p>首先我们要先在x轴方向做两次插值，得到u0和u1的位置，再用这两个点做一次线性插值，即可得到双线性插值的结果，公式如下：</p><script type="math/tex; mode=display">lerp(x, v_0, v_1) = v_0 + x(v_1-v0) \\u_0 = lerp(s, u_{00}, u_{10}) \\u_1 = lerp(s, u_{01}, u_{11}) \\f (x, y) = lerp(t, u_0, u_1)</script><p>有一种精度更高的插值方法:Bicubic插值，对周围十六个点做插值。</p><h3 id="纹理缩小"><a href="#纹理缩小" class="headerlink" title="纹理缩小"></a>纹理缩小</h3><p>当物体距离过远时，一个像素映射到纹理上的区域过大，采样不足导致走样，这和之前光栅化部分说到的走样的原理是相同的。可以将像素划分为多个小像素，但开销过大。如果可以快速得到像素对应纹理上这一片区域的平均值，就可以在一定程度上解决这个问题。</p><p><strong>Mipmap</strong>：这是一种快速，不准确，只针对正方形区域的范围查询。首先我们对纹理进行预处理，产生多层纹理，每一层纹理的分辨率都为之前的一半，直到1x1。在进行纹理映射时，只需要选择最接近的纹理即可。</p><p><strong>各向异性过滤</strong>：不止是正方形，长宽可以不同比例。课程中没有具体描述实现过程。大致原理是对映射点周围方形8个或更多的像素进行取样，获得平均值平均后映射到像素点上。</p><h2 id="纹理的应用"><a href="#纹理的应用" class="headerlink" title="纹理的应用"></a>纹理的应用</h2><p>在现代的GPU中，我们可以将纹理理解成一块内存，我们可以在上面做各种操作（点查询、范围查询）。</p><h3 id="环境光照-1"><a href="#环境光照-1" class="headerlink" title="环境光照"></a>环境光照</h3><p>可以用纹理来映射任何环境中照射来的光（例如犹他茶壶）。通常假设环境光都是从无限远处照射而来。</p><p>我们可以把整个环境光都记录在一个球上，并像地球仪转换为世界地图一样将其展开。但是这样会导致球的上下两端展开后产生扭曲。一个解决方法是将球体替换成边长和球直径相同的正方体。</p><h3 id="影响着色结果"><a href="#影响着色结果" class="headerlink" title="影响着色结果"></a>影响着色结果</h3><p>之前，我们都用纹理来替代Blinn-Phong模型中的kd，来影响物体的颜色。其实，纹理也可以改变其他属性，例如凹凸贴图（法线贴图），我们可以用纹理记录物体每一个位置的相对高度（法线移动的距离和方向），来造成凹凸不平的效果。计算方法如下：</p><p><img src="/undefined/61766197/image-20241228171808315.png" alt="image-20241228171808315"></p><p>现在的做法：使用<strong>位移贴图</strong>，通过改变三角形的顶点位置来产生更逼真的效果。需要模型足够精细，三角形数量够多。</p><h3 id="三维纹理"><a href="#三维纹理" class="headerlink" title="三维纹理"></a>三维纹理</h3><p>三维纹理不止存储物体表面的材质，还有三维空间任何一个点的材质。可以在三维空间中添加一个噪声函数，经过一系列处理后得到任意一点的效果。</p><h3 id="存储之前计算好的结果"><a href="#存储之前计算好的结果" class="headerlink" title="存储之前计算好的结果"></a>存储之前计算好的结果</h3><p>例如，在着色时我们不会考虑阴影等物体，当计算完阴影后，我们可以将环境光遮蔽贴图记录下来，并在之后直接应用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;【GAMES101】图形学学习记录——着色-Shading&quot;&gt;&lt;a href=&quot;#【GAMES101】图形学学习记录——着色-Shading&quot; class=&quot;headerlink&quot; title=&quot;【GAMES101】图形学学习记录——着色(Shading)&quot;&gt;&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【GAMES101】图形学学习记录——光栅化</title>
    <link href="http://example.com/undefined/6cf9a142.html"/>
    <id>http://example.com/undefined/6cf9a142.html</id>
    <published>2024-12-24T14:11:40.000Z</published>
    <updated>2025-02-19T14:38:54.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【GAMES101】图形学学习记录——光栅化"><a href="#【GAMES101】图形学学习记录——光栅化" class="headerlink" title="【GAMES101】图形学学习记录——光栅化"></a>【GAMES101】图形学学习记录——光栅化</h1><p>我们想要显示的三维模型基本上都是由大量多边形（一般为三角形）组成的，而将这些三角形渲染在屏幕上的过程即为光栅化。</p><h2 id="视锥"><a href="#视锥" class="headerlink" title="视锥"></a>视锥</h2><p>首先，我们要知道我们的屏幕的信息。<br><img src="/undefined/6cf9a142/screen.png" alt></p><p><strong>fovY</strong>：这是一个角度，表示观测点距离平面的竖直范围。</p><p><strong>Aspect ratio</strong>：宽高比，字面意思，为平面宽和高的比值。</p><p>通过下面这张图，我们可以知道以上两个值和之前在投影部分所说物体的t、b、l、r等值的关系，具体如下：<br><img src="/undefined/6cf9a142/fov to lrbt.png" alt="alt text"></p><script type="math/tex; mode=display">tan\frac {fovY}2=\frac t{|n|}</script><script type="math/tex; mode=display">aspect=\frac rt</script><h2 id="屏幕"><a href="#屏幕" class="headerlink" title="屏幕"></a>屏幕</h2><p>什么是屏幕？在这里，我们将其简单地认为屏幕由一组具有单个颜色的像素排列而成。<br><img src="/undefined/6cf9a142/array of pixels.png" alt="alt text"></p><p>光栅化的过程即为决定每一个像素应该显示什么颜色的过程。</p><h2 id="视口变换"><a href="#视口变换" class="headerlink" title="视口变换"></a>视口变换</h2><p>在正交投影时，我们将物体转换到了一个(-1,1)^3的正则立方体中，而在视口变换中，我们要将其显示在我们的屏幕中。</p><p>做法为将立方体的XY平面拉伸为屏幕的宽高。</p><script type="math/tex; mode=display">M_{viewport}=\begin{bmatrix}\frac{width}2 & 0 & 0 & \frac{width}2 \\0 & \frac{height}2 & 0 & \frac{height}2 \\0 & 0 & 1 & 0 \\0 & 0 & 0 & 1\end{bmatrix}</script><h2 id="判断像素是否在三角形内"><a href="#判断像素是否在三角形内" class="headerlink" title="判断像素是否在三角形内"></a>判断像素是否在三角形内</h2><p>现在，我们已经将物体（即组成它的三角形）在屏幕上表示出来了，但是如何判断一个像素在不在某个三角形内，该不该被渲染呢？</p><p>将两个向量做叉积，可以得到新的向量，新的向量垂直于这两个向量，方向与这两个向量有关，例如在右手坐标系中：</p><script type="math/tex; mode=display">\vec x \times \vec y=\vec z</script><p>用叉积判断像素是否在三角形内的方法如下图所示：<br><img src="/undefined/6cf9a142/pointInTriangle.png" alt="alt text"></p><script type="math/tex; mode=display">若\overrightarrow {P_0P_1}\times\overrightarrow {P_0Q},\overrightarrow {P_1P_2}\times\overrightarrow {P_1Q},\overrightarrow {P_2P_0}\times\overrightarrow {P_2Q}得到的三个向量的值全都大于0或全都小于0，则点在三角形内部。</script><p>注意，这里我们用来判断的点是<strong>像素的中心</strong>。</p><p>如果一个点在三角形的边缘，我们可以自行决定这个点在三角形内部还是三角形外部。</p><p>优化：一个三角形的范围有限，将整个屏幕的像素都判断一遍较为浪费资源。因此，我们可以为每个三角形建立一个Bounding Box，只需要将Bounding Box内的像素比较。如图：<br><img src="/undefined/6cf9a142/BoundongBox1.png" alt="alt text"></p><p>或者是按行或列建立的Bounding Box（适用于较为瘦长的三角形）：<br><img src="/undefined/6cf9a142/BoundingBox2.png" alt="alt text"></p><h2 id="反走样"><a href="#反走样" class="headerlink" title="反走样"></a>反走样</h2><p>这部分内容涉及很多理论内容，技术内容较少，因此我将简略描述。（并不是因为我懒</p><p>当我们按照上面的方法进行三角形的光栅化后，我们会发现，得到的结果和我们想象中的差很多，边缘会有很多“锯齿”。对于这种现象，我们称之为<strong>走样</strong>。<br><img src="/undefined/6cf9a142/Jaggie.png" alt="alt text"></p><p>走样的本质原因是采样的频率过低，采样的结果的高频部分混叠导致的信息丢失。我们可以砍掉三角形的高频信息，根据三角形在像素内的覆盖面积进行模糊，再进行采样。具体的实现方法是超采样。</p><p><strong>超采样(Supersampling)</strong>：我们可以人为地在像素内模拟出多个点，分别判断这些点是否在三角形内，最终整个像素的结果有这些点综合得出（需要注意的是，最终的结果并不是像素是否在三角形内，而是一个中间结果）。<br><img src="/undefined/6cf9a142/supersampling.png" alt="alt text"></p><p>超采样的结果示例：<br><img src="/undefined/6cf9a142/superSamplingResult.png" alt="alt text"></p><p>如今工业界已经有了许多抗锯齿的手段，例如<strong>MSAA</strong>、<strong>FXAA</strong>、<strong>TAA</strong>。</p><h2 id="深度缓冲-Z-buffering"><a href="#深度缓冲-Z-buffering" class="headerlink" title="深度缓冲(Z-buffering)"></a>深度缓冲(Z-buffering)</h2><p>在光栅化的过程中，我们判断哪个物体被遮挡，哪个物体没有的方法是使用深度缓冲。深度缓冲记录了每一个像素的最小深度，即每个像素中离摄像机最近的z值。在进行渲染时，我们只需要渲染离摄像机最近的物体。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;【GAMES101】图形学学习记录——光栅化&quot;&gt;&lt;a href=&quot;#【GAMES101】图形学学习记录——光栅化&quot; class=&quot;headerlink&quot; title=&quot;【GAMES101】图形学学习记录——光栅化&quot;&gt;&lt;/a&gt;【GAMES101】图形学学习记录——光</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【GAMES101】图形学学习记录——变换</title>
    <link href="http://example.com/undefined/d0768364.html"/>
    <id>http://example.com/undefined/d0768364.html</id>
    <published>2024-12-22T15:12:02.000Z</published>
    <updated>2025-02-19T14:38:38.849Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【GAMES101】图形学学习记录——变换"><a href="#【GAMES101】图形学学习记录——变换" class="headerlink" title="【GAMES101】图形学学习记录——变换"></a>【GAMES101】图形学学习记录——变换</h1><p>在正式开始学习计算机图形学之前，我们需要了解一些关于线性代数的基础知识。</p><h2 id="点和向量的表示"><a href="#点和向量的表示" class="headerlink" title="点和向量的表示"></a>点和向量的表示</h2><p>我们通常用一个二维列向量来表示一个点的位置或者一个向量，例如：</p><script type="math/tex; mode=display">\begin{bmatrix}   1\\   2\\  \end{bmatrix}</script><h2 id="矩阵的表示"><a href="#矩阵的表示" class="headerlink" title="矩阵的表示"></a>矩阵的表示</h2><p>矩阵的表示方式：</p><script type="math/tex; mode=display">\left[\begin{matrix}1 & 2 & 3 \\4 & 5 & 6 \\7 & 8 & 9\end{matrix}\right]</script><h2 id="图形的变换"><a href="#图形的变换" class="headerlink" title="图形的变换"></a>图形的变换</h2><p>矩阵和向量之间可以进行加减乘除等运算，这里省略。我们知道，一个图形可以用一系列点来表示。如果我们想要对一个图形进行变换操作，我们只需要让这个图形的所有点移动到我们想要的位置即可。我们可以通过对这些点进行运算来实现这个操作。</p><h3 id="镜像变换"><a href="#镜像变换" class="headerlink" title="镜像变换"></a>镜像变换</h3><p><img src="/undefined/d0768364/Reflection.png" alt="alt text"><br>对于这个变换，我们只需要让x或y值变成相反数。</p><script type="math/tex; mode=display">\left[ \begin{matrix}   -x \\   y \\  \end{matrix}  \right] = \left[ \begin{matrix}   -1 & 0\\   0 & 1  \end{matrix}  \right] \left[ \begin{matrix}   x \\   y  \end{matrix}  \right]</script><h3 id="切变"><a href="#切变" class="headerlink" title="切变"></a>切变</h3><p><img src="/undefined/d0768364/Shear.png" alt="alt text"></p><script type="math/tex; mode=display">\left[ \begin{matrix}   x+ay \\   y \\  \end{matrix}  \right] = \left[ \begin{matrix}   1 & a\\   0 & 1  \end{matrix}  \right] \left[ \begin{matrix}   x \\   y  \end{matrix}  \right]</script><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p><img src="/undefined/d0768364/Rotate.png" alt="alt text"></p><script type="math/tex; mode=display">\left[ \begin{matrix}   cosθ*x-sinθ*y \\   sinθ*x+cosθ*y \\  \end{matrix}  \right] = \left[ \begin{matrix}   cosθ & -sinθ\\   sinθ & cosθ  \end{matrix}  \right] \left[ \begin{matrix}   x \\   y  \end{matrix}  \right]</script><h3 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h3><p><img src="/undefined/d0768364/Translation.png" alt="alt text"></p><script type="math/tex; mode=display">\left[\begin{matrix}x+tx \\y+ty\end{matrix}\right]=\left[\begin{matrix}x \\y\end{matrix}\right]+\left[\begin{matrix}tx \\ty\end{matrix}\right]</script><h2 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h2><p>我们可以注意到，前三个变换都是用变换矩阵乘以点的形式，而平移操作需要我们用点的向量加上平移矩阵。有没有一种方法可以将平移操作也统一成乘法形式？</p><p>答案是<strong>齐次坐标</strong>。</p><p>我们将所有n维的矩阵和向量都加上一个维度，例如：</p><script type="math/tex; mode=display">\begin{bmatrix}   1\\   2\\\end{bmatrix}=>\begin{bmatrix}   1\\   2\\   0\end{bmatrix}</script><script type="math/tex; mode=display">\begin{bmatrix}1 & 2 \\3 & 4\end{bmatrix}=>\begin{bmatrix}1 & 2 & 0 \\3 & 4 & 0 \\0 & 0 & 1\end{bmatrix}</script><p>我们可以在多出来的这一个维度中表示平移的操作，例如：</p><script type="math/tex; mode=display">\begin{bmatrix}   x+tx\\   y+ty\\   0\end{bmatrix}=\begin{bmatrix}1 & 0 & tx \\0 & 1 & ty \\0 & 0 & 1\end{bmatrix}\begin{bmatrix}   x\\   y\\   0\end{bmatrix}</script><p>而对于向量矩阵来说，多出来的这个维度也有其作用。例如下面这个向量：</p><script type="math/tex; mode=display">\begin{bmatrix}   x\\   y\\   w\end{bmatrix}</script><p>当w=0时，这个向量矩阵表示的就是一个向量。当w=1时，这个向量矩阵表示的是一个点。</p><p>而当w!=0且w!=1时，它表示的如下的点：</p><script type="math/tex; mode=display">\begin{bmatrix}   x/w\\   y/w\\   1\end{bmatrix}</script><p>对于前三种变换矩阵，我们只需要加上一个维度即可，例如旋转：</p><script type="math/tex; mode=display">\begin{bmatrix}   cosθ & -sinθ\\   sinθ & cosθ  \end{bmatrix}=>\begin{bmatrix}   cosθ & -sinθ & 0\\   sinθ & cosθ & 0 \\   0 & 0 & 1  \end{bmatrix}</script><h2 id="变换的组合"><a href="#变换的组合" class="headerlink" title="变换的组合"></a>变换的组合</h2><p>如果我们想对对象进行一系列变换，我们只需要依次对对象左乘变换即可，但是要注意顺序。</p><p>例如，我们想对X做变换M1,M2,…Mn，乘积的顺序应该是：</p><script type="math/tex; mode=display">X'=Mn*...*M3*M2*M1*X</script><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="三维空间中的旋转公式"><a href="#三维空间中的旋转公式" class="headerlink" title="三维空间中的旋转公式"></a>三维空间中的旋转公式</h3><p>绕x轴：</p><script type="math/tex; mode=display">\begin{bmatrix}1 & 0 & 0 & 0\\0 & cosθ & -sinθ & 0  \\0 & sinθ & cosθ & 0 \\0 & 0 & 0 & 1\end{bmatrix}</script><p>绕y轴：</p><script type="math/tex; mode=display">\begin{bmatrix}cosθ & 0 & sinθ & 0\\0 & 1 & 0 & 0  \\-sinθ & 0 & cosθ & 0 \\0 & 0 & 0 & 1\end{bmatrix}</script><p>绕z轴：</p><script type="math/tex; mode=display">\begin{bmatrix}cos & -sinθ & 0 & 0\\sinθ & cosθ & 0 & 0  \\0 & 0 & 1 & 0 \\0 & 0 & 0 & 1\end{bmatrix}</script><h3 id="绕任意轴的旋转公式"><a href="#绕任意轴的旋转公式" class="headerlink" title="绕任意轴的旋转公式"></a>绕任意轴的旋转公式</h3><script type="math/tex; mode=display">R(n,α)=cos(α)I+(1-cos(α))nn^T+sin(α)\begin{bmatrix}0 & -n_z & n_y \\n_z & 0 & -n_x \\-n_y & n_x & 0\end{bmatrix}</script><h2 id="观测变换"><a href="#观测变换" class="headerlink" title="观测变换"></a>观测变换</h2><p>现在我们已经知道了在一个坐标空间中的物体是如何摆放和移动的，但是如果我们想要表示出我们是如何“看到”它们的，我们要怎么做呢？</p><p>例如，在现实生活中，火车的轨道是平行的，但是我们却能看到铁轨在远处交汇。通过观测变换，我们就能知道摄像机在指定的位置看到的物体是什么样的。</p><p>观测变换(MVP变换)分为：<strong>模型变换</strong>（模型摆放的位置）、<strong>视图变换</strong>（确定摄像机的位置和方向，并保证所有物体跟随摄像机移动）、<strong>投影变换</strong>（将三维空间的物体投影到二维平面上。</p><p>我们的重点是<strong>投影变换</strong>。</p><h3 id="相机的摆放"><a href="#相机的摆放" class="headerlink" title="相机的摆放"></a>相机的摆放</h3><p>以(0,0,0)为原点，将摄像机放在原点上，并以y轴方向为摄像机的上方向，使摄像机看向-z方向。这样摆放符合右手坐标系。</p><h3 id="投影变换"><a href="#投影变换" class="headerlink" title="投影变换"></a>投影变换</h3><p>投影变换分为两种：正交投影和透视投影。前者不遵循近大远小法则，而后者较为接近我们现实中看到的情况。</p><h4 id="正交投影"><a href="#正交投影" class="headerlink" title="正交投影"></a>正交投影</h4><p>假设物体在如下的立方体中，我们要做的是将其移动到正则立方体（(-1,1)^3）中。之后如何将其显示在屏幕上，我们会在下一节“光栅化”中讲解。<br><img src="/undefined/d0768364/cuboid.png" alt="alt text"></p><p>这个过程比较简单，我们只需要将其启动到原点，再进行缩放。变换矩阵如下：</p><script type="math/tex; mode=display">M_{ortho}=\begin{bmatrix}2/(r-1) & 0 & 0 & 0 \\0 & 2/(t-b) & 0 & 0 \\0 & 0 & 2/(n-f) & 0 \\0 & 0 & 0 & 1\end{bmatrix}\begin{bmatrix}1 & 0 & 0 & -(r+l)/2 \\0 & 1 & 0 & -(t+b)/2\\0 & 0 & 1 & -(n+f)/2 \\0 & 0 & 0 & 1\end{bmatrix}</script><h4 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h4><p>在透视投影中，我们要投影的是如下所示的一个棱台。直接做投影比较困难，但是我们可以将其“压缩”成一个长方体后再对其做正交投影。</p><p>所谓的压缩是指我们需要将较远的大平面压缩为和n处小平面相同大小。其中假设n和f固定。</p><p><img src="/undefined/d0768364/Perspective.png" alt="alt text"></p><p>压缩的过程可以用下图进行推导，这里不详细解释。<br><img src="/undefined/d0768364/SimilarTriangle.png" alt="alt text"></p><p>变换矩阵如下：</p><script type="math/tex; mode=display">M_{persp->ortho}=\begin{bmatrix}n & 0 & 0 & 0 \\0 & n & 0 & 0\\0 & 0 & n+f & -nf \\0 & 0 & 1 & 0\end{bmatrix}</script><p>之后的过程和正交投影相同。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;【GAMES101】图形学学习记录——变换&quot;&gt;&lt;a href=&quot;#【GAMES101】图形学学习记录——变换&quot; class=&quot;headerlink&quot; title=&quot;【GAMES101】图形学学习记录——变换&quot;&gt;&lt;/a&gt;【GAMES101】图形学学习记录——变换&lt;/</summary>
      
    
    
    
    
  </entry>
  
</feed>
